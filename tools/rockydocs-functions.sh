#!/bin/bash

# Rocky Linux Documentation - Function Library
# Modular function library for rockydocs.sh
# Contains all utility functions, setup logic, and serving modes
#
# Author: Wale Soyinka
# Contributors: 
# Ai-Contributors: Claude (claude-sonnet-4-20250514), Gemini (gemini-2.5-pro)

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Print functions
print_success() { echo -e "${GREEN}✅ $1${NC}"; }
print_info() { echo -e "${BLUE}ℹ️  $1${NC}"; }
print_warning() { echo -e "${YELLOW}⚠️  $1${NC}"; }
print_error() { echo -e "${RED}❌ $1${NC}"; }
print_command() { echo -e "${YELLOW}Running: $1${NC}"; }

# Execute command with echo
run_cmd() {
    print_command "$1"
    eval "$1"
}

# === UTILITY FUNCTIONS ===

# Resource cleanup handler
CLEANUP_RESOURCES=()
cleanup_on_exit() {
    local exit_code=$?
    if [ ${#CLEANUP_RESOURCES[@]} -gt 0 ]; then
        print_warning "Cleaning up resources..."
        for resource in "${CLEANUP_RESOURCES[@]}"; do
            if [[ "$resource" =~ ^pid: ]]; then
                local pid="${resource#pid:}"
                kill "$pid" 2>/dev/null || true
                print_info "Terminated PID $pid"
            elif [[ "$resource" =~ ^dir: ]]; then
                local dir="${resource#dir:}"
                rm -rf "$dir" 2>/dev/null || true
                print_info "Cleaned directory $dir"
            elif [[ "$resource" =~ ^file: ]]; then
                local file="${resource#file:}"
                rm -f "$file" 2>/dev/null || true
                print_info "Cleaned file $file"
            elif [[ "$resource" =~ ^container: ]]; then
                local container="${resource#container:}"
                stop_docker_container "$container"
                print_info "Stopped container $container"
            fi
        done
    fi
    exit $exit_code
}
trap cleanup_on_exit EXIT INT TERM

# Add resource to cleanup list
add_cleanup_resource() {
    CLEANUP_RESOURCES+=("$1")
}

# Load saved workspace configuration
load_workspace_config() {
    if [ -f "$CONFIG_FILE" ]; then
        source "$CONFIG_FILE"
    fi
}

# Save workspace configuration
save_workspace_config() {
    local workspace_path="$1"
    mkdir -p "$CONFIG_DIR"
    cat > "$CONFIG_FILE" << EOF
# Rocky Linux Documentation Workspace Configuration
# This file is automatically generated and managed
SAVED_WORKSPACE_BASE_DIR="$workspace_path"
EOF
    print_success "Workspace configuration saved to: $CONFIG_FILE"
}

# Setup mkdocs configuration
setup_mkdocs_config() {
    local build_type="$1"
    local working_dir="${2:-$PWD}"
    
    cd "$working_dir"
    
    if [ "$build_type" = "full" ]; then
        run_cmd "cp -f configs/mkdocs.full.yml mkdocs.yml"
        print_info "Using full config (all languages)"
    else
        run_cmd "cp -f configs/mkdocs.minimal.yml mkdocs.yml"
        print_info "Using minimal config (English + Ukrainian)"
    fi
}

# Manage content symlink with proper cleanup
manage_content_symlink() {
    local action="$1"
    local target="${2:-$CONTENT_DIR/docs}"
    local link_name="${3:-content}"
    
    case "$action" in
        "create")
            run_cmd "rm -rf $link_name"
            run_cmd "ln -sf $target $link_name"
            add_cleanup_resource "file:$PWD/$link_name"
            ;;
        "backup")
            if [ -e "$link_name" ]; then
                run_cmd "rm -f ${link_name}-backup-current"
                run_cmd "mv $link_name ${link_name}-backup-current"
            fi
            ;;
        "restore")
            run_cmd "rm -f $link_name"
            if [ -e "${link_name}-backup-current" ]; then
                run_cmd "mv ${link_name}-backup-current $link_name"
            fi
            ;;
        "clean")
            run_cmd "rm -f $link_name ${link_name}-backup-current"
            ;;
    esac
}

# Activate virtual environment with error handling
activate_venv() {
    local venv_path="${1:-venv}"
    if [ ! -d "$venv_path" ]; then
        print_error "Virtual environment not found: $venv_path"
        return 1
    fi
    source "$venv_path/bin/activate" || {
        print_error "Failed to activate virtual environment"
        return 1
    }
}

# Improved error handling for commands
run_cmd_with_rollback() {
    local cmd="$1"
    local rollback_cmd="$2"
    local error_msg="${3:-Command failed}"
    
    print_command "$cmd"
    if ! eval "$cmd"; then
        print_error "$error_msg"
        if [ -n "$rollback_cmd" ]; then
            print_warning "Attempting rollback: $rollback_cmd"
            eval "$rollback_cmd" 2>/dev/null || true
        fi
        return 1
    fi
    return 0
}

# Check and resolve port conflicts
check_and_resolve_port_conflict() {
    local port="$1"
    local force_kill="${2:-false}"
    
    if lsof -i ":$port" >/dev/null 2>&1; then
        local process_info=$(lsof -i ":$port" 2>/dev/null | tail -n 1 | awk '{print $1 " (PID " $2 ")"}')
        local pid=$(lsof -ti ":$port" 2>/dev/null)
        
        print_warning "Port $port is already in use by $process_info"
        
        if [ "$force_kill" = "true" ]; then
            print_info "Automatically terminating conflicting process..."
            if kill "$pid" 2>/dev/null; then
                print_success "Terminated PID $pid (was using port $port)"
                sleep 2
                return 0
            else
                print_error "Failed to terminate PID $pid"
                return 1
            fi
        else
            print_info "Options:"
            print_info "  1. Terminate the conflicting process automatically"
            print_info "  2. Use a different port"
            print_info "  3. Cancel and resolve manually"
            read -p "Choose (1-3): " choice
            
            case "$choice" in
                1)
                    if kill "$pid" 2>/dev/null; then
                        print_success "Terminated PID $pid (was using port $port)"
                        sleep 2
                        return 0
                    else
                        print_error "Failed to terminate PID $pid"
                        return 1
                    fi
                    ;;
                2)
                    print_info "Using alternative port 8002"
                    return 2  # Signal to use alternative port
                    ;;
                3)
                    print_info "Please manually terminate the process: kill $pid"
                    return 1
                    ;;
                *)
                    print_error "Invalid choice"
                    return 1
                    ;;
            esac
        fi
    fi
    
    return 0  # Port is available
}

# Kill all documentation-related processes
kill_all_doc_processes() {
    print_info "Cleaning up all documentation server processes..."
    
    # Kill mike serve processes
    local mike_pids=$(pgrep -f "mike serve" 2>/dev/null || true)
    if [ -n "$mike_pids" ]; then
        echo "$mike_pids" | xargs kill 2>/dev/null || true
        print_info "Terminated mike serve processes: $mike_pids"
    fi
    
    # Kill Python HTTP servers on documentation ports
    for port in 8000 8001 8002; do
        if lsof -i ":$port" >/dev/null 2>&1; then
            local pid=$(lsof -ti ":$port" 2>/dev/null)
            local process_name=$(lsof -i ":$port" 2>/dev/null | tail -n 1 | awk '{print $1}')
            if [[ "$process_name" == "Python" ]] || [[ "$process_name" == "python"* ]]; then
                kill "$pid" 2>/dev/null || true
                print_info "Terminated $process_name (PID $pid) on port $port"
            fi
        fi
    done
    
    # Kill mkdocs serve processes
    local mkdocs_pids=$(pgrep -f "mkdocs serve" 2>/dev/null || true)
    if [ -n "$mkdocs_pids" ]; then
        echo "$mkdocs_pids" | xargs kill 2>/dev/null || true
        print_info "Terminated mkdocs serve processes: $mkdocs_pids"
    fi
    
    sleep 2
    print_success "All documentation server processes cleaned up"
}

# Detect current Rocky version from git branch
detect_version() {
    local branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "main")
    case "$branch" in
        rocky-8) echo "8" ;;
        rocky-9) echo "9" ;;
        main) echo "10" ;;
        *) echo "10" ;;
    esac
}

# Utility function: Find available port with fallback
find_available_port() {
    local port
    for port in "$@"; do
        if ! lsof -i ":$port" >/dev/null 2>&1; then
            echo "$port"
            return 0
        fi
    done
    return 1
}

# Docker container utility functions
get_docker_container_name() {
    local service_type="$1"  # serve, deploy, etc.
    echo "rockydocs-${service_type}-${USER}"
}

stop_docker_container() {
    local container_name="$1"
    if docker ps -q -f name="$container_name" >/dev/null 2>&1; then
        print_info "Stopping existing container: $container_name"
        docker stop "$container_name" >/dev/null 2>&1 || true
    fi
    if docker ps -a -q -f name="$container_name" >/dev/null 2>&1; then
        docker rm "$container_name" >/dev/null 2>&1 || true
    fi
}

get_docker_container_status() {
    local container_name="$1"
    if docker ps -q -f name="$container_name" >/dev/null 2>&1; then
        echo "running"
    elif docker ps -a -q -f name="$container_name" >/dev/null 2>&1; then
        echo "stopped"
    else
        echo "not_found"
    fi
}

check_docker_health() {
    local container_name="$1"
    local port="$2"
    local max_attempts="${3:-30}"
    local attempt=0
    
    while [ $attempt -lt $max_attempts ]; do
        # First check if container is still running
        if ! docker ps --format "table {{.Names}}" | grep -q "^$container_name$"; then
            print_error "Container $container_name stopped running"
            return 1
        fi
        
        # Then check if service is responding
        if curl -s "http://localhost:$port" >/dev/null 2>&1; then
            return 0
        fi
        sleep 1
        attempt=$((attempt + 1))
    done
    return 1
}

# Docker volume management functions
create_docker_volumes() {
    local workspace_volume="rockydocs-workspace-${USER}"
    local content_volume="rockydocs-content-${USER}"
    
    # Create workspace volume if it doesn't exist
    if ! docker volume inspect "$workspace_volume" >/dev/null 2>&1; then
        print_info "Creating Docker volume for workspace: $workspace_volume"
        docker volume create "$workspace_volume" >/dev/null 2>&1
    fi
    
    # Create content volume if it doesn't exist
    if ! docker volume inspect "$content_volume" >/dev/null 2>&1; then
        print_info "Creating Docker volume for content: $content_volume"
        docker volume create "$content_volume" >/dev/null 2>&1
    fi
    
    echo "$workspace_volume $content_volume"
}

# Docker volume cleanup function
cleanup_docker_volumes() {
    local workspace_volume="rockydocs-workspace-${USER}"
    local content_volume="rockydocs-content-${USER}"
    
    print_warning "This will remove Docker volumes containing your workspace data"
    read -p "Remove Docker volumes? (y/N): " confirm
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        print_info "Removing Docker volumes..."
        docker volume rm "$workspace_volume" >/dev/null 2>&1 || true
        docker volume rm "$content_volume" >/dev/null 2>&1 || true
        print_success "Docker volumes removed"
    else
        print_info "Docker volume cleanup cancelled"
    fi
}

# Docker volume status check
show_docker_volume_status() {
    local workspace_volume="rockydocs-workspace-${USER}"
    local content_volume="rockydocs-content-${USER}"
    
    echo "  • Docker volumes:"
    
    if docker volume inspect "$workspace_volume" >/dev/null 2>&1; then
        local volume_size=$(docker system df -v 2>/dev/null | grep "$workspace_volume" | awk '{print $3}' || echo "unknown")
        echo "    - $workspace_volume (size: $volume_size)"
    else
        echo "    - $workspace_volume (not created)"
    fi
    
    if docker volume inspect "$content_volume" >/dev/null 2>&1; then
        local volume_size=$(docker system df -v 2>/dev/null | grep "$content_volume" | awk '{print $3}' || echo "unknown")
        echo "    - $content_volume (size: $volume_size)"
    else
        echo "    - $content_volume (not created)"
    fi
}

cleanup_docker_containers() {
    local user_containers=$(docker ps -a -q -f name="rockydocs-.*-${USER}" 2>/dev/null || true)
    if [ -n "$user_containers" ]; then
        print_info "Cleaning up Docker containers..."
        echo "$user_containers" | xargs docker rm -f >/dev/null 2>&1 || true
    fi
}

# === HELP FUNCTIONS ===

# Main help
show_help() {
    cat << EOF
Rocky Linux Documentation - Master Contributor Script v$FULL_VERSION

DESCRIPTION:
  Recreates the exact look and feel of https://docs.rockylinux.org locally
  for contributors to preview their changes before pushing.

USAGE:
  $0 [COMMAND] [OPTIONS]

COMMANDS:
  --setup     Setup local development environment
  --serve     Serve existing deployed versions (fast)
  --serve-dual  Dual server mode: mike serve + mkdocs live reload
  --deploy    Build and deploy all versions locally (slow)
  --clean     Clean workspace and build artifacts
  --reset     Reset saved configuration
  --status    Show system status

GLOBAL OPTIONS:
  --minimal   Use English + Ukrainian only (default, faster) - setup only
  --full      Use all languages (slower, complete testing) - setup only
  --workspace PATH  Custom workspace location
  --help, -h  Show this help

EXAMPLES:
  ./rockydocs-dev-12.sh --setup --venv              # Setup Python venv environment
  ./rockydocs-dev-12.sh --deploy                    # Build and deploy versions locally
  ./rockydocs-dev-12.sh --serve                     # Fast serve (after deploy)
  ./rockydocs-dev-12.sh --serve --static            # Static production-like serve
  ./rockydocs-dev-12.sh --serve-dual                # Dual server with live reload
  ./rockydocs-dev-12.sh --setup --full              # Setup with all languages (config set once)
  ./rockydocs-dev-12.sh --deploy                    # Build using setup's language config

SUBCOMMAND HELP:
  ./rockydocs-dev-12.sh --setup -h                  # Detailed setup help
  ./rockydocs-dev-12.sh --serve -h                  # Detailed serve help
  ./rockydocs-dev-12.sh --serve-dual -h             # Dual server help
  ./rockydocs-dev-12.sh --deploy -h                 # Detailed deploy help

WORKFLOW:
  1. git checkout rocky-9                            # Choose your target version
  2. ./rockydocs-dev-12.sh --setup --venv           # Setup environment (once)
  3. ./rockydocs-dev-12.sh --deploy                 # Build/deploy versions to local repo
  4. ./rockydocs-dev-12.sh --serve                  # Fast serve for editing
  5. git add . && git commit && git push             # Push your source changes to origin

Current Rocky Linux version: $(detect_version) (branch: $(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown"))
EOF
}

# Setup command help
show_setup_help() {
    cat << EOF
Rocky Linux Documentation - Setup Environment

DESCRIPTION:
  Sets up local development environment that recreates the exact look and feel 
  of https://docs.rockylinux.org on your local machine.

USAGE:
  $0 --setup [ENVIRONMENT] [OPTIONS]

ENVIRONMENTS:
  --venv      Use Python virtual environment (recommended)
  --docker    Use Docker container (containerized environment)
  --podman    Use Podman container

OPTIONS:
  --minimal   Setup for English + Ukrainian only (default, faster)
  --full      Setup for all languages (complete testing)
  --workspace PATH  Custom workspace location

THIS COMMAND RUNS:
  - mkdir -p $WORKSPACE_BASE_DIR
  - Searches for existing docs.rockylinux.org repository to reuse OR
  - git clone https://github.com/rocky-linux/docs.rockylinux.org.git $APP_DIR
  - ln -sf docs.rockylinux.org $WORKSPACE_BASE_DIR/app  (compatibility symlink)
  - cd $APP_DIR
  
  For --venv (default):
  - python3 -m venv venv
  - source venv/bin/activate
  - pip install -r requirements.txt
  
  For --docker:
  - docker build -t rockydocs-dev .
  - Creates Docker volumes for data persistence
  - ln -sf $CONTENT_DIR/docs $APP_DIR/docs
  - cp configs/mkdocs.minimal.yml ./mkdocs.yml  (if --minimal)
  - cp configs/mkdocs.full.yml ./mkdocs.yml     (if --full)
  - Saves workspace configuration to ~/.config/rockydocs/config

MANUAL ALTERNATIVE:
  You can run these commands yourself:
    mkdir -p $WORKSPACE_BASE_DIR
    git clone https://github.com/rocky-linux/docs.rockylinux.org.git $APP_DIR
    cd $APP_DIR && python3 -m venv venv && source venv/bin/activate
    pip install -r requirements.txt

AFTER SETUP:
  - Content editing happens in: $CONTENT_DIR/docs/
  - App environment located at: $APP_DIR
  - You can cd to app directory and run mkdocs commands directly

WORKSPACE CONFIGURATION:
  First run saves your workspace preference to ~/.config/rockydocs/config
  Subsequent runs automatically use your saved workspace location
  Use --workspace to change location (gets saved for future use)
  Script intelligently finds and reuses existing docs.rockylinux.org repositories
  
SIMPLIFIED STRUCTURE:
  workspace/
  ├── docs.rockylinux.org/     # App repo (build environment)
  ├── app -> docs.rockylinux.org  # Compatibility symlink
  └── (your content repo is wherever you cloned it)

EOF
}

# Serve command help  
show_serve_help() {
    cat << EOF
Rocky Linux Documentation - Fast Serve (No Rebuild)

DESCRIPTION:
  Starts a FAST local development server using previously deployed versions.
  Serves existing mike-deployed content from gh-pages branch without rebuilding.
  Use --deploy first to create/update versions if needed.

FEATURES:
  - FAST startup (no rebuilding)
  - Multi-version support with version selector
  - Serves pre-built content from gh-pages branch
  - Root + versioned access (/, /8/, /9/, /10/, /latest/)
  - Port fallback (8000 → 8001 → 8002 if ports busy)

USAGE:
  $0 --serve [ENVIRONMENT] [OPTIONS]

ENVIRONMENTS:
  (default)   Use Python virtual environment setup
  --docker    Use Docker container for serving

OPTIONS:
  --static    Serve static files (exact production behavior)

NOTE: --minimal/--full options only apply to --setup command. Deploy uses setup's configuration.
      Serve modes use whatever content was already deployed to gh-pages.

THIS COMMAND RUNS:
  For default (venv):
  - cd $APP_DIR
  - source venv/bin/activate
  - mike serve -a localhost:PORT --config-file mkdocs.yml (if not --static)
  - python3 -m http.server PORT -d site-static (if --static)
  
  For --docker:
  - docker run -d --name rockydocs-serve-$USER -p PORT:8000 \
    -v $APP_DIR:/app -v $CONTENT_DIR/docs:/app/content \
    rockydocs-dev mkdocs serve -a 0.0.0.0:8000 (if not --static)
  - docker run -d --name rockydocs-serve-$USER -p PORT:8000 \
    -v $APP_DIR:/app rockydocs-dev \
    python3 -m http.server 8000 -d /app/site-static (if --static)

PREREQUISITES:
  Run --deploy first to build/deploy versions:
  $0 --deploy

MANUAL ALTERNATIVE:
  cd $APP_DIR
  source venv/bin/activate
  mike serve -a localhost:8000

ACCESS:
  Local site will be available at: http://localhost:8000 (or 8001/8002)
  Live reload enabled - changes appear automatically

Current version being served: Rocky Linux $(detect_version)

EOF
}

# Help function for dual server mode
show_serve_dual_help() {
    cat << EOF
Rocky Linux Documentation - Dual Server Mode (Live Reload)

DESCRIPTION:
  Starts DUAL servers for optimal development experience:
  - Port 8000: Mike serve (multi-version with version selector)
  - Port 8001: MkDocs serve (live reload for current content)

FEATURES:
  - Mike serve (8000): Multi-version support, root + versioned access
  - MkDocs serve (8001): Live reload, --watch-theme support
  - Simultaneous operation for different use cases
  - Smart port conflict resolution
  - Proper cleanup on exit

USAGE:
  $0 --serve-dual [OPTIONS]

OPTIONS:
  --minimal   Use minimal config (English + Ukrainian)
  --venv      Use Python virtual environment
  --workspace DIR  Set workspace directory

ACCESS PATTERNS:
  Multi-version (Port 8000):
    • http://localhost:8000/          → Rocky Linux 10 (latest)
    • http://localhost:8000/10/       → Rocky Linux 10 (versioned)
    • http://localhost:8000/9/        → Rocky Linux 9
    • http://localhost:8000/8/        → Rocky Linux 8

  Live Reload (Port 8001):
    • http://localhost:8001/          → Current content with live reload
    • File changes automatically refresh browser
    • Theme changes supported with --watch-theme

NOTES:
  - Use port 8000 for testing multi-version functionality
  - Use port 8001 for active content editing with live reload
  - Both servers run simultaneously in background
  - Ctrl+C cleanly stops both servers

EOF
}

# Deploy command help
show_deploy_help() {
    cat << EOF
Rocky Linux Documentation - Build and Deploy All Versions Locally

DESCRIPTION:
  Builds and deploys ALL Rocky Linux versions (8, 9, 10) locally for testing.
  This is a ONE-TIME operation that creates the complete versioned site in your
  local build repository. It does NOT push to any remote.

USAGE:
  $0 --deploy [ENVIRONMENT] [OPTIONS]

ENVIRONMENTS:
  (default)   Use Python virtual environment setup
  --docker    Use Docker container for deployment

OPTIONS:
  (none)      Uses language configuration set during --setup

THIS COMMAND RUNS:
  For default (venv):
  - cd $APP_DIR
  - Uses existing mkdocs.yml configuration from setup
  - Deletes and recreates the local 'gh-pages' branch
  - Setup cached repositories for each version
  - source venv/bin/activate
  - mike deploy 8 --title 'Rocky Linux 8' (from rocky-8 branch)
  - mike deploy 9 --title 'Rocky Linux 9' (from rocky-9 branch)
  - mike deploy 10 latest --title 'Rocky Linux 10' (from main branch)
  - mike set-default latest
  - Applies local-only commit to serve 'latest' content from web root
  
  For --docker:
  - Uses existing mkdocs.yml configuration from setup
  - Creates temporary deployment script in container
  - docker run --name rockydocs-deploy-$USER \
    -v $APP_DIR:/app -v $CONTENT_DIR/docs:/app/content \
    rockydocs-dev bash /app/temp_deploy.sh
  - Extracts site-static artifacts from container
  - Applies web root override for production-identical serving

MANUAL ALTERNATIVE:
  cd $APP_DIR
  source venv/bin/activate  
  mike deploy 8 9 10 latest

OUTPUT:
  Deployed versions available for serving with --serve
  Use $0 --serve to start fast development server

Current version being deployed: Rocky Linux $(detect_version)

EOF
}

# === SETUP FUNCTIONS ===

# Smart repository discovery and reuse
find_existing_app_repo() {
    # Check if there's already a docs.rockylinux.org repo at workspace root level
    local potential_paths=(
        "$WORKSPACE_BASE_DIR/docs.rockylinux.org"
        "$WORKSPACE_BASE_DIR/../*/docs.rockylinux.org"  # Check sibling workspace directories
    )
    
    for path in "${potential_paths[@]}"; do
        if [ -d "$path/.git" ]; then
            local remote_url=$(cd "$path" && git remote get-url origin 2>/dev/null || echo "")
            if [[ "$remote_url" == *"docs.rockylinux.org"* ]]; then
                echo "$path"
                return 0
            fi
        fi
    done
    return 1
}

# Setup function
setup_environment() {
    local env_type="$1"
    local build_type="$2"
    
    print_info "Setting up Rocky Linux documentation environment..."
    print_info "Target: Recreate https://docs.rockylinux.org locally"
    print_info "Version: Rocky Linux $(detect_version)"
    print_info "Workspace: $WORKSPACE_BASE_DIR"
    
    # Save workspace configuration if this is first time or different from saved
    if [ ! -f "$CONFIG_FILE" ] || [ "$WORKSPACE_BASE_DIR" != "${SAVED_WORKSPACE_BASE_DIR:-}" ]; then
        save_workspace_config "$WORKSPACE_BASE_DIR"
    fi
    
    # Create workspace
    run_cmd "mkdir -p $WORKSPACE_BASE_DIR"
    
    # Smart repository handling
    if [ ! -d "$APP_DIR" ]; then
        # Check if we can reuse an existing repo
        local existing_repo=$(find_existing_app_repo)
        if [ $? -eq 0 ] && [ -n "$existing_repo" ]; then
            print_info "Found existing docs.rockylinux.org repository at: $existing_repo"
            print_info "Creating symlink to reuse existing repository..."
            run_cmd "ln -sf $existing_repo $APP_DIR"
        else
            print_info "Cloning fresh docs.rockylinux.org repository..."
            run_cmd "git clone https://github.com/rocky-linux/docs.rockylinux.org.git $APP_DIR"
        fi
    fi
    
    # Create compatibility symlink for backward compatibility
    if [ ! -e "$APP_COMPAT_LINK" ]; then
        run_cmd "ln -sf docs.rockylinux.org $APP_COMPAT_LINK"
        print_info "Created compatibility symlink: app -> docs.rockylinux.org"
    fi
    
    # Setup environment based on type
    case "$env_type" in
        "venv")
            setup_venv "$build_type"
            ;;
        "docker")
            setup_docker "$build_type"
            ;;
        "podman")
            setup_podman "$build_type"
            ;;
        *)
            print_error "Unknown environment type: $env_type"
            exit 1
            ;;
    esac
    
    print_success "Setup complete!"
    print_info "Content editing: $CONTENT_DIR/docs/"
    print_info "App environment: $APP_DIR"
    print_info "Next: $0 --serve"
}

# Setup Python virtual environment
setup_venv() {
    local build_type="$1"
    
    print_info "Setting up Python virtual environment..."
    
    run_cmd "cd $APP_DIR"
    
    if [ ! -d "venv" ]; then
        run_cmd_with_rollback "python3 -m venv venv" "rm -rf venv" "Failed to create virtual environment"
    fi
    
    # Install requirements with error handling
    if ! run_cmd_with_rollback "source venv/bin/activate && pip install -r requirements.txt" "" "Failed to install requirements"; then
        return 1
    fi
    
    # Setup content symlink using utility function
    manage_content_symlink "create" "$CONTENT_DIR/docs" "content"
    
    # Setup config using utility function
    setup_mkdocs_config "$build_type" "$APP_DIR"
}

# Setup Docker environment
setup_docker() {
    local build_type="$1"
    
    print_info "Setting up Docker environment..."
    
    # Create Dockerfile if not exists
    if [ ! -f "$APP_DIR/Dockerfile.dev" ]; then
        cat > "$APP_DIR/Dockerfile.dev" << 'EOF'
FROM python:3.9-slim

# Install git (required for mkdocs-git-revision-date-localized-plugin)
RUN apt-get update && apt-get install -y git && rm -rf /var/lib/apt/lists/*

WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .
EXPOSE 8000

CMD ["mkdocs", "serve", "-a", "0.0.0.0:8000"]
EOF
    fi
    
    
    run_cmd "cd $APP_DIR"
    run_cmd "rm -rf content && ln -sf $CONTENT_DIR/docs content"
    
    if [ "$build_type" = "minimal" ]; then
        run_cmd "cp -f configs/mkdocs.minimal.yml mkdocs.yml"
    else
        run_cmd "cp -f configs/mkdocs.full.yml mkdocs.yml"
    fi
    
    run_cmd "docker build -f Dockerfile.dev -t rockydocs-dev ."
    
    print_info "Docker image built: rockydocs-dev"
    print_info "To run: docker run -p 8000:8000 -v $CONTENT_DIR/docs:/app/content rockydocs-dev"
    print_info "Or use: ./rockydocs-dev-12.sh --serve --docker (when implemented)"
}

# Setup Podman environment
setup_podman() {
    local build_type="$1"
    
    print_info "Setting up Podman environment..."
    
    # Similar to Docker but using podman commands
    setup_docker "$build_type"  # Reuse Docker setup logic
    
    run_cmd "cd $APP_DIR"
    run_cmd "podman build -f Dockerfile.dev -t rockydocs-dev ."
    
    print_info "Podman image built: rockydocs-dev"
    print_info "To run: podman run -p 8000:8000 -v $CONTENT_DIR/docs:/app/docs rockydocs-dev"
}

# === SERVING FUNCTIONS ===

# Setup git worktrees for efficient multi-version deployment
setup_cached_repos() {
    local worktree_base="$APP_DIR/worktrees"
    local repo_url="https://github.com/rocky-linux/documentation.git"
    
    print_info "Setting up git worktrees for efficient deployment..."
    
    # Create worktree base directory if it doesn't exist
    if [ ! -d "$worktree_base" ]; then
        run_cmd "mkdir -p $worktree_base"
    fi
    
    # Check if we have the main repository
    if [ -d "$worktree_base/main/.git" ]; then
        print_info "Found existing worktree setup, using cached repositories..."
        cd "$worktree_base/main"
        cd "$APP_DIR"
    else
        # Clone main repository if we don't have it
        print_info "Creating main repository for git worktrees (one-time setup)..."
        cd "$worktree_base"
        
        # Use --reference optimization if user's content repo exists and has .git
        if [ -d "$CONTENT_DIR/.git" ]; then
            print_info "Optimizing clone using local repository reference (saves bandwidth)..."
            run_cmd "git clone --reference $CONTENT_DIR $repo_url main"
        else
            run_cmd "git clone $repo_url main"
        fi
        
        cd main
        # Fetch all branches we need
        run_cmd "git fetch origin rocky-8:rocky-8 rocky-9:rocky-9" 2>/dev/null || true
        cd "$APP_DIR"
    fi
    
    # Create worktrees for each version if they don't exist
    cd "$worktree_base/main"
    
    # Rocky Linux 8 worktree
    if [ ! -d "$worktree_base/rocky-8" ]; then
        print_info "Creating Rocky Linux 8 worktree..."
        run_cmd "git worktree add ../rocky-8 rocky-8"
        add_cleanup_resource "worktree:$worktree_base/rocky-8"
    fi
    
    # Rocky Linux 9 worktree  
    if [ ! -d "$worktree_base/rocky-9" ]; then
        print_info "Creating Rocky Linux 9 worktree..."
        run_cmd "git worktree add ../rocky-9 rocky-9"
        add_cleanup_resource "worktree:$worktree_base/rocky-9"
    fi
    
    cd "$APP_DIR"
    print_success "Git worktrees ready for efficient deployment"
}

# Deploy specific version locally
deploy_version_local() {
    local version=$1
    local branch=$2
    local alias=$3
    local title=$4
    local worktree_base="$APP_DIR/worktrees"
    local current_version=$(detect_version)
    
    print_info "Deploying Rocky Linux $version (optimized)..."
    
    if [ "$version" = "$current_version" ]; then
        # Deploy current branch content (your edits)
        print_info "Using your current content for Rocky Linux $version"
        
        # Ensure content symlink points to current docs (clean user docs first to avoid loops)
        run_cmd "rm -f $CONTENT_DIR/docs/content"  # Remove any stale content symlinks from user docs
        manage_content_symlink "create" "$CONTENT_DIR/docs" "content"
        
        if [ -n "$alias" ]; then
            run_cmd_with_rollback "source venv/bin/activate && mike deploy $version $alias --title '$title'" "" "Build had warnings for Rocky Linux $version but continuing with deployment" || {
                print_warning "Build had warnings for Rocky Linux $version but continuing with deployment"
            }
        else
            run_cmd_with_rollback "source venv/bin/activate && mike deploy $version --title '$title'" "" "Build had warnings for Rocky Linux $version but continuing with deployment" || {
                print_warning "Build had warnings for Rocky Linux $version but continuing with deployment"
            }
        fi
    else
        # Use git worktrees for efficient deployment
        local worktree_path="$worktree_base/$branch"
        if [ -d "$worktree_path" ]; then
            print_info "Using git worktree for Rocky Linux $version ($branch branch)..."
            
            # Temporarily backup current docs and use worktree content
            manage_content_symlink "backup" "$CONTENT_DIR/docs" "content"
            run_cmd "ln -sf $worktree_path/docs content"
            
            # Deploy this version
            if [ -n "$alias" ]; then
                run_cmd "source venv/bin/activate && mike deploy $version $alias --title '$title'"
            else
                run_cmd "source venv/bin/activate && mike deploy $version --title '$title'"
            fi
            
            # Restore current docs
            manage_content_symlink "restore" "$CONTENT_DIR/docs" "content"
            
            print_success "Rocky Linux $version deployed successfully (worktree)"
        else
            print_warning "No worktree found for $branch branch - skipping Rocky Linux $version"
            print_info "Run setup again to create git worktrees"
        fi
    fi
}

# Deploy all Rocky Linux versions
deploy_all_versions() {
    local current_version="$1"
    
    # Initialize git repo for mike if not exists
    if [ ! -d ".git" ]; then
        print_info "Initializing git repository for mike versioning..."
        run_cmd "git init"
        run_cmd "git config user.name 'Local Dev'"
        run_cmd "git config user.email 'dev@local.dev'"
        run_cmd "git add mkdocs.yml"
        run_cmd "git commit -m 'Initial commit for local development'"
    fi
    
    # Deploy all versions like production
    print_info "Building complete multi-version site like production..."
    deploy_version_local "8" "rocky-8" "" "Rocky Linux 8"
    deploy_version_local "9" "rocky-9" "" "Rocky Linux 9"  
    deploy_version_local "10" "main" "latest" "Rocky Linux 10"
    
    # Set default to latest
    print_info "Setting latest version as default for root access..."
    if ! run_cmd "source venv/bin/activate && mike set-default --allow-empty latest"; then
        print_error "Failed to set default version to 'latest'. Aborting."
        return 1
    fi
}

# Live serving mode with mike serve
serve_live() {
    
    print_info "🚀 FAST SERVE MODE: Using existing deployed versions from gh-pages"
    
    # Basic validation
    if [ ! -d "$APP_DIR" ]; then
        print_error "App directory not found: $APP_DIR"
        print_info "Run: $0 --setup --venv --minimal first"
        return 1
    fi
    
    if [ ! -d "$APP_DIR/venv" ]; then
        print_error "Virtual environment not found. Run: $0 --setup --venv --minimal"
        return 1
    fi
    
    cd "$APP_DIR"
    
    # Check if mike has been deployed
    if ! git show-ref --verify --quiet refs/heads/gh-pages; then
        print_error "No mike deployment found on gh-pages branch. Run: $0 --deploy first"
        return 1
    fi
    
    # Mike serve still needs a valid mkdocs.yml, but will serve from gh-pages branch
    # We need to ensure there's a valid config file and docs_dir exists
    if [ ! -f "mkdocs.yml" ]; then
        if [ -f "configs/mkdocs.minimal.yml" ]; then
            run_cmd "cp configs/mkdocs.minimal.yml mkdocs.yml"
            print_info "Created minimal mkdocs.yml for mike serve"
        else
            print_error "No mkdocs config files found"
            return 1
        fi
    fi
    
    # Ensure the docs_dir referenced in mkdocs.yml exists (mike serve requires it)
    local docs_dir=$(grep "^docs_dir:" mkdocs.yml | cut -d'"' -f2 2>/dev/null || echo "content")
    if [ ! -d "$docs_dir" ]; then
        run_cmd "mkdir -p $docs_dir"
        print_info "Created placeholder $docs_dir directory for mike serve"
    fi
    
    # Find available port with fallback
    local port=$(find_available_port 8000 8001 8002)
    if [ -z "$port" ]; then
        print_error "No available ports (8000, 8001, 8002). Kill existing processes or use different ports."
        return 1
    fi
    
    print_success "🚀 Starting FAST server on port $port"
    print_info "   • Serving pre-built content from gh-pages branch"
    print_info "   • Version selector available"
    print_info "   • No rebuilding - content already deployed"
    print_info "   • Port fallback: 8000 → 8001 → 8002"
    print_info ""
    print_info "Access: http://localhost:$port"
    print_info ""
    
    # Mike serve reads directly from gh-pages branch, no content symlink needed
    print_command "source venv/bin/activate && mike serve -a localhost:$port"
    bash -c "cd $APP_DIR && source venv/bin/activate && mike serve -a localhost:$port"
}

# Extract static site like Vercel
extract_static_site() {
    if ! git show-ref --verify --quiet refs/heads/gh-pages; then
        print_error "No gh-pages branch found - mike deployment may have failed"
        return 1
    fi
    
    print_info "Extracting static site from gh-pages branch (like Vercel)..."
    
    # Clean and create site-static directory
    run_cmd "rm -rf site-static"
    run_cmd "mkdir -p site-static"
    add_cleanup_resource "dir:$PWD/site-static"
    
    # Extract static files from gh-pages using checkout instead of archive to preserve symlinks
    print_info "Using git checkout to preserve symlinks..."
    local current_branch=$(git rev-parse --abbrev-ref HEAD)
    
    # Stash any uncommitted changes
    git stash push -m "Temporary stash for static extraction" >/dev/null 2>&1 || true
    
    # Checkout gh-pages branch temporarily
    if ! run_cmd "git checkout gh-pages"; then
        print_error "Failed to checkout gh-pages branch"
        return 1
    fi
    
    # Copy all files to site-static directory
    run_cmd "cp -r * site-static/ 2>/dev/null || true"
    run_cmd "cp -r .[^.]* site-static/ 2>/dev/null || true"  # Copy hidden files
    
    # Return to original branch
    run_cmd "git checkout $current_branch"
    
    # Restore any stashed changes
    git stash pop >/dev/null 2>&1 || true
    
    if [ ! -d "site-static" ] || [ "$(ls -A site-static 2>/dev/null | wc -l)" -eq 0 ]; then
        print_error "Static extraction produced no content"
        return 1
    fi
    
    print_success "Static site extracted successfully from gh-pages with symlinks preserved!"
    
    # Apply Vercel-style root deployment
    apply_root_deployment
    return $?
}

# Apply root deployment for backward compatibility
apply_root_deployment() {
    print_info "Applying Vercel-style root deployment..."
    
    # First check if root deployment is already applied
    if [ -f "site-static/index.html" ] && [ ! -d "site-static/latest" ] && [ ! -d "site-static/10" ]; then
        print_info "Root deployment already applied - content is already at web root"
        print_success "Root index.html exists (content already deployed to root)"
        return 0
    fi
    
    # Look for latest content to copy to root (handle symlinks)
    local root_source=""
    
    # Check if latest exists (could be directory or symlink)
    if [ -e "site-static/latest" ]; then
        if [ -L "site-static/latest" ]; then
            # Latest is a symlink, resolve it
            local latest_target=$(readlink "site-static/latest" 2>/dev/null || echo "")
            if [ -n "$latest_target" ] && [ -d "site-static/$latest_target" ]; then
                root_source="site-static/$latest_target"
                print_info "Found latest symlink pointing to $latest_target, using as root source..."
            fi
        elif [ -d "site-static/latest" ]; then
            # Latest is a directory
            root_source="site-static/latest"
            print_info "Found latest directory, using as root source..."
        fi
    fi
    
    # Fallback to version 10 if latest not resolved
    if [ -z "$root_source" ] && [ -d "site-static/10" ]; then
        root_source="site-static/10"
        print_info "Using version 10 directory as root source..."
    fi
    
    if [ -z "$root_source" ]; then
        print_warning "No suitable version directory found for root deployment"
        return 1
    fi
    
    # Backup versions.json if it exists
    if [ -f "site-static/versions.json" ]; then
        run_cmd "cp site-static/versions.json site-static/versions.json.backup"
        print_info "Backed up versions.json"
    fi
    
    # Copy version content to root
    print_info "Copying latest content to root for production behavior..."
    run_cmd "cp -r $root_source/* site-static/ 2>/dev/null || true"
    
    # Restore versions.json to maintain version selector functionality
    if [ -f "site-static/versions.json.backup" ]; then
        run_cmd "cp site-static/versions.json.backup site-static/versions.json"
        run_cmd "rm site-static/versions.json.backup"
        print_info "Restored versions.json for version selector"
    fi
    
    # Verify root content
    if [ -f "site-static/index.html" ]; then
        print_success "Root index.html exists (latest content deployed)"
        
        # Check what URLs will work
        print_info "Verifying URL access patterns..."
        if [ -d "site-static/8" ]; then print_info "  ✅ /8/ → Rocky Linux 8"; fi
        if [ -d "site-static/9" ]; then print_info "  ✅ /9/ → Rocky Linux 9"; fi
        if [ -d "site-static/10" ]; then print_info "  ✅ /10/ → Rocky Linux 10"; fi
        if [ -d "site-static/latest" ]; then print_info "  ✅ /latest/ → Rocky Linux 10"; fi
        print_success "  ✅ / → Rocky Linux 10 (DIRECT ACCESS)"
        
        return 0
    else
        print_error "Root index.html missing after root deployment!"
        return 1
    fi
}

# Main serve function - routes to appropriate serving mode
serve_site() {
    local build_type="$1"  # Ignored for serve modes - they use pre-built content
    local static_mode="$2"
    
    # Route to appropriate serving mode
    if [ "$static_mode" = "true" ]; then
        serve_static
    else
        serve_live
    fi
}

# Dual server function
serve_dual() {
    
    print_info "🚀 DUAL SERVER MODE: Starting mike serve + mkdocs live reload"
    print_info "Setting up dual server environment..."
    
    # Validate basic requirements
    if [ ! -d "$APP_DIR" ]; then
        print_error "App directory not found: $APP_DIR"
        print_info "Run setup first: $0 --setup --minimal"
        return 1
    fi
    
    run_cmd "cd $APP_DIR"
    
    # Validate environment (same as serve_live)
    if [ ! -d "$APP_DIR/venv" ]; then
        print_error "Virtual environment not found. Run: $0 --setup --venv --minimal"
        return 1
    fi
    
    # Check if mike has been deployed - dual server requires mike versioning
    if ! git show-ref --verify --quiet refs/heads/gh-pages; then
        print_error "No mike deployment found on 'gh-pages' branch. Dual server requires mike versioning."
        print_info "Run: $0 --deploy first to create the local mike deployment."
        return 1
    fi
    
    # NOTE: No mkdocs config needed - serve_dual serves pre-built content from gh-pages
    
    # Setup content symlink for current content
    manage_content_symlink "create" "$CONTENT_DIR/docs" "content"
    
    # Activate virtual environment if using it
    if [ ! -f "venv/bin/activate" ]; then
        print_error "Virtual environment not found. Run: $0 --setup --venv first"
        return 1
    fi
    print_info "Activating virtual environment..."
    source venv/bin/activate
    
    # Find available ports with conflict resolution
    local mike_port=$(find_available_port 8000 8010 8020)
    local mkdocs_port=$(find_available_port 8001 8011 8021)
    
    if [ -z "$mike_port" ] || [ -z "$mkdocs_port" ]; then
        print_error "Could not find available ports for dual server mode"
        return 1
    fi
    
    print_success "🔧 DUAL SERVER CONFIGURATION:"
    print_info "  • Mike serve (multi-version): http://localhost:$mike_port"
    print_info "  • MkDocs serve (live reload): http://localhost:$mkdocs_port"
    print_info ""
    print_info "🎯 USE CASES:"
    print_info "  • Port $mike_port: Test multi-version functionality, version selector, and web root."
    print_info "  • Port $mkdocs_port: Active content editing with live reload."
    print_info ""
    
    # Start mike serve in background
    print_info "Starting mike serve in background (port $mike_port)..."
    mike serve -a localhost:$mike_port --config-file mkdocs.yml > /tmp/mike-serve-$$.log 2>&1 &
    local mike_pid=$!
    add_cleanup_resource "pid:$mike_pid"
    add_cleanup_resource "file:/tmp/mike-serve-$$.log"
    
    # Give mike serve time to start
    sleep 2
    
    # Check if mike serve started successfully
    if ! kill -0 $mike_pid 2>/dev/null; then
        print_error "Failed to start mike serve. Check log: /tmp/mike-serve-$$.log"
        return 1
    fi
    
    print_success "✅ Mike serve started successfully (PID: $mike_pid)"
    
    # Start mkdocs serve in foreground with live reload
    print_info "Starting mkdocs serve with live reload (port $mkdocs_port)..."
    print_info "📝 LIVE RELOAD FEATURES:"
    print_info "  • File changes auto-refresh browser"
    print_info "  • Theme changes supported"
    print_info "  • Current content only (not versioned)"
    print_info ""
    print_warning "Press Ctrl+C to stop both servers cleanly"
    print_info ""
    
    # Set up signal handler for clean shutdown
    trap 'print_warning "Stopping dual servers..."; kill $mike_pid 2>/dev/null; exit 0' INT TERM
    
    # Start mkdocs serve in foreground
    mkdocs serve -a localhost:$mkdocs_port --watch-theme --config-file mkdocs.yml
}

# Deploy site function
deploy_site() {
    local current_version=$(detect_version)
    
    print_info "🚀 DEPLOY MODE: Building and deploying ALL Rocky Linux versions locally"
    print_info "This creates the complete versioned site that --serve uses"
    print_info "Current branch: Rocky Linux $current_version (your edits will be in this version)"
    
    if [ ! -d "$APP_DIR/venv" ]; then
        print_error "Environment not setup. Run: $0 --setup --venv first"
        return 1
    fi
    
    run_cmd "cd $APP_DIR"

    # Delete existing gh-pages branch for a clean LOCAL deployment
    if git show-ref --verify --quiet refs/heads/gh-pages; then
        print_info "Deleting existing local gh-pages branch for a clean deployment..."
        run_cmd "git branch -D gh-pages"
    fi
    
    # Use existing mkdocs.yml config set during setup - no need to reconfigure
    
    # Setup repository caching and deploy all versions
    print_info "Setting up cached repositories and deploying versions..."
    setup_cached_repos
    deploy_all_versions "$current_version"
    
    # Apply the web root override directly to the local gh-pages branch
    apply_web_root_override_local
    
    print_success "🎉 Local deploy complete! All versions are ready for '--serve'."
    print_info "Available versions: Rocky Linux 8, 9, 10 (latest)"
    print_info ""
    print_info "Next steps:"
    print_info "  • Use: $0 --serve --minimal      # Fast serve (no rebuild)"
    print_info "  • Use: $0 --serve --static       # Static production-like serve"
    print_info ""
    print_info "Deployed versions ready for fast serving with mike!"
}

# Docker deployment function
deploy_docker() {
    local current_version=$(detect_version)
    
    print_info "🐳 DOCKER DEPLOY MODE: Container-based multi-version deployment"
    print_info "Building and deploying ALL Rocky Linux versions using Docker containers"
    print_info "Current branch: Rocky Linux $current_version (your edits will be in this version)"
    
    # Validate Docker setup
    if [ ! -d "$APP_DIR" ]; then
        print_error "App directory not found: $APP_DIR"
        print_info "Run setup first: $0 --setup --docker"
        return 1
    fi
    
    # Check if Docker image exists
    if ! docker image inspect rockydocs-dev >/dev/null 2>&1; then
        print_error "Docker image 'rockydocs-dev' not found"
        print_info "Run setup first: $0 --setup --docker"
        return 1
    fi
    
    cd "$APP_DIR"
    
    # Use existing mkdocs.yml config set during setup - no need to reconfigure
    print_info "Using existing mkdocs configuration from setup..."
    
    # Get container name for deployment
    local container_name=$(get_docker_container_name "deploy")
    stop_docker_container "$container_name"
    
    print_info "Setting up cached repositories..."
    setup_cached_repos
    
    print_success "🚀 Starting Docker deployment container..."
    
    # Create deployment script inside container
    local deploy_script="/tmp/deploy_all_versions.sh"
    cat > "$deploy_script" << 'EOF'
#!/bin/bash
set -e

current_version="$1"
echo "🐳 Container deployment starting..."
echo "Current version: $current_version"

# Configure git user for timestamp preservation
git config --global user.name "Rocky Linux Documentation Bot"
git config --global user.email "noreply@rockylinux.org"

# No virtual environment needed in Docker - packages installed globally

# Deploy Rocky Linux 8
if [ -d "worktrees/rocky-8" ]; then
    echo "📦 Deploying Rocky Linux 8..."
    rm -rf content && ln -sf worktrees/rocky-8/docs content
    mike deploy 8 --config-file mkdocs.yml || echo "Warning: Rocky 8 deployment had issues"
fi

# Deploy Rocky Linux 9
if [ -d "worktrees/rocky-9" ]; then
    echo "📦 Deploying Rocky Linux 9..."
    rm -rf content && ln -sf worktrees/rocky-9/docs content
    mike deploy 9 --config-file mkdocs.yml || echo "Warning: Rocky 9 deployment had issues"
fi

# Deploy Rocky Linux 10 (current content with git history)
echo "📦 Deploying Rocky Linux 10 (current)..."
if [ -d "worktrees/main" ]; then
    echo "Using worktree main for Rocky Linux 10 (with git history)..."
    rm -rf content && ln -sf worktrees/main/docs content
else
    echo "Fallback: Using current content directory..."
    rm -rf content && ln -sf /app/content-current content
fi
mike deploy 10 latest --config-file mkdocs.yml
mike set-default latest --config-file mkdocs.yml

echo "✅ Container deployment completed successfully!"
mike list --config-file mkdocs.yml || true
EOF
    chmod +x "$deploy_script"
    
    # Run deployment in container
    print_info "Running deployment inside Docker container..."
    docker run --rm --name "$container_name" \
        -v "$APP_DIR:/app" \
        -v "$CONTENT_DIR/docs:/app/content-current" \
        -v "$deploy_script:$deploy_script" \
        --workdir /app \
        rockydocs-dev \
        bash "$deploy_script" "$current_version"
    
    # Clean up temporary script
    rm -f "$deploy_script"
    
    # Apply web root override (same as venv version)
    print_info "Applying web root override for production-like behavior..."
    apply_web_root_override_local
    
    print_success "🎉 Docker deployment complete! All versions are ready for '--serve'."
    print_info "Available versions: Rocky Linux 8, 9, 10 (latest)"
    print_info ""
    print_info "Next steps:"
    print_info "  • Use: $0 --serve --docker         # Docker-based serving"
    print_info "  • Use: $0 --serve --docker --static # Static production-like serve"
    print_info ""
    print_info "Deployed versions ready for Docker serving!"
}

# === STATUS FUNCTIONS ===

show_system_info() {
    print_success "System Information:"
    echo "  • Script version: $FULL_VERSION"
    echo "  • Current directory: $CONTENT_DIR"
    echo "  • Rocky Linux version: $(detect_version) (branch: $(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown"))"
    echo "  • Platform: $(uname -s) $(uname -m)"
}

# Merged environment and configuration info
show_config_env_info() {
    print_success "Configuration & Environment:"
    echo "  • Config file: $CONFIG_FILE"
    if [ -f "$CONFIG_FILE" ]; then
        echo "  • Saved workspace: $SAVED_WORKSPACE_BASE_DIR"
    fi
    echo "  • Current workspace (WORKSPACE_BASE_DIR): $WORKSPACE_BASE_DIR"
    echo "  • Content directory (CONTENT_DIR): $CONTENT_DIR"
    echo "  • App directory (APP_DIR): $APP_DIR"
}


show_repo_status() {
    local repo_type="$1"
    local repo_dir="$2"
    
    if [ -d "$repo_dir/.git" ]; then
        cd "$repo_dir"
        local remote=$(git remote get-url origin 2>/dev/null || echo "unknown")
        local commit=$(git rev-parse HEAD 2>/dev/null || echo "unknown")
        local upstream_commit="unknown"
        if git ls-remote origin HEAD >/dev/null 2>&1; then
            upstream_commit=$(git ls-remote origin HEAD | cut -f1 2>/dev/null || echo "unknown")
        fi
        echo "  • Origin: $remote"
        echo "  • Local commit: ${commit:0:8}"
        echo "  • Remote commit: ${upstream_commit:0:8}"
        
        # Show other remotes if they exist
        local other_remotes=$(git remote | grep -v "^origin$" 2>/dev/null || true)
        if [ -n "$other_remotes" ]; then
            for remote_name in $other_remotes; do
                local remote_url=$(git remote get-url "$remote_name" 2>/dev/null || echo "unknown")
                echo "  • $remote_name: $remote_url"
            done
        fi
        
        if [ "$repo_type" = "content" ]; then
            local git_status=$(git status --porcelain 2>/dev/null | wc -l | tr -d ' ')
            if [ "$git_status" -gt 0 ]; then
                print_warning "  • $git_status uncommitted changes"
            else
                echo "  • Working tree clean"
            fi
        fi
        cd "$CONTENT_DIR"
    else
        echo "  • Not a git repository"
    fi
}

show_process_status() {
    print_success "Active Processes:"
    local mike_pids=$(pgrep -f "mike serve" 2>/dev/null || true)
    local python_pids=$(pgrep -f "python.*http\.server" 2>/dev/null || true)
    local mkdocs_pids=$(pgrep -f "mkdocs serve" 2>/dev/null || true)
    
    if [ -n "$mike_pids" ]; then
        echo "  • Mike serve PIDs: $mike_pids"
    fi
    if [ -n "$python_pids" ]; then
        echo "  • Python HTTP server PIDs: $python_pids"
    fi
    if [ -n "$mkdocs_pids" ]; then
        echo "  • MkDocs serve PIDs: $mkdocs_pids"
    fi
    if [ -z "$mike_pids" ] && [ -z "$python_pids" ] && [ -z "$mkdocs_pids" ]; then
        echo "  • No active documentation servers found"
    fi
}

show_port_status() {
    print_success "Port Usage:"
    for port in 8000 8001 8002; do
        if lsof -i :$port >/dev/null 2>&1; then
            local process_info=$(lsof -i :$port 2>/dev/null | tail -n 1 | awk '{print $1 " (PID " $2 ")"}')
            echo "  • Port $port: In use by $process_info"
        else
            echo "  • Port $port: Available"
        fi
    done
}

# Enhanced build artifacts with disk usage
show_build_artifacts() {
    print_success "Build Artifacts & Disk Usage:"
    
    # Helper function for fast disk usage
    get_disk_usage_fast() {
        local path="$1"
        if [ -d "$path" ]; then
            du -sh "$path" 2>/dev/null | cut -f1
        else
            echo "0B"
        fi
    }
    
    # Build artifacts status
    if [ -d "$APP_DIR/site" ]; then
        local site_size=$(get_disk_usage_fast "$APP_DIR/site")
        echo "  • Site directory: Found ($site_size)"
    else
        echo "  • Site directory: Not found"
    fi
    
    if [ -d "$APP_DIR/site-static" ]; then
        local static_size=$(get_disk_usage_fast "$APP_DIR/site-static")
        echo "  • Static site directory: Found ($static_size)"
    else
        echo "  • Static site directory: Not found"
    fi
    
    if [ -f "$APP_DIR/versions.json" ]; then
        echo "  • Versions file: Found"
    else
        echo "  • Versions file: Not found"
    fi
    
    # Simple disk usage totals
    local workspace_size=$(get_disk_usage_fast "$WORKSPACE_BASE_DIR")
    local worktree_size=$(get_disk_usage_fast "$APP_DIR/worktrees")
    echo "  • Total workspace: $workspace_size"
    echo "  • Cached worktrees: $worktree_size"
}

# List deployed versions (mimics mike list behavior)
list_versions() {
    print_info "Listing deployed versions..."
    
    # Check if app directory exists
    if [ ! -d "$APP_DIR" ]; then
        print_error "App directory not found: $APP_DIR"
        print_info "Run --setup first to create the build environment"
        return 1
    fi
    
    cd "$APP_DIR"
    
    # Check if gh-pages branch exists (indicates deployment has happened)
    if ! git show-ref --verify --quiet refs/heads/gh-pages; then
        print_warning "No versions deployed yet"
        print_info "Run --deploy first to create version deployments"
        return 0
    fi
    
    # Extract version information from gh-pages branch
    local current_branch=$(git rev-parse --abbrev-ref HEAD)
    
    # Check if versions.json exists on gh-pages branch
    if git ls-tree gh-pages | grep -q "versions.json"; then
        print_success "Deployed versions:"
        # Extract version info directly from gh-pages branch without switching
        git show gh-pages:versions.json | jq -r '.[] | "\(.version) [\(.title)] \(.aliases // [] | join(", ") | if . == "" then "" else "(" + . + ")" end)"' 2>/dev/null || {
            # Fallback if jq fails - simple extraction
            git show gh-pages:versions.json 2>/dev/null | grep -E '"version"|"title"|"aliases"' | paste - - - | sed 's/"version": "\([^"]*\)".*"title": "\([^"]*\)".*/\1 [\2]/'
        }
    else
        print_warning "No versions.json found on gh-pages branch"
        print_info "Checking for version directories..."
        # List version directories directly from gh-pages
        git ls-tree gh-pages | grep "^040000 tree" | awk '{print $4}' | grep -E "^[0-9]+$|^latest$" | sort -V || print_warning "No version directories found"
    fi
}

# Docker status display function
show_docker_status() {
    print_success "Docker Environment:"
    
    # Check if Docker is available
    if ! command -v docker >/dev/null 2>&1; then
        echo "  • Docker: Not available"
        return
    fi
    
    # Check Docker daemon status
    if ! docker info >/dev/null 2>&1; then
        echo "  • Docker: Available but daemon not running"
        return
    fi
    
    echo "  • Docker: Available and running"
    
    # Check for rockydocs-dev image (faster check)
    if docker images -q rockydocs-dev 2>/dev/null | grep -q .; then
        echo "  • Docker image: rockydocs-dev (available)"
    else
        echo "  • Docker image: rockydocs-dev (not found)"
    fi
    
    # Check for active containers (faster)
    local serve_container=$(get_docker_container_name "serve")
    local deploy_container=$(get_docker_container_name "deploy")
    
    local serve_running=$(docker ps -q -f name="$serve_container" 2>/dev/null)
    local deploy_running=$(docker ps -q -f name="$deploy_container" 2>/dev/null)
    
    if [ -n "$serve_running" ] || [ -n "$deploy_running" ]; then
        echo "  • Active containers: Yes"
        if [ -n "$serve_running" ]; then
            local port=$(docker port "$serve_container" 8000 2>/dev/null | cut -d: -f2)
            echo "    - Serving on port ${port:-unknown}"
        fi
        if [ -n "$deploy_running" ]; then
            echo "    - Deploy container running"
        fi
    else
        echo "  • Active containers: None"
    fi
}


# Main status function - optimized and streamlined
show_status() {
    print_info "Rocky Linux Documentation System Status"
    echo ""
    
    show_system_info
    echo ""
    
    show_config_env_info
    echo ""
    
    print_success "Content Repository Status:"
    show_repo_status "content" "$CONTENT_DIR"
    echo ""
    
    print_success "App Repository Status:"
    if [ -d "$APP_DIR" ]; then
        show_repo_status "app" "$APP_DIR"
    else
        echo "  • App directory not found: $APP_DIR"
    fi
    echo ""
    
    show_process_status
    echo ""
    
    show_port_status
    echo ""
    
    show_docker_status
    echo ""
    
    show_build_artifacts
}

# === CLEANUP FUNCTIONS ===

# Reset configuration function
reset_configuration() {
    print_info "Resetting saved configuration..."
    
    if [ -f "$CONFIG_FILE" ]; then
        print_warning "This will remove saved workspace configuration: $CONFIG_FILE"
        read -p "Continue? (y/N): " confirm
        if [[ "$confirm" =~ ^[Yy]$ ]]; then
            run_cmd "rm -f $CONFIG_FILE"
            print_success "Configuration reset - next setup will use default workspace"
        else
            print_info "Reset operation cancelled"
        fi
    else
        print_info "No saved configuration found to reset"
    fi
}

# Clean function with enhanced resource management
clean_workspace() {
    print_info "Cleaning workspace and build artifacts..."
    
    if [ -d "$WORKSPACE_BASE_DIR" ]; then
        print_warning "This will remove the entire workspace directory: $WORKSPACE_BASE_DIR"
        print_warning "This includes the app repository and all build artifacts"
        print_info "Repository cache will be preserved for faster subsequent runs"
        read -p "Continue? (y/N): " confirm
        if [[ "$confirm" =~ ^[Yy]$ ]]; then
            # Clean up git worktrees first to avoid permission issues
            if [ -d "$APP_DIR" ]; then
                print_info "Cleaning up git worktrees..."
                cd "$APP_DIR" 2>/dev/null || true
                for worktree in rocky-8 rocky-9 main; do
                    if [ -d "worktrees/$worktree" ]; then
                        git worktree remove --force "worktrees/$worktree" 2>/dev/null || true
                    fi
                done
                cd - >/dev/null 2>&1 || true
            fi
            
            # Preserve cached repos for performance
            if [ -d "$APP_DIR/cached-repos" ]; then
                print_info "Preserving repository cache for faster startup..."
                run_cmd_with_rollback "mv $APP_DIR/cached-repos /tmp/rockydocs-cache-backup" "" "Failed to backup cache"
            fi
            
            # Fix permissions before removal
            if [ -d "$WORKSPACE_BASE_DIR" ]; then
                chmod -R 755 "$WORKSPACE_BASE_DIR" 2>/dev/null || true
            fi
            
            run_cmd "rm -rf $WORKSPACE_BASE_DIR"
            print_success "Workspace cleaned: $WORKSPACE_BASE_DIR"
            
            # Restore cache if it existed
            if [ -d "/tmp/rockydocs-cache-backup" ]; then
                run_cmd "mkdir -p $APP_DIR"
                run_cmd "mv /tmp/rockydocs-cache-backup $APP_DIR/cached-repos"
                print_info "Repository cache restored for next run"
            fi
        else
            print_info "Clean operation cancelled"
        fi
    else
        print_info "No workspace directory found to clean"
    fi
    
    # Also clean any local build artifacts in current directory
    if [ -d "site" ]; then
        run_cmd "rm -rf site"
        print_success "Local build artifacts cleaned"
    fi
    
    # Option to clean cache completely
    if [ -d "$APP_DIR/cached-repos" ]; then
        print_info ""
        print_warning "Repository cache found: $APP_DIR/cached-repos"
        print_info "This cache makes subsequent runs much faster"
        read -p "Also remove repository cache? (y/N): " clean_cache
        if [[ "$clean_cache" =~ ^[Yy]$ ]]; then
            run_cmd "rm -rf $APP_DIR/cached-repos"
            # Also remove the empty parent directory to avoid setup issues
            if [ -d "$APP_DIR" ] && [ "$(ls -A $APP_DIR 2>/dev/null | wc -l)" -eq 0 ]; then
                run_cmd "rm -rf $APP_DIR"
                print_info "Removed empty app directory"
            fi
            print_success "Repository cache cleaned (next run will be slower)"
        else
            print_info "Repository cache preserved for faster startup"
        fi
    fi
    
    # Option to clean Docker volumes
    if command -v docker >/dev/null 2>&1 && docker info >/dev/null 2>&1; then
        local workspace_volume="rockydocs-workspace-${USER}"
        local content_volume="rockydocs-content-${USER}"
        
        if docker volume inspect "$workspace_volume" >/dev/null 2>&1 || docker volume inspect "$content_volume" >/dev/null 2>&1; then
            print_info ""
            print_warning "Docker volumes found for Rocky Linux Documentation"
            cleanup_docker_volumes
        fi
    fi
    
    # Option to clean saved configuration
    if [ -f "$CONFIG_FILE" ]; then
        print_info ""
        print_warning "Saved configuration found: $CONFIG_FILE"
        print_info "This contains your workspace preferences"
        read -p "Also remove saved configuration? (y/N): " clean_config
        if [[ "$clean_config" =~ ^[Yy]$ ]]; then
            run_cmd "rm -f $CONFIG_FILE"
            print_success "Saved configuration cleared - next setup will use defaults"
        else
            print_info "Saved configuration preserved"
        fi
    fi
}