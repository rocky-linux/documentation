#!/bin/bash

# Rocky Linux Documentation - Function Library
# Modular function library for rockydocs.sh
# Contains all utility functions, setup logic, and serving modes
#
# Author: Wale Soyinka
# Contributors: 
# Ai-Contributors: Claude (claude-sonnet-4-20250514), Gemini (gemini-2.5-pro)

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Print functions
print_success() { echo -e "${GREEN}✅ $1${NC}"; }
print_info() { echo -e "${BLUE}ℹ️  $1${NC}"; }
print_warning() { echo -e "${YELLOW}⚠️  $1${NC}"; }
print_error() { echo -e "${RED}❌ $1${NC}"; }
print_command() { echo -e "${YELLOW}Running: $1${NC}"; }

# Execute command with echo
run_cmd() {
    print_command "$1"
    eval "$1"
}

# === UTILITY FUNCTIONS ===

# Resource cleanup handler
CLEANUP_RESOURCES=()
cleanup_on_exit() {
    local exit_code=$?
    if [ ${#CLEANUP_RESOURCES[@]} -gt 0 ]; then
        print_warning "Cleaning up resources..."
        for resource in "${CLEANUP_RESOURCES[@]}"; do
            if [[ "$resource" =~ ^pid: ]]; then
                local pid="${resource#pid:}"
                kill "$pid" 2>/dev/null || true
                print_info "Terminated PID $pid"
            elif [[ "$resource" =~ ^dir: ]]; then
                local dir="${resource#dir:}"
                rm -rf "$dir" 2>/dev/null || true
                print_info "Cleaned directory $dir"
            elif [[ "$resource" =~ ^file: ]]; then
                local file="${resource#file:}"
                rm -f "$file" 2>/dev/null || true
                print_info "Cleaned file $file"
            elif [[ "$resource" =~ ^container: ]]; then
                local container="${resource#container:}"
                # Try Docker first, then Podman
                if command -v docker >/dev/null 2>&1 && docker ps -a -q -f name="$container" >/dev/null 2>&1; then
                    stop_docker_container "$container"
                elif command -v podman >/dev/null 2>&1 && podman ps -a -q -f name="$container" >/dev/null 2>&1; then
                    stop_podman_container "$container"
                fi
                print_info "Stopped container $container"
            fi
        done
    fi
    exit $exit_code
}
trap cleanup_on_exit EXIT INT TERM

# Add resource to cleanup list
add_cleanup_resource() {
    CLEANUP_RESOURCES+=("$1")
}

# Load saved workspace configuration
load_workspace_config() {
    if [ -f "$CONFIG_FILE" ]; then
        source "$CONFIG_FILE"
    fi
}

# Save workspace configuration
save_workspace_config() {
    local workspace_path="$1"
    mkdir -p "$CONFIG_DIR"
    cat > "$CONFIG_FILE" << EOF
# Rocky Linux Documentation Workspace Configuration
# This file is automatically generated and managed
SAVED_WORKSPACE_BASE_DIR="$workspace_path"
EOF
    print_success "Workspace configuration saved to: $CONFIG_FILE"
}

# Setup mkdocs configuration
setup_mkdocs_config() {
    local build_type="$1"
    local working_dir="${2:-$PWD}"
    
    cd "$working_dir"
    
    if [ "$build_type" = "full" ]; then
        run_cmd "cp -f configs/mkdocs.full.yml mkdocs.yml"
        print_info "Using full config (all languages)"
    else
        run_cmd "cp -f configs/mkdocs.minimal.yml mkdocs.yml"
        print_info "Using minimal config (English + Ukrainian)"
    fi
}

# Manage content symlink with proper cleanup
manage_content_symlink() {
    local action="$1"
    local target="${2:-$CONTENT_DIR/docs}"
    local link_name="${3:-content}"
    
    case "$action" in
        "create")
            run_cmd "rm -rf $link_name"
            run_cmd "ln -sf $target $link_name"
            add_cleanup_resource "file:$PWD/$link_name"
            ;;
        "backup")
            if [ -e "$link_name" ]; then
                run_cmd "rm -f ${link_name}-backup-current"
                run_cmd "mv $link_name ${link_name}-backup-current"
            fi
            ;;
        "restore")
            run_cmd "rm -f $link_name"
            if [ -e "${link_name}-backup-current" ]; then
                run_cmd "mv ${link_name}-backup-current $link_name"
            fi
            ;;
        "clean")
            run_cmd "rm -f $link_name ${link_name}-backup-current"
            ;;
    esac
}

# Activate virtual environment with error handling
activate_venv() {
    local venv_path="${1:-venv}"
    if [ ! -d "$venv_path" ]; then
        print_error "Virtual environment not found: $venv_path"
        return 1
    fi
    source "$venv_path/bin/activate" || {
        print_error "Failed to activate virtual environment"
        return 1
    }
}

# Improved error handling for commands
run_cmd_with_rollback() {
    local cmd="$1"
    local rollback_cmd="$2"
    local error_msg="${3:-Command failed}"
    
    print_command "$cmd"
    if ! eval "$cmd"; then
        print_error "$error_msg"
        if [ -n "$rollback_cmd" ]; then
            print_warning "Attempting rollback: $rollback_cmd"
            eval "$rollback_cmd" 2>/dev/null || true
        fi
        return 1
    fi
    return 0
}

# Check and resolve port conflicts
check_and_resolve_port_conflict() {
    local port="$1"
    local force_kill="${2:-false}"
    
    if lsof -i ":$port" >/dev/null 2>&1; then
        local process_info=$(lsof -i ":$port" 2>/dev/null | tail -n 1 | awk '{print $1 " (PID " $2 ")"}')
        local pid=$(lsof -ti ":$port" 2>/dev/null)
        
        print_warning "Port $port is already in use by $process_info"
        
        if [ "$force_kill" = "true" ]; then
            print_info "Automatically terminating conflicting process..."
            if kill "$pid" 2>/dev/null; then
                print_success "Terminated PID $pid (was using port $port)"
                sleep 2
                return 0
            else
                print_error "Failed to terminate PID $pid"
                return 1
            fi
        else
            print_info "Options:"
            print_info "  1. Terminate the conflicting process automatically"
            print_info "  2. Use a different port"
            print_info "  3. Cancel and resolve manually"
            read -p "Choose (1-3): " choice
            
            case "$choice" in
                1)
                    if kill "$pid" 2>/dev/null; then
                        print_success "Terminated PID $pid (was using port $port)"
                        sleep 2
                        return 0
                    else
                        print_error "Failed to terminate PID $pid"
                        return 1
                    fi
                    ;;
                2)
                    print_info "Using alternative port 8002"
                    return 2  # Signal to use alternative port
                    ;;
                3)
                    print_info "Please manually terminate the process: kill $pid"
                    return 1
                    ;;
                *)
                    print_error "Invalid choice"
                    return 1
                    ;;
            esac
        fi
    fi
    
    return 0  # Port is available
}

# Kill all documentation-related processes
kill_all_doc_processes() {
    print_info "Cleaning up all documentation server processes..."
    
    # Kill mike serve processes
    local mike_pids=$(pgrep -f "mike serve" 2>/dev/null || true)
    if [ -n "$mike_pids" ]; then
        echo "$mike_pids" | xargs kill 2>/dev/null || true
        print_info "Terminated mike serve processes: $mike_pids"
    fi
    
    # Kill Python HTTP servers on documentation ports
    for port in 8000 8001 8002; do
        if lsof -i ":$port" >/dev/null 2>&1; then
            local pid=$(lsof -ti ":$port" 2>/dev/null)
            local process_name=$(lsof -i ":$port" 2>/dev/null | tail -n 1 | awk '{print $1}')
            if [[ "$process_name" == "Python" ]] || [[ "$process_name" == "python"* ]]; then
                kill "$pid" 2>/dev/null || true
                print_info "Terminated $process_name (PID $pid) on port $port"
            fi
        fi
    done
    
    # Kill mkdocs serve processes
    local mkdocs_pids=$(pgrep -f "mkdocs serve" 2>/dev/null || true)
    if [ -n "$mkdocs_pids" ]; then
        echo "$mkdocs_pids" | xargs kill 2>/dev/null || true
        print_info "Terminated mkdocs serve processes: $mkdocs_pids"
    fi
    
    sleep 2
    print_success "All documentation server processes cleaned up"
}

# Detect current Rocky version from git branch
detect_version() {
    local branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "main")
    case "$branch" in
        rocky-8) echo "8" ;;
        rocky-9) echo "9" ;;
        main) echo "10" ;;
        *) echo "10" ;;
    esac
}

# Utility function: Find available port with fallback
find_available_port() {
    local port
    for port in "$@"; do
        if ! lsof -i ":$port" >/dev/null 2>&1; then
            echo "$port"
            return 0
        fi
    done
    return 1
}

# Docker container utility functions
get_docker_container_name() {
    local service_type="$1"  # serve, deploy, etc.
    echo "rockydocs-${service_type}-${USER}"
}

stop_docker_container() {
    local container_name="$1"
    if docker ps -q -f name="$container_name" >/dev/null 2>&1; then
        print_info "Stopping existing container: $container_name"
        docker stop "$container_name" >/dev/null 2>&1 || true
    fi
    if docker ps -a -q -f name="$container_name" >/dev/null 2>&1; then
        docker rm "$container_name" >/dev/null 2>&1 || true
    fi
}

get_docker_container_status() {
    local container_name="$1"
    if docker ps -q -f name="$container_name" >/dev/null 2>&1; then
        echo "running"
    elif docker ps -a -q -f name="$container_name" >/dev/null 2>&1; then
        echo "stopped"
    else
        echo "not_found"
    fi
}

check_docker_health() {
    local container_name="$1"
    local port="$2"
    local max_attempts="${3:-30}"
    local attempt=0
    
    while [ $attempt -lt $max_attempts ]; do
        # First check if container is still running
        if ! docker ps --format "table {{.Names}}" | grep -q "^$container_name$"; then
            print_error "Container $container_name stopped running"
            return 1
        fi
        
        # Then check if service is responding
        if curl -s "http://localhost:$port" >/dev/null 2>&1; then
            return 0
        fi
        sleep 1
        attempt=$((attempt + 1))
    done
    return 1
}

# Docker volume management functions
create_docker_volumes() {
    local workspace_volume="rockydocs-workspace-${USER}"
    local content_volume="rockydocs-content-${USER}"
    
    # Create workspace volume if it doesn't exist
    if ! docker volume inspect "$workspace_volume" >/dev/null 2>&1; then
        print_info "Creating Docker volume for workspace: $workspace_volume"
        docker volume create "$workspace_volume" >/dev/null 2>&1
    fi
    
    # Create content volume if it doesn't exist
    if ! docker volume inspect "$content_volume" >/dev/null 2>&1; then
        print_info "Creating Docker volume for content: $content_volume"
        docker volume create "$content_volume" >/dev/null 2>&1
    fi
    
    echo "$workspace_volume $content_volume"
}

# Docker volume cleanup function
cleanup_docker_volumes() {
    local workspace_volume="rockydocs-workspace-${USER}"
    local content_volume="rockydocs-content-${USER}"
    
    print_warning "This will remove Docker volumes containing your workspace data"
    read -p "Remove Docker volumes? (y/N): " confirm
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        print_info "Removing Docker volumes..."
        docker volume rm "$workspace_volume" >/dev/null 2>&1 || true
        docker volume rm "$content_volume" >/dev/null 2>&1 || true
        print_success "Docker volumes removed"
    else
        print_info "Docker volume cleanup cancelled"
    fi
}

# Docker volume status check
show_docker_volume_status() {
    local workspace_volume="rockydocs-workspace-${USER}"
    local content_volume="rockydocs-content-${USER}"
    
    echo "  • Docker volumes:"
    
    if docker volume inspect "$workspace_volume" >/dev/null 2>&1; then
        local volume_size=$(docker system df -v 2>/dev/null | grep "$workspace_volume" | awk '{print $3}' || echo "unknown")
        echo "    - $workspace_volume (size: $volume_size)"
    else
        echo "    - $workspace_volume (not created)"
    fi
    
    if docker volume inspect "$content_volume" >/dev/null 2>&1; then
        local volume_size=$(docker system df -v 2>/dev/null | grep "$content_volume" | awk '{print $3}' || echo "unknown")
        echo "    - $content_volume (size: $volume_size)"
    else
        echo "    - $content_volume (not created)"
    fi
}

cleanup_docker_containers() {
    local user_containers=$(docker ps -a -q -f name="rockydocs-.*-${USER}" 2>/dev/null || true)
    if [ -n "$user_containers" ]; then
        print_info "Cleaning up Docker containers..."
        echo "$user_containers" | xargs docker rm -f >/dev/null 2>&1 || true
    fi
}

# === PODMAN UTILITY FUNCTIONS ===

# Podman container utility functions
get_podman_container_name() {
    local suffix="$1"  # serve, deploy, etc.
    echo "rockydocs-${suffix}-${USER}"
}

stop_podman_container() {
    local container_name="$1"
    if podman ps -q -f name="$container_name" >/dev/null 2>&1; then
        print_info "Stopping existing Podman container: $container_name"
        podman stop "$container_name" >/dev/null 2>&1 || true
    fi
    if podman ps -a -q -f name="$container_name" >/dev/null 2>&1; then
        podman rm "$container_name" >/dev/null 2>&1 || true
    fi
}

get_podman_container_status() {
    local container_name="$1"
    if podman ps -q -f name="$container_name" >/dev/null 2>&1; then
        echo "running"
    elif podman ps -a -q -f name="$container_name" >/dev/null 2>&1; then
        echo "stopped"
    else
        echo "not_found"
    fi
}

check_podman_health() {
    local container_name="$1"
    local port="$2"
    local timeout="${3:-60}"
    local attempt=1
    local max_attempts=$((timeout / 5))
    
    while [ $attempt -le $max_attempts ]; do
        print_info "Health check attempt $attempt/$max_attempts..."
        
        # Check if container is still running
        if ! podman ps --format "table {{.Names}}" | grep -q "^$container_name$"; then
            print_error "Container $container_name is not running"
            return 1
        fi
        
        # Check if port is responding
        if curl -sf "http://localhost:$port" >/dev/null 2>&1; then
            return 0
        fi
        
        sleep 5
        attempt=$((attempt + 1))
    done
    return 1
}

# Podman volume management functions
create_podman_volumes() {
    local workspace_volume="rockydocs-workspace-${USER}"
    local content_volume="rockydocs-content-${USER}"
    
    # Create workspace volume if it doesn't exist
    if ! podman volume inspect "$workspace_volume" >/dev/null 2>&1; then
        print_info "Creating Podman volume for workspace: $workspace_volume"
        podman volume create "$workspace_volume" >/dev/null 2>&1
    fi
    
    # Create content volume if it doesn't exist
    if ! podman volume inspect "$content_volume" >/dev/null 2>&1; then
        print_info "Creating Podman volume for content: $content_volume"
        podman volume create "$content_volume" >/dev/null 2>&1
    fi
    
    echo "$workspace_volume $content_volume"
}

# Podman volume cleanup function
cleanup_podman_volumes() {
    local workspace_volume="rockydocs-workspace-${USER}"
    local content_volume="rockydocs-content-${USER}"
    
    print_warning "This will remove Podman volumes containing your workspace data"
    read -p "Remove Podman volumes? (y/N): " confirm
    if [[ "$confirm" =~ ^[yY]$ ]]; then
        print_info "Removing Podman volumes..."
        podman volume rm "$workspace_volume" >/dev/null 2>&1 || true
        podman volume rm "$content_volume" >/dev/null 2>&1 || true
        print_success "Podman volumes removed"
    else
        print_info "Podman volume cleanup cancelled"
    fi
}

# Podman volume status check
show_podman_volume_status() {
    local workspace_volume="rockydocs-workspace-${USER}"
    local content_volume="rockydocs-content-${USER}"
    
    echo "  • Podman volumes:"
    
    if podman volume inspect "$workspace_volume" >/dev/null 2>&1; then
        local volume_size=$(podman system df -v 2>/dev/null | grep "$workspace_volume" | awk '{print $3}' || echo "unknown")
        echo "    - $workspace_volume: exists (size: $volume_size)"
    else
        echo "    - $workspace_volume: not found"
    fi
    
    if podman volume inspect "$content_volume" >/dev/null 2>&1; then
        local volume_size=$(podman system df -v 2>/dev/null | grep "$content_volume" | awk '{print $3}' || echo "unknown")
        echo "    - $content_volume: exists (size: $volume_size)"
    else
        echo "    - $content_volume: not found"
    fi
}

cleanup_podman_containers() {
    local user_containers=$(podman ps -a -q -f name="rockydocs-.*-${USER}" 2>/dev/null || true)
    if [ -n "$user_containers" ]; then
        print_info "Cleaning up Podman containers..."
        echo "$user_containers" | xargs podman rm -f >/dev/null 2>&1 || true
    fi
}

# Stop all Rocky Linux documentation services across all environments
stop_all_services() {
    print_info "🛑 Stopping all Rocky Linux documentation services..."
    
    local stopped_count=0
    
    # Stop Python HTTP servers (venv static mode)
    local python_pids=$(pgrep -f "python.*http.server.*8000" 2>/dev/null || true)
    if [ -n "$python_pids" ]; then
        print_info "Stopping Python HTTP servers (venv static mode)..."
        echo "$python_pids" | xargs kill -TERM 2>/dev/null || true
        sleep 2
        # Force kill if still running
        echo "$python_pids" | xargs kill -KILL 2>/dev/null || true
        stopped_count=$((stopped_count + 1))
    fi
    
    # Stop MkDocs servers (venv live mode)
    local mkdocs_pids=$(pgrep -f "mkdocs.*serve" 2>/dev/null || true)
    if [ -n "$mkdocs_pids" ]; then
        print_info "Stopping MkDocs development servers (venv live mode)..."
        echo "$mkdocs_pids" | xargs kill -TERM 2>/dev/null || true
        sleep 2
        echo "$mkdocs_pids" | xargs kill -KILL 2>/dev/null || true
        stopped_count=$((stopped_count + 1))
    fi
    
    # Stop Docker containers
    if command -v docker >/dev/null 2>&1 && docker info >/dev/null 2>&1; then
        # Call dedicated Docker stop function
        stop_docker_services 2>/dev/null || true
        
        # Also handle general rockydocs Docker containers
        local docker_containers=$(docker ps -q -f name="rockydocs-.*" 2>/dev/null || true)
        if [ -n "$docker_containers" ]; then
            print_info "Stopping additional Docker containers..."
            echo "$docker_containers" | xargs docker stop >/dev/null 2>&1 || true
            echo "$docker_containers" | xargs docker rm >/dev/null 2>&1 || true
            stopped_count=$((stopped_count + 1))
        fi
    fi
    
    # Stop Podman containers
    if command -v podman >/dev/null 2>&1 && podman info >/dev/null 2>&1; then
        local podman_containers=$(podman ps -q -f name="rockydocs-.*-${USER}" 2>/dev/null || true)
        if [ -n "$podman_containers" ]; then
            print_info "Stopping Podman containers..."
            echo "$podman_containers" | xargs podman stop >/dev/null 2>&1 || true
            echo "$podman_containers" | xargs podman rm >/dev/null 2>&1 || true
            stopped_count=$((stopped_count + 1))
        fi
    fi
    
    # Stop LXD containers (if requested)
    if command -v lxc >/dev/null 2>&1; then
        local lxd_containers=$(lxc list -c n --format csv | grep "^rockydocs-.*-${USER}$" 2>/dev/null || true)
        if [ -n "$lxd_containers" ]; then
            print_info "Stopping LXD containers..."
            echo "$lxd_containers" | xargs -I {} lxc stop {} 2>/dev/null || true
            stopped_count=$((stopped_count + 1))
        fi
    fi
    
    if [ $stopped_count -eq 0 ]; then
        print_info "No active Rocky Linux documentation services found"
    else
        print_success "✅ Stopped $stopped_count service type(s)"
    fi
    
    # Show remaining processes (for debugging)
    local remaining_processes=$(pgrep -f "rockydocs\|mkdocs.*serve" 2>/dev/null || true)
    if [ -n "$remaining_processes" ]; then
        print_warning "Some processes may still be running:"
        ps -p $remaining_processes -o pid,ppid,cmd 2>/dev/null || true
    fi
}

# === HELP FUNCTIONS ===

# Main help
show_help() {
    cat << EOF
Rocky Linux Documentation - Master Contributor Script v$FULL_VERSION

DESCRIPTION:
  Recreates the exact look and feel of https://docs.rockylinux.org locally
  for contributors to preview their changes before pushing.

USAGE:
  $0 [COMMAND] [OPTIONS]

COMMANDS:
  --setup     Setup local development environment
  --serve     Serve existing deployed versions (fast)
  --serve-dual  Dual server mode: mike serve + mkdocs live reload
  --deploy    Build and deploy all versions locally (slow)
  --stop      Stop all running servers and containers
  --clean     Clean workspace and build artifacts
  --reset     Reset saved configuration
  --status    Show system status
  --install   Install LXD system containers (Rocky Linux 10 only)
  --uninstall Remove LXD and all containers (destructive)

GLOBAL OPTIONS:
  --minimal   Use English + Ukrainian only (default, faster) - setup only
  --full      Use all languages (slower, complete testing) - setup only
  --workspace PATH  Custom workspace location
  --help, -h  Show this help

EXAMPLES:
  $0 --setup --venv              # Setup Python venv environment
  $0 --setup --podman            # Setup Podman container environment
  $0 --setup --lxd               # Setup LXD container environment
  $0 --deploy                    # Build and deploy versions locally
  $0 --serve                     # Fast serve (after deploy)
  $0 --serve --static            # Static production-like serve
  $0 --serve-dual                # Dual server with live reload (venv)
  $0 --serve-dual --podman       # Dual server with Podman containers
  $0 --serve --lxd               # Serve with LXD containers
  $0 --install --lxd             # Install LXD (Rocky Linux 10 only)
  $0 --uninstall --lxd           # Remove LXD and all containers
  $0 --stop                      # Stop all running servers and containers
  $0 --setup --full              # Setup with all languages (config set once)
  $0 --deploy                    # Build using setup's language config

SUBCOMMAND HELP:
  $0 --setup -h                  # Detailed setup help
  $0 --serve -h                  # Detailed serve help
  $0 --serve-dual -h             # Dual server help
  $0 --deploy -h                 # Detailed deploy help

WORKFLOW:
  1. git checkout rocky-9                            # Choose your target version
  2. $0 --setup --venv           # Setup environment (once)
  3. $0 --deploy                 # Build/deploy versions to local repo
  4. $0 --serve                  # Fast serve for editing
  5. git add . && git commit && git push             # Push your source changes to origin

Current Rocky Linux version: $(detect_version) (branch: $(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown"))
EOF
}

# Setup command help
show_setup_help() {
    cat << EOF
Rocky Linux Documentation - Setup Environment

DESCRIPTION:
  Sets up local development environment that recreates the exact look and feel 
  of https://docs.rockylinux.org on your local machine.

USAGE:
  $0 --setup [ENVIRONMENT] [OPTIONS]

ENVIRONMENTS:
  --venv      Use Python virtual environment (recommended)
  --docker    Use Docker container (containerized environment)
  --podman    Use Podman container

OPTIONS:
  --minimal   Setup for English + Ukrainian only (default, faster)
  --full      Setup for all languages (complete testing)
  --workspace PATH  Custom workspace location

THIS COMMAND RUNS:
  - mkdir -p $WORKSPACE_BASE_DIR
  - Searches for existing docs.rockylinux.org repository to reuse OR
  - git clone https://github.com/rocky-linux/docs.rockylinux.org.git $APP_DIR
  - ln -sf docs.rockylinux.org $WORKSPACE_BASE_DIR/app  (compatibility symlink)
  - cd $APP_DIR
  
  For --venv (default):
  - python3 -m venv venv
  - source venv/bin/activate
  - pip install -r requirements.txt
  
  For --docker:
  - docker build -t rockydocs-dev .
  - Creates Docker volumes for data persistence
  - ln -sf $CONTENT_DIR/docs $APP_DIR/docs
  - cp configs/mkdocs.minimal.yml ./mkdocs.yml  (if --minimal)
  - cp configs/mkdocs.full.yml ./mkdocs.yml     (if --full)
  - Saves workspace configuration to ~/.config/rockydocs/config

MANUAL ALTERNATIVE:
  You can run these commands yourself:
    mkdir -p $WORKSPACE_BASE_DIR
    git clone https://github.com/rocky-linux/docs.rockylinux.org.git $APP_DIR
    cd $APP_DIR && python3 -m venv venv && source venv/bin/activate
    pip install -r requirements.txt

AFTER SETUP:
  - Content editing happens in: $CONTENT_DIR/docs/
  - App environment located at: $APP_DIR
  - You can cd to app directory and run mkdocs commands directly

WORKSPACE CONFIGURATION:
  First run saves your workspace preference to ~/.config/rockydocs/config
  Subsequent runs automatically use your saved workspace location
  Use --workspace to change location (gets saved for future use)
  Script intelligently finds and reuses existing docs.rockylinux.org repositories
  
SIMPLIFIED STRUCTURE:
  workspace/
  ├── docs.rockylinux.org/     # App repo (build environment)
  ├── app -> docs.rockylinux.org  # Compatibility symlink
  └── (your content repo is wherever you cloned it)

EOF
}

# Serve command help  
show_serve_help() {
    cat << EOF
Rocky Linux Documentation - Fast Serve (No Rebuild)

DESCRIPTION:
  Starts a FAST local development server using previously deployed versions.
  Serves existing mike-deployed content from gh-pages branch without rebuilding.
  Use --deploy first to create/update versions if needed.

FEATURES:
  - FAST startup (no rebuilding)
  - Multi-version support with version selector
  - Serves pre-built content from gh-pages branch
  - Root + versioned access (/, /8/, /9/, /10/, /latest/)
  - Port fallback (8000 → 8001 → 8002 if ports busy)

USAGE:
  $0 --serve [ENVIRONMENT] [OPTIONS]

ENVIRONMENTS:
  (default)   Use Python virtual environment setup
  --docker    Use Docker container for serving

OPTIONS:
  --static    Serve static files (exact production behavior)

NOTE: --minimal/--full options only apply to --setup command. Deploy uses setup's configuration.
      Serve modes use whatever content was already deployed to gh-pages.

THIS COMMAND RUNS:
  For default (venv):
  - cd $APP_DIR
  - source venv/bin/activate
  - mike serve -a localhost:PORT --config-file mkdocs.yml (if not --static)
  - python3 -m http.server PORT -d site-static (if --static)
  
  For --docker:
  - docker run -d --name rockydocs-serve-$USER -p PORT:8000 \
    -v $APP_DIR:/app -v $CONTENT_DIR/docs:/app/content \
    rockydocs-dev mkdocs serve -a 0.0.0.0:8000 (if not --static)
  - docker run -d --name rockydocs-serve-$USER -p PORT:8000 \
    -v $APP_DIR:/app rockydocs-dev \
    python3 -m http.server 8000 -d /app/site-static (if --static)

PREREQUISITES:
  Run --deploy first to build/deploy versions:
  $0 --deploy

MANUAL ALTERNATIVE:
  cd $APP_DIR
  source venv/bin/activate
  mike serve -a localhost:8000

ACCESS:
  Local site will be available at: http://localhost:8000 (or 8001/8002)
  Live reload enabled - changes appear automatically

Current version being served: Rocky Linux $(detect_version)

EOF
}

# Help function for dual server mode
show_serve_dual_help() {
    cat << EOF
Rocky Linux Documentation - Dual Server Mode (Live Reload)

DESCRIPTION:
  Starts DUAL servers for optimal development experience:
  - Port 8000+: Multi-version server (production-like)
  - Port 8001+: Live development server (with reload)

FEATURES:
  - Multi-version server: Complete version selector, root + versioned access
  - Live development server: File changes auto-refresh, --watch-theme support
  - Simultaneous operation for different use cases
  - Smart port conflict resolution (8000→8010→8020, 8001→8011→8021)
  - Proper cleanup on exit

USAGE:
  $0 --serve-dual [ENVIRONMENT] [OPTIONS]

ENVIRONMENTS:
  --venv      Use Python virtual environment (default)
  --docker    Use Docker containers for both servers
  --podman    Use Podman containers for both servers

OPTIONS:
  --minimal   Use minimal config (English + Ukrainian)
  --workspace DIR  Set workspace directory

EXAMPLES:
  $0 --serve-dual                # Native venv: mike serve + mkdocs serve
  $0 --serve-dual --podman       # Dual Podman containers
  $0 --serve-dual --docker       # Dual Docker containers

ACCESS PATTERNS:
  Multi-version (Port 8000):
    • http://localhost:8000/          → Rocky Linux 10 (latest)
    • http://localhost:8000/10/       → Rocky Linux 10 (versioned)
    • http://localhost:8000/9/        → Rocky Linux 9
    • http://localhost:8000/8/        → Rocky Linux 8

  Live Reload (Port 8001):
    • http://localhost:8001/          → Current content with live reload
    • File changes automatically refresh browser
    • Theme changes supported with --watch-theme

NOTES:
  - Use port 8000 for testing multi-version functionality
  - Use port 8001 for active content editing with live reload
  - Both servers run simultaneously in background
  - Ctrl+C cleanly stops both servers

EOF
}

# Stop command help
show_stop_help() {
    cat << EOF
Rocky Linux Documentation - Stop All Services

DESCRIPTION:
  Stops all running documentation servers and containers across all environments.
  Provides comprehensive cleanup for development workflows.

USAGE:
  $0 --stop

WHAT THIS COMMAND STOPS:
  • Python HTTP servers (port 8000, 8001, 8002)
  • MkDocs development servers (all ports)
  • Docker containers (rockydocs-*)
  • Podman containers (rockydocs-*)
  • LXD containers (rockydocs-*)
  • Background processes started by this script

ENVIRONMENTS SUPPORTED:
  • Virtual environment (venv) servers
  • Docker containerized services
  • Podman containerized services  
  • LXD containerized services
  • Mixed environments (stops all)

PROCESS:
  1. Identify all related processes and containers
  2. Gracefully stop services with proper signals
  3. Remove stopped containers
  4. Clean up temporary files and logs
  5. Report cleanup results

EXAMPLES:
  $0 --stop                      # Stop everything
  $0 --stop && $0 --serve        # Restart clean

NOTES:
  - Safe to run multiple times
  - Does not affect source code or configurations
  - Preserves deployed versions for quick restart
  - Automatic cleanup on script interruption (Ctrl+C)

EOF
}

# Install command help
show_install_help() {
    local environment="$1"
    
    if [ "$environment" = "lxd" ]; then
        cat << EOF
Rocky Linux Documentation - Install LXD System Containers

DESCRIPTION:
  Installs and configures LXD (Linux Container Daemon) on Rocky Linux 10 systems.
  Sets up system container infrastructure for isolated documentation builds.

USAGE:
  $0 --install --lxd

WHAT THIS COMMAND DOES:
  • Verifies Rocky Linux 10 system compatibility
  • Installs snapd package manager and kernel modules
  • Installs LXD via snap (latest stable channel 5.0)
  • Initializes LXD with default configuration
  • Sets up unprivileged container security
  • Creates necessary user groups and permissions
  • Configures AppArmor security profiles
  • Tests basic container functionality

PREREQUISITES:
  • Rocky Linux 10 server with root access
  • Internet connection for package downloads
  • At least 2GB available disk space
  • Kernel 3.10+ with container support

SYSTEM CHANGES:
  • Enables snapd daemon service
  • Creates /snap symlink for snap packages
  • Adds current user to lxd group
  • Configures kernel modules for containers
  • Sets up LXD storage backend

EXAMPLES:
  $0 --install --lxd                # Install LXD on Rocky Linux 10
  $0 --install --lxd && $0 --setup --lxd    # Install then setup

NOTES:
  - Only supports Rocky Linux 10
  - Requires system reboot after installation
  - Can be safely run multiple times
  - Use --uninstall --lxd to remove if needed

EOF
    elif [ "$environment" = "docker" ]; then
        cat << EOF
Rocky Linux Documentation - Install Docker Application Containers

DESCRIPTION:
  Installs and configures Docker Engine on Rocky Linux 10 systems.
  Sets up application container infrastructure for isolated documentation builds.

USAGE:
  $0 --install --docker

WHAT THIS COMMAND DOES:
  • Verifies Rocky Linux 10 system compatibility
  • Updates system packages and installs prerequisites
  • Adds Docker CE repository from docker.com
  • Installs Docker CE, CLI, and build plugins
  • Configures Docker daemon for security and performance
  • Enables and starts Docker service
  • Adds current user to docker group
  • Tests basic container functionality

PREREQUISITES:
  • Rocky Linux 10 server with root access
  • Internet connection for package downloads
  • At least 2GB available disk space
  • Compatible kernel with container support

SYSTEM CHANGES:
  • Enables Docker daemon service
  • Creates Docker daemon configuration
  • Adds current user to docker group
  • Configures storage driver (overlay2)
  • Sets up container resource limits

EXAMPLES:
  $0 --install --docker              # Install Docker on Rocky Linux 10
  $0 --install --docker && $0 --setup --docker  # Install then setup

NOTES:
  - Only supports Rocky Linux 10
  - Logout/login required after installation for group changes
  - Can be safely run multiple times
  - Use --uninstall --docker to remove if needed

EOF
    else
        cat << EOF
Rocky Linux Documentation - Install Container Runtime

USAGE:
  $0 --install --lxd        # Install LXD (system containers)
  $0 --install --docker     # Install Docker (application containers)

SUPPORTED ENVIRONMENTS:
  --lxd      System containers with full OS isolation
  --docker   Application containers with efficient layered storage

For specific help:
  $0 --install --lxd -h     # LXD installation help
  $0 --install --docker -h  # Docker installation help

EOF
    fi
}

# Uninstall command help  
show_uninstall_help() {
    local environment="$1"
    
    if [ "$environment" = "lxd" ]; then
        cat << EOF
Rocky Linux Documentation - Uninstall LXD System Containers

DESCRIPTION:
  Removes LXD and all associated containers, images, and configurations.
  Provides complete cleanup of LXD system container infrastructure.

USAGE:
  $0 --uninstall --lxd

WHAT THIS COMMAND DOES:
  • Stops all running rockydocs-* containers
  • Removes all LXD containers and images
  • Removes LXD snap package
  • Removes snapd if no other snaps installed
  • Cleans up LXD storage pools and networks
  • Removes /snap symlink and directories
  • Reverts system configuration changes
  • Provides uninstall progress feedback

WARNING:
  This will destroy ALL LXD containers and data on the system,
  not just rockydocs containers.

SYSTEM CHANGES REVERTED:
  • Removes snapd daemon service
  • Removes /snap symlink
  • Cleans up LXD storage backend
  • Removes container-related packages

EXAMPLES:
  $0 --uninstall --lxd             # Remove LXD completely
  $0 --stop && $0 --uninstall --lxd    # Stop services first

NOTES:
  - Requires confirmation for destructive operations
  - Cannot be undone - backup important containers first
  - May require system reboot for complete cleanup
  - Safe to run if LXD already removed

EOF
    elif [ "$environment" = "docker" ]; then
        cat << EOF
Rocky Linux Documentation - Uninstall Docker Application Containers

DESCRIPTION:
  Removes Docker Engine and all associated containers, images, and configurations.
  Provides complete cleanup of Docker application container infrastructure.

USAGE:
  $0 --uninstall --docker

WHAT THIS COMMAND DOES:
  • Stops all running Docker containers
  • Removes all Docker containers and images
  • Removes all Docker volumes and networks
  • Removes Docker Engine packages
  • Removes Docker daemon configuration
  • Cleans up Docker data directories
  • Reverts system configuration changes
  • Provides uninstall progress feedback

WARNING:
  This will destroy ALL Docker containers, images, and data on the system,
  not just rockydocs containers.

SYSTEM CHANGES REVERTED:
  • Removes Docker daemon service
  • Removes Docker data directory (/var/lib/docker)
  • Removes Docker configuration (/etc/docker)
  • Removes Docker repository configuration
  • Removes user group memberships

EXAMPLES:
  $0 --uninstall --docker          # Remove Docker completely
  $0 --stop && $0 --uninstall --docker  # Stop services first

NOTES:
  - Requires confirmation for destructive operations
  - Cannot be undone - backup important containers first
  - Safe to run if Docker already removed
  - Removes all Docker data permanently

EOF
    else
        cat << EOF
Rocky Linux Documentation - Uninstall Container Runtime

USAGE:
  $0 --uninstall --lxd        # Uninstall LXD (system containers)
  $0 --uninstall --docker     # Uninstall Docker (application containers)

SUPPORTED ENVIRONMENTS:
  --lxd      Remove LXD system containers and snapd
  --docker   Remove Docker application containers and daemon

For specific help:
  $0 --uninstall --lxd -h     # LXD uninstall help
  $0 --uninstall --docker -h  # Docker uninstall help

WARNING: Both operations will destroy ALL containers and data!

EOF
    fi
}

# Deploy command help
show_deploy_help() {
    cat << EOF
Rocky Linux Documentation - Build and Deploy All Versions Locally

DESCRIPTION:
  Builds and deploys ALL Rocky Linux versions (8, 9, 10) locally for testing.
  This is a ONE-TIME operation that creates the complete versioned site in your
  local build repository. It does NOT push to any remote.

USAGE:
  $0 --deploy [ENVIRONMENT] [OPTIONS]

ENVIRONMENTS:
  (default)   Use Python virtual environment setup
  --docker    Use Docker container for deployment

OPTIONS:
  (none)      Uses language configuration set during --setup

THIS COMMAND RUNS:
  For default (venv):
  - cd $APP_DIR
  - Uses existing mkdocs.yml configuration from setup
  - Deletes and recreates the local 'gh-pages' branch
  - Setup cached repositories for each version
  - source venv/bin/activate
  - mike deploy 8 --title 'Rocky Linux 8' (from rocky-8 branch)
  - mike deploy 9 --title 'Rocky Linux 9' (from rocky-9 branch)
  - mike deploy 10 latest --title 'Rocky Linux 10' (from main branch)
  - mike set-default latest
  - Applies local-only commit to serve 'latest' content from web root
  
  For --docker:
  - Uses existing mkdocs.yml configuration from setup
  - Creates temporary deployment script in container
  - docker run --name rockydocs-deploy-$USER \
    -v $APP_DIR:/app -v $CONTENT_DIR/docs:/app/content \
    rockydocs-dev bash /app/temp_deploy.sh
  - Extracts site-static artifacts from container
  - Applies web root override for production-identical serving

MANUAL ALTERNATIVE:
  cd $APP_DIR
  source venv/bin/activate  
  mike deploy 8 9 10 latest

OUTPUT:
  Deployed versions available for serving with --serve
  Use $0 --serve to start fast development server

Current version being deployed: Rocky Linux $(detect_version)

EOF
}

# === SETUP FUNCTIONS ===

# Smart repository discovery and reuse
find_existing_app_repo() {
    # Check if there's already a docs.rockylinux.org repo at workspace root level
    local potential_paths=(
        "$WORKSPACE_BASE_DIR/docs.rockylinux.org"
        "$WORKSPACE_BASE_DIR/../*/docs.rockylinux.org"  # Check sibling workspace directories
    )
    
    for path in "${potential_paths[@]}"; do
        if [ -d "$path/.git" ]; then
            local remote_url=$(cd "$path" && git remote get-url origin 2>/dev/null || echo "")
            if [[ "$remote_url" == *"docs.rockylinux.org"* ]]; then
                echo "$path"
                return 0
            fi
        fi
    done
    return 1
}

# Setup function
setup_environment() {
    local env_type="$1"
    local build_type="$2"
    
    print_info "Setting up Rocky Linux documentation environment..."
    print_info "Target: Recreate https://docs.rockylinux.org locally"
    print_info "Version: Rocky Linux $(detect_version)"
    print_info "Workspace: $WORKSPACE_BASE_DIR"
    
    # Save workspace configuration if this is first time or different from saved
    if [ ! -f "$CONFIG_FILE" ] || [ "$WORKSPACE_BASE_DIR" != "${SAVED_WORKSPACE_BASE_DIR:-}" ]; then
        save_workspace_config "$WORKSPACE_BASE_DIR"
    fi
    
    # Create workspace
    run_cmd "mkdir -p $WORKSPACE_BASE_DIR"
    
    # Smart repository handling
    if [ ! -d "$APP_DIR" ]; then
        # Check if we can reuse an existing repo
        local existing_repo=$(find_existing_app_repo)
        if [ $? -eq 0 ] && [ -n "$existing_repo" ]; then
            print_info "Found existing docs.rockylinux.org repository at: $existing_repo"
            print_info "Creating symlink to reuse existing repository..."
            run_cmd "ln -sf $existing_repo $APP_DIR"
        else
            print_info "Cloning fresh docs.rockylinux.org repository..."
            run_cmd "git clone https://github.com/rocky-linux/docs.rockylinux.org.git $APP_DIR"
        fi
    fi
    
    # Create compatibility symlink for backward compatibility
    if [ ! -e "$APP_COMPAT_LINK" ]; then
        run_cmd "ln -sf docs.rockylinux.org $APP_COMPAT_LINK"
        print_info "Created compatibility symlink: app -> docs.rockylinux.org"
    fi
    
    # Setup environment based on type
    case "$env_type" in
        "venv")
            setup_venv "$build_type"
            ;;
        "docker")
            setup_docker "$build_type"
            ;;
        "podman")
            setup_podman "$build_type"
            ;;
        "lxd")
            setup_lxd "$build_type"
            ;;
        *)
            print_error "Unknown environment type: $env_type"
            exit 1
            ;;
    esac
    
    print_success "Setup complete!"
    print_info "Content editing: $CONTENT_DIR/docs/"
    print_info "App environment: $APP_DIR"
    print_info "Next: $0 --serve"
}

# Setup Python virtual environment
setup_venv() {
    local build_type="$1"
    
    print_info "Setting up Python virtual environment..."
    
    run_cmd "cd $APP_DIR"
    
    if [ ! -d "venv" ]; then
        run_cmd_with_rollback "python3 -m venv venv" "rm -rf venv" "Failed to create virtual environment"
    fi
    
    # Install requirements with error handling
    if ! run_cmd_with_rollback "source venv/bin/activate && pip install -r requirements.txt" "" "Failed to install requirements"; then
        return 1
    fi
    
    # Setup content symlink using utility function
    manage_content_symlink "create" "$CONTENT_DIR/docs" "content"
    
    # Setup config using utility function
    setup_mkdocs_config "$build_type" "$APP_DIR"
}

# Setup Docker environment
setup_docker() {
    local build_type="$1"
    
    print_info "Setting up Docker environment..."
    
    # Create Dockerfile if not exists
    if [ ! -f "$APP_DIR/Dockerfile.dev" ]; then
        cat > "$APP_DIR/Dockerfile.dev" << 'EOF'
FROM python:3.9-slim

# Install git (required for mkdocs-git-revision-date-localized-plugin)
RUN apt-get update && apt-get install -y git && rm -rf /var/lib/apt/lists/*

WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .
EXPOSE 8000

CMD ["mkdocs", "serve", "-a", "0.0.0.0:8000"]
EOF
    fi
    
    
    run_cmd "cd $APP_DIR"
    run_cmd "rm -rf content && ln -sf $CONTENT_DIR/docs content"
    
    if [ "$build_type" = "minimal" ]; then
        run_cmd "cp -f configs/mkdocs.minimal.yml mkdocs.yml"
    else
        run_cmd "cp -f configs/mkdocs.full.yml mkdocs.yml"
    fi
    
    run_cmd "docker build -f Dockerfile.dev -t rockydocs-dev ."
    
    print_info "Docker image built: rockydocs-dev"
    print_info "To run: docker run -p 8000:8000 -v $CONTENT_DIR/docs:/app/content rockydocs-dev"
    print_info "Or use: ./rockydocs-dev-12.sh --serve --docker (when implemented)"
}

# Setup Podman environment
setup_podman() {
    local build_type="$1"
    
    print_info "Setting up Podman environment..."
    
    # Validate Podman availability
    if ! command -v podman >/dev/null 2>&1; then
        print_error "Podman is not installed or not in PATH"
        print_info "Please install Podman and try again"
        print_info "See: https://podman.io/getting-started/installation"
        exit 1
    fi
    
    # Check if Podman service is available (for rootless mode)
    if ! podman info >/dev/null 2>&1; then
        print_error "Podman service is not available or not configured properly"
        print_info "For rootless Podman, you may need to:"
        print_info "  1. Start user service: systemctl --user start podman"
        print_info "  2. Enable at boot: systemctl --user enable podman"
        print_info "  3. Configure subuids/subgids if needed"
        exit 1
    fi
    
    # Create Dockerfile if not exists (same as Docker setup but standalone)
    if [ ! -f "$APP_DIR/Dockerfile.dev" ]; then
        cat > "$APP_DIR/Dockerfile.dev" << 'EOF'
FROM python:3.9-slim

# Install git (required for mkdocs-git-revision-date-localized-plugin)
RUN apt-get update && apt-get install -y git && rm -rf /var/lib/apt/lists/*

WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .
EXPOSE 8000

CMD ["mkdocs", "serve", "-a", "0.0.0.0:8000"]
EOF
    fi
    
    run_cmd "cd $APP_DIR"
    run_cmd "rm -rf content && ln -sf $CONTENT_DIR/docs content"
    
    if [ "$build_type" = "minimal" ]; then
        run_cmd "cp -f configs/mkdocs.minimal.yml mkdocs.yml"
    else
        run_cmd "cp -f configs/mkdocs.full.yml mkdocs.yml"
    fi
    
    run_cmd "podman build -f Dockerfile.dev -t rockydocs-dev ."
    
    print_info "Podman image built: rockydocs-dev"
    print_info "To run: podman run -p 8000:8000 -v $CONTENT_DIR/docs:/app/content rockydocs-dev"
    print_info "Or use: $0 --serve --podman"
}

# LXD Container Environment Functions
install_lxd() {
    print_info "Installing LXD on Rocky Linux 10..."
    
    # Verify Rocky Linux 10
    if ! grep -q "VERSION_ID=\"10" /etc/os-release 2>/dev/null; then
        print_error "LXD installation script only supports Rocky Linux 10"
        return 1
    fi
    
    # Check if already installed
    if command -v lxd >/dev/null 2>&1; then
        print_warning "LXD is already installed"
        lxd version
        return 0
    fi
    
    # Install prerequisites
    print_info "Installing LXD prerequisites..."
    run_cmd "dnf install -y epel-release"
    run_cmd "dnf install -y snapd kernel-modules-extra"
    
    # Enable snapd
    print_info "Enabling snapd service..."
    run_cmd "systemctl enable --now snapd.socket"
    run_cmd "systemctl enable --now snapd"
    
    # Create snap symlink
    if [ ! -L "/snap" ]; then
        run_cmd "ln -sf /var/lib/snapd/snap /snap"
    fi
    
    # Check if squashfs module is available
    if ! find /lib/modules/$(uname -r) -name '*squashfs*' >/dev/null 2>&1; then
        print_warning "Squashfs kernel module not found for current kernel"
        print_info "This usually means a kernel update is needed"
        print_info "After reboot, re-run: $0 --install --lxd"
        print_info "Then run: $0 --setup --lxd"
        return 2  # Special return code for "reboot required"
    fi
    
    # Install LXD via snap
    print_info "Installing LXD 5.0 LTS via snap..."
    run_cmd "snap install lxd --channel=5.0/stable"
    
    # Add snap binaries to PATH if not already there
    if ! echo "$PATH" | grep -q "/snap/bin"; then
        export PATH="$PATH:/snap/bin"
        echo 'export PATH="$PATH:/snap/bin"' >> /etc/profile.d/snap.sh
    fi
    
    # Wait for LXD to be ready
    print_info "Waiting for LXD to be ready..."
    if ! lxd waitready --timeout=60; then
        print_error "LXD failed to start within 60 seconds"
        return 1
    fi
    
    # Initialize LXD with default configuration
    print_info "Initializing LXD with default configuration..."
    run_cmd "lxd init --auto"
    
    # Verify installation
    print_info "Verifying LXD installation..."
    if lxd version && lxc image list >/dev/null 2>&1; then
        print_success "LXD installation completed successfully"
        lxd version
        return 0
    else
        print_error "LXD installation verification failed"
        return 1
    fi
}

uninstall_lxd() {
    print_warning "Uninstalling LXD and all containers/images..."
    
    # Confirm operation
    read -p "This will remove all LXD containers and data. Continue? (y/N): " confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        print_info "LXD uninstall cancelled"
        return 0
    fi
    
    # Stop all containers
    print_info "Stopping all LXD containers..."
    lxc list --format csv -c n | while read container_name; do
        if [ -n "$container_name" ]; then
            lxc stop "$container_name" --force 2>/dev/null || true
        fi
    done
    
    # Delete all containers
    print_info "Deleting all LXD containers..."
    lxc list --format csv -c n | while read container_name; do
        if [ -n "$container_name" ]; then
            lxc delete "$container_name" 2>/dev/null || true
        fi
    done
    
    # Remove LXD snap
    print_info "Removing LXD snap package..."
    run_cmd "snap remove lxd"
    
    # Optionally remove snapd
    read -p "Remove snapd as well? (y/N): " remove_snapd
    if [[ "$remove_snapd" = "y" || "$remove_snapd" = "Y" ]]; then
        run_cmd "dnf remove -y snapd snap-confine snapd-selinux"
        run_cmd "rm -f /snap"
    fi
    
    print_success "LXD uninstalled successfully"
}

check_lxd_availability() {
    # Check if LXD command exists
    if ! command -v lxd >/dev/null 2>&1; then
        print_error "LXD is not installed or not in PATH"
        print_info "Please install LXD first:"
        print_info "  $0 --install --lxd"
        print_info "Or install manually following the documentation"
        return 1
    fi
    
    # Check if LXD daemon is running
    if ! lxd waitready --timeout=10 >/dev/null 2>&1; then
        print_error "LXD daemon is not running or not initialized"
        print_info "Please run 'lxd init' to initialize LXD"
        print_info "Or restart LXD service"
        return 1
    fi
    
    # Check if we can communicate with LXD
    if ! lxc info >/dev/null 2>&1; then
        print_error "Cannot communicate with LXD daemon"
        print_info "Please check LXD permissions and configuration"
        return 1
    fi
    
    return 0
}

get_lxd_container_name() {
    local operation="$1"
    echo "rockydocs-${operation}-${USER:-root}-$(date +%s)"
}

create_build_container() {
    local build_type="$1"
    local container_name="$2"
    
    print_info "Creating LXD build container: $container_name"
    
    # Launch Rocky Linux 10 container
    if ! lxc launch images:rocky/10 "$container_name"; then
        print_error "Failed to create LXD container"
        return 1
    fi
    
    # Wait for container to be ready
    print_info "Waiting for container to be ready..."
    local timeout=60
    local count=0
    while [ $count -lt $timeout ]; do
        if lxc exec "$container_name" -- echo "ready" >/dev/null 2>&1; then
            break
        fi
        sleep 1
        count=$((count + 1))
    done
    
    if [ $count -ge $timeout ]; then
        print_error "Container failed to start within $timeout seconds"
        lxc delete "$container_name" --force 2>/dev/null || true
        return 1
    fi
    
    # Install dependencies in container
    print_info "Installing dependencies in container..."
    lxc exec "$container_name" -- dnf update -y
    lxc exec "$container_name" -- dnf install -y python3 python3-pip git
    
    # Create app directory in container
    lxc exec "$container_name" -- mkdir -p /app
    
    print_success "Build container $container_name created successfully"
    return 0
}

setup_container_mounts() {
    local container_name="$1"
    
    print_info "Setting up container mounts..."
    
    # Mount app directory (read-write)
    if ! lxc config device add "$container_name" app disk source="$APP_DIR" path="/app"; then
        print_error "Failed to mount app directory"
        return 1
    fi
    
    # Mount content directory (read-only)
    if ! lxc config device add "$container_name" content disk source="$CONTENT_DIR/docs" path="/app/content" readonly=true; then
        print_warning "Failed to mount content directory (continuing anyway)"
    fi
    
    return 0
}

setup_container_resources() {
    local container_name="$1"
    
    print_info "Configuring container resource limits..."
    
    # Set resource limits
    lxc config set "$container_name" limits.cpu 4
    lxc config set "$container_name" limits.memory 4GB
    lxc config set "$container_name" limits.processes 1000
    
    # Security settings
    lxc config set "$container_name" security.privileged false
    lxc config set "$container_name" security.nesting false
    
    return 0
}

setup_container_networking() {
    local container_name="$1"
    local port="${2:-8000}"
    
    print_info "Setting up container networking..."
    
    # Setup port forwarding for documentation server
    if ! lxc config device add "$container_name" http-proxy proxy \
         listen="tcp:0.0.0.0:$port" \
         connect="tcp:127.0.0.1:$port"; then
        print_warning "Failed to setup port forwarding (port may be in use)"
        # Try alternative port
        local alt_port=$((port + 1))
        print_info "Trying alternative port $alt_port..."
        lxc config device add "$container_name" http-proxy proxy \
            listen="tcp:0.0.0.0:$alt_port" \
            connect="tcp:127.0.0.1:$port" || true
    fi
    
    return 0
}

cleanup_lxd_containers() {
    local max_age="${1:-86400}"  # Default 24 hours
    
    print_info "Cleaning up old LXD containers older than $((max_age / 3600)) hours..."
    
    lxc list --format csv -c n,s | while IFS=, read container_name status; do
        if [[ "$container_name" == rockydocs-* ]]; then
            if [ "$status" = "STOPPED" ]; then
                # Get container creation time (simplified check)
                local creation_time=$(lxc info "$container_name" | grep "Created:" | head -1 || echo "")
                if [ -n "$creation_time" ]; then
                    print_info "Removing old container: $container_name"
                    lxc delete "$container_name" 2>/dev/null || true
                fi
            fi
        fi
    done
}

setup_lxd() {
    local build_type="$1"
    
    # Check LXD availability first
    if ! check_lxd_availability; then
        return 1
    fi
    
    print_info "Setting up LXD container environment for $build_type build..."
    
    # Cleanup old containers first
    cleanup_lxd_containers
    
    # Create build container
    local container_name
    container_name=$(get_lxd_container_name "setup")
    
    if ! create_build_container "$build_type" "$container_name"; then
        return 1
    fi
    
    # Setup container resources
    setup_container_resources "$container_name"
    
    # Setup container mounts
    if ! setup_container_mounts "$container_name"; then
        lxc delete "$container_name" --force 2>/dev/null || true
        return 1
    fi
    
    # Install Python requirements in container
    print_info "Installing Python requirements in container..."
    lxc exec "$container_name" -- pip3 install mkdocs mkdocs-material mkdocs-static-i18n mkdocs-git-revision-date-localized-plugin mike
    
    # Setup content symlink inside container
    lxc exec "$container_name" -- bash -c "cd /app && rm -rf content && ln -sf /app/content content"
    
    # Copy appropriate configuration
    if [ "$build_type" = "minimal" ]; then
        lxc file push "$APP_DIR/configs/mkdocs.minimal.yml" "$container_name/app/mkdocs.yml"
    else
        lxc file push "$APP_DIR/configs/mkdocs.full.yml" "$container_name/app/mkdocs.yml"
    fi
    
    # Store container name for later use
    echo "$container_name" > "$APP_DIR/.lxd-container"
    
    print_success "LXD environment setup complete"
    print_info "Container: $container_name"
    print_info "To deploy: $0 --deploy --lxd"
    print_info "To serve: $0 --serve --lxd"
}

deploy_lxd() {
    local build_type="$1"
    
    # Check LXD availability
    if ! check_lxd_availability; then
        return 1
    fi
    
    print_info "Deploying documentation in LXD container..."
    
    # Get container name from setup
    local container_name
    if [ -f "$APP_DIR/.lxd-container" ]; then
        container_name=$(cat "$APP_DIR/.lxd-container")
    else
        print_error "No LXD container found. Please run --setup --lxd first"
        return 1
    fi
    
    # Verify container exists and is running
    if ! lxc list --format csv -c n | grep -q "^$container_name$"; then
        print_error "Container $container_name not found"
        return 1
    fi
    
    # Start container if stopped
    local container_status=$(lxc list --format csv -c n,s | grep "^$container_name," | cut -d, -f2)
    if [ "$container_status" = "STOPPED" ]; then
        print_info "Starting container $container_name..."
        lxc start "$container_name"
        
        # Wait for container to be ready
        local timeout=30
        local count=0
        while [ $count -lt $timeout ]; do
            if lxc exec "$container_name" -- echo "ready" >/dev/null 2>&1; then
                break
            fi
            sleep 1
            count=$((count + 1))
        done
        
        if [ $count -ge $timeout ]; then
            print_error "Container failed to start within $timeout seconds"
            return 1
        fi
    fi
    
    # Configure git in container
    print_info "Configuring git in container..."
    lxc exec "$container_name" -- git config --global user.name "Rocky Linux Documentation Bot"
    lxc exec "$container_name" -- git config --global user.email "noreply@rockylinux.org"
    
    # Initialize git repository in container if needed
    lxc exec "$container_name" -- bash -c "cd /app && if [ ! -d .git ]; then git init; fi"
    
    # Execute deployment inside container
    print_info "Executing deployment inside container..."
    lxc exec "$container_name" -- bash -c "
        cd /app
        
        # Ensure content symlink exists
        rm -rf content && ln -sf /app/content content
        
        # Initialize git if needed
        if [ ! -f .git/config ]; then
            git add mkdocs.yml 2>/dev/null || true
            git commit -m 'Initial commit for container deployment' 2>/dev/null || true
        fi
        
        # Deploy Rocky Linux 8
        echo 'Deploying Rocky Linux 8...'
        mike deploy 8 --config-file mkdocs.yml || echo 'Rocky 8 deployment skipped'
        
        # Deploy Rocky Linux 9
        echo 'Deploying Rocky Linux 9...'
        mike deploy 9 --config-file mkdocs.yml || echo 'Rocky 9 deployment skipped'
        
        # Deploy Rocky Linux 10 (latest)
        echo 'Deploying Rocky Linux 10...'
        mike deploy 10 latest --update-aliases --config-file mkdocs.yml
        
        # Set default version
        mike set-default latest --config-file mkdocs.yml
        
        echo 'Deployment completed successfully'
    "
    
    if [ $? -eq 0 ]; then
        print_success "LXD deployment completed successfully"
        print_info "Container: $container_name"
        print_info "To serve: $0 --serve --lxd"
        print_info "To serve static: $0 --serve --lxd --static"
        
        # Store successful deployment indicator
        echo "deployed" > "$APP_DIR/.lxd-deployment"
        
        return 0
    else
        print_error "LXD deployment failed"
        return 1
    fi
}

serve_lxd() {
    local serve_mode="$1"
    
    # Check LXD availability
    if ! check_lxd_availability; then
        return 1
    fi
    
    # Get container name from setup
    local container_name
    if [ -f "$APP_DIR/.lxd-container" ]; then
        container_name=$(cat "$APP_DIR/.lxd-container")
    else
        print_error "No LXD container found. Please run --setup --lxd first"
        return 1
    fi
    
    # Verify container exists
    if ! lxc list --format csv -c n | grep -q "^$container_name$"; then
        print_error "Container $container_name not found"
        return 1
    fi
    
    # Start container if stopped
    local container_status=$(lxc list --format csv -c n,s | grep "^$container_name," | cut -d, -f2)
    if [ "$container_status" = "STOPPED" ]; then
        print_info "Starting container $container_name..."
        lxc start "$container_name"
        sleep 5  # Give container time to start
    fi
    
    # Setup port forwarding
    local port=8000
    while lsof -Pi :$port -sTCP:LISTEN -t >/dev/null 2>&1; do
        port=$((port + 1))
    done
    
    setup_container_networking "$container_name" "$port"
    
    if [ "$serve_mode" = "static" ]; then
        print_info "Starting static documentation server in container..."
        
        # Check if deployment exists
        if [ ! -f "$APP_DIR/.lxd-deployment" ]; then
            print_warning "No deployment found. Running deployment first..."
            if ! deploy_lxd "${BUILD_TYPE:-minimal}"; then
                return 1
            fi
        fi
        
        # Extract static files and serve
        lxc exec "$container_name" -- bash -c "
            cd /app
            
            # Extract static files from mike deployment
            if [ -d site ]; then
                rm -rf site-static
                cp -r site site-static
                
                # Apply web root override (copy latest to root)
                if [ -d site-static/latest ]; then
                    cp -r site-static/latest/* site-static/
                fi
                
                echo 'Static files extracted successfully'
                echo 'Starting Python HTTP server...'
                cd site-static
                python3 -m http.server 8000 --bind 0.0.0.0
            else
                echo 'No site directory found. Please run deployment first.'
                exit 1
            fi
        " &
        
        # Store server PID for cleanup
        local server_pid=$!
        echo "$server_pid:$container_name:static" >> "$APP_DIR/.lxd-servers"
        
    else
        print_info "Starting live documentation server in container..."
        
        # Start mike serve in container
        lxc exec "$container_name" -- bash -c "
            cd /app
            echo 'Starting mike serve...'
            mike serve --dev-addr 0.0.0.0:8000
        " &
        
        # Store server PID for cleanup
        local server_pid=$!
        echo "$server_pid:$container_name:live" >> "$APP_DIR/.lxd-servers"
    fi
    
    # Wait a moment for server to start
    sleep 3
    
    # Check if server is responding
    local attempts=0
    local max_attempts=12
    while [ $attempts -lt $max_attempts ]; do
        if curl -s -f "http://localhost:$port/" >/dev/null 2>&1; then
            print_success "Documentation server started successfully"
            print_info "Server URL: http://localhost:$port/"
            print_info "Container: $container_name"
            print_info "Mode: $serve_mode"
            
            if [ "$serve_mode" = "static" ]; then
                print_info "Static files served from container with web root override"
            else
                print_info "Live development server with auto-reload"
            fi
            
            return 0
        fi
        sleep 5
        attempts=$((attempts + 1))
    done
    
    print_error "Documentation server failed to start or is not responding"
    return 1
}

stop_lxd_services() {
    print_info "Stopping LXD documentation services..."
    
    # Stop container servers
    if [ -f "$APP_DIR/.lxd-servers" ]; then
        while IFS=':' read -r pid container_name mode; do
            if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
                print_info "Stopping $mode server (PID: $pid) in container $container_name"
                kill "$pid" 2>/dev/null || true
            fi
        done < "$APP_DIR/.lxd-servers"
        rm -f "$APP_DIR/.lxd-servers"
    fi
    
    # Stop containers
    if [ -f "$APP_DIR/.lxd-container" ]; then
        local container_name=$(cat "$APP_DIR/.lxd-container")
        if lxc list --format csv -c n | grep -q "^$container_name$"; then
            local container_status=$(lxc list --format csv -c n,s | grep "^$container_name," | cut -d, -f2)
            if [ "$container_status" = "RUNNING" ]; then
                print_info "Stopping container $container_name"
                lxc stop "$container_name"
            fi
        fi
    fi
    
    print_success "LXD services stopped"
}

# === DOCKER FUNCTIONS ===

# Install Docker on Rocky Linux 10
install_docker() {
    print_info "Installing Docker on Rocky Linux 10..."
    
    # Verify Rocky Linux 10
    if ! grep -q "VERSION_ID=\"10" /etc/os-release 2>/dev/null; then
        print_error "Docker installation script only supports Rocky Linux 10"
        return 1
    fi
    
    # Check if already installed
    if command -v docker >/dev/null 2>&1; then
        print_warning "Docker is already installed"
        docker --version
        return 0
    fi
    
    # Update system packages
    print_info "Updating system packages..."
    run_cmd "dnf update -y"
    
    # Install prerequisites
    print_info "Installing Docker prerequisites..."
    run_cmd "dnf install -y dnf-plugins-core device-mapper-persistent-data lvm2"
    
    # Add Docker repository
    print_info "Adding Docker CE repository..."
    run_cmd "dnf config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo"
    
    # Update package index
    run_cmd "dnf makecache"
    
    # Install Docker CE
    print_info "Installing Docker CE..."
    run_cmd "dnf install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin"
    
    # Enable and start Docker service
    print_info "Enabling and starting Docker service..."
    run_cmd "systemctl enable --now docker"
    
    # Configure Docker daemon for security and performance
    print_info "Configuring Docker daemon..."
    run_cmd "mkdir -p /etc/docker"
    
    cat > /etc/docker/daemon.json << 'EOF'
{
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "10m",
    "max-file": "3"
  },
  "storage-driver": "overlay2",
  "userland-proxy": false,
  "experimental": false,
  "default-ulimits": {
    "nofile": {
      "Name": "nofile",
      "Hard": 64000,
      "Soft": 64000
    }
  }
}
EOF
    
    # Restart Docker to apply configuration
    print_info "Restarting Docker to apply configuration..."
    run_cmd "systemctl restart docker"
    
    # Add current user to docker group (if not root)
    if [ "$EUID" -ne 0 ]; then
        print_info "Adding current user to docker group..."
        run_cmd "usermod -aG docker $USER"
        print_warning "Please logout and login again to apply group changes"
        print_info "Or run: newgrp docker"
    fi
    
    # Verify installation
    print_info "Verifying Docker installation..."
    if docker --version && docker info >/dev/null 2>&1; then
        print_success "Docker installation completed successfully"
        docker --version
        return 0
    else
        print_error "Docker installation verification failed"
        return 1
    fi
}

# Uninstall Docker and clean up
uninstall_docker() {
    print_warning "Uninstalling Docker and all containers/images..."
    
    # Confirm operation
    read -p "This will remove all Docker containers, images, and data. Continue? (y/N): " confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        print_info "Docker uninstall cancelled"
        return 0
    fi
    
    # Stop all containers
    print_info "Stopping all Docker containers..."
    if command -v docker >/dev/null 2>&1; then
        docker ps -aq | xargs -r docker stop 2>/dev/null || true
        docker ps -aq | xargs -r docker rm 2>/dev/null || true
        
        # Remove all images
        print_info "Removing all Docker images..."
        docker images -aq | xargs -r docker rmi -f 2>/dev/null || true
        
        # Remove all volumes
        print_info "Removing all Docker volumes..."
        docker volume ls -q | xargs -r docker volume rm 2>/dev/null || true
        
        # Remove all networks (except default ones)
        print_info "Removing Docker networks..."
        docker network ls --format "{{.Name}}" | grep -v -E '^(bridge|host|none)$' | xargs -r docker network rm 2>/dev/null || true
    fi
    
    # Stop Docker service
    print_info "Stopping Docker service..."
    run_cmd "systemctl stop docker" || true
    run_cmd "systemctl disable docker" || true
    
    # Remove Docker packages
    print_info "Removing Docker packages..."
    run_cmd "dnf remove -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin"
    
    # Remove Docker data directory
    print_info "Removing Docker data directory..."
    run_cmd "rm -rf /var/lib/docker"
    run_cmd "rm -rf /var/lib/containerd"
    
    # Remove Docker configuration
    print_info "Removing Docker configuration..."
    run_cmd "rm -rf /etc/docker"
    
    # Remove repository configuration
    print_info "Removing Docker repository configuration..."
    run_cmd "rm -f /etc/yum.repos.d/docker-ce.repo"
    
    print_success "Docker uninstalled successfully"
}

# Check Docker availability and status
check_docker_availability() {
    print_info "Checking Docker availability..."
    
    # Check if Docker is installed
    if ! command -v docker >/dev/null 2>&1; then
        print_error "Docker is not installed"
        print_info "Run: $0 --install --docker"
        return 1
    fi
    
    # Check if Docker daemon is running
    if ! docker info >/dev/null 2>&1; then
        print_error "Docker daemon is not running or accessible"
        print_info "Try: sudo systemctl start docker"
        print_info "Or add your user to docker group: sudo usermod -aG docker $USER"
        return 1
    fi
    
    # Check Docker version
    local docker_version=$(docker --version 2>/dev/null)
    print_success "Docker is available: $docker_version"
    
    # Check if user has permission to use Docker
    if ! docker ps >/dev/null 2>&1; then
        print_warning "Docker command requires elevated permissions"
        print_info "Consider adding user to docker group: sudo usermod -aG docker $USER"
        return 2  # Warning but not failure
    fi
    
    return 0
}

# Setup Docker environment for documentation builds
setup_docker() {
    local build_type="$1"
    
    # Check Docker availability first
    local docker_check_result
    check_docker_availability
    docker_check_result=$?
    
    if [ $docker_check_result -eq 1 ]; then
        return 1
    elif [ $docker_check_result -eq 2 ]; then
        print_warning "Continuing with elevated permissions requirement..."
    fi
    
    print_info "Setting up Docker environment for documentation builds..."
    
    # Ensure we're in the app directory
    cd "$APP_DIR"
    
    # Setup configuration
    setup_mkdocs_config "$build_type" "$APP_DIR"
    
    # Pull Rocky Linux 10 base image
    print_info "Pulling Rocky Linux 10 base image..."
    run_cmd "docker pull rockylinux:10"
    
    # Build documentation container image
    print_info "Building documentation container image..."
    
    # Create temporary Dockerfile
    cat > Dockerfile.rockydocs << 'EOF'
FROM rockylinux:10

# Install development tools and Python
RUN dnf update -y && \
    dnf groupinstall -y "Development Tools" && \
    dnf install -y python3 python3-pip git curl && \
    dnf clean all

# Create documentation user
RUN useradd -m -u 1000 rockydocs && \
    mkdir -p /app /workspace && \
    chown -R rockydocs:rockydocs /app /workspace

# Switch to documentation user
USER rockydocs

# Install Python dependencies
RUN python3 -m pip install --user mkdocs mkdocs-material mike

# Configure git for timestamp preservation
RUN git config --global user.name "Rocky Linux Documentation" && \
    git config --global user.email "noreply@rockylinux.org"

# Set working directory
WORKDIR /app

# Expose documentation server port
EXPOSE 8000

# Default command
CMD ["python3", "-m", "http.server", "8000"]
EOF
    
    # Build the image
    run_cmd "docker build -f Dockerfile.rockydocs -t rockydocs:rl10 ."
    
    # Clean up temporary Dockerfile
    rm -f Dockerfile.rockydocs
    
    print_success "Docker environment setup completed"
    print_info "Container image: rockydocs:rl10"
    print_info "Build type: $build_type"
}

# Deploy documentation in Docker container
deploy_docker() {
    local build_type="$1"
    
    # Check Docker availability
    if ! check_docker_availability; then
        return 1
    fi
    
    print_info "Deploying documentation in Docker container..."
    
    # Ensure we're in the app directory
    cd "$APP_DIR"
    
    # Setup cached repositories for git history
    setup_cached_repos
    
    # Container name
    local container_name="rockydocs-rl10-docs"
    
    # Stop and remove existing container if it exists
    if docker ps -a --format "{{.Names}}" | grep -q "^$container_name$"; then
        print_info "Stopping existing container..."
        docker stop "$container_name" >/dev/null 2>&1 || true
        docker rm "$container_name" >/dev/null 2>&1 || true
    fi
    
    # Create container with bind mounts
    print_info "Creating documentation container..."
    run_cmd "docker run -d \
        --name '$container_name' \
        --memory=2g \
        --cpus='2.0' \
        --pids-limit=1000 \
        -v '$APP_DIR:/app:rw' \
        -v '$APP_DIR/worktrees:/workspace:rw' \
        -p 8000:8000 \
        -p 8001:8001 \
        -p 8002:8002 \
        rockydocs:rl10 \
        sleep infinity"
    
    # Store container name for cleanup
    echo "$container_name" > "$APP_DIR/.docker-container"
    add_cleanup_resource "container:$container_name"
    
    # Wait for container to be ready
    sleep 2
    
    # Deploy documentation inside container
    print_info "Building documentation inside container..."
    
    # Create deployment script
    cat > deploy_script.sh << 'EOF'
#!/bin/bash
set -e

echo "📦 Docker container deployment starting..."

# Add Python user bin to PATH
export PATH="/home/rockydocs/.local/bin:$PATH"

# Change to app directory
cd /app

# Copy mkdocs configuration
echo "📋 Using mkdocs configuration..."
ls -la mkdocs.yml

# Deploy Rocky Linux versions
echo "🚀 Deploying Rocky Linux versions..."

# Deploy version 8
if [ -d "/workspace/rocky-8" ]; then
    echo "📝 Deploying Rocky Linux 8..."
    ln -sf /workspace/rocky-8/docs content
    mike deploy 8 -t "Rocky Linux 8" --push
else
    echo "⚠️  Rocky Linux 8 content not found"
fi

# Deploy version 9  
if [ -d "/workspace/rocky-9" ]; then
    echo "📝 Deploying Rocky Linux 9..."
    ln -sf /workspace/rocky-9/docs content
    mike deploy 9 -t "Rocky Linux 9" --push
else
    echo "⚠️  Rocky Linux 9 content not found"
fi

# Deploy version 10 (latest)
if [ -d "/workspace/main" ]; then
    echo "📝 Deploying Rocky Linux 10 (latest)..."
    ln -sf /workspace/main/docs content
    mike deploy 10 latest -t "Rocky Linux 10" --push --update-aliases
else
    echo "❌ Rocky Linux 10 content not found"
    exit 1
fi

# Set default version
mike set-default latest --push

echo "✅ Docker deployment completed successfully"
EOF
    
    # Make script executable and run it in container
    chmod +x deploy_script.sh
    docker cp deploy_script.sh "$container_name:/tmp/"
    
    if docker exec "$container_name" bash /tmp/deploy_script.sh; then
        print_success "Docker deployment completed successfully"
        
        # Clean up
        rm -f deploy_script.sh
        
        return 0
    else
        print_error "Docker deployment failed"
        rm -f deploy_script.sh
        return 1
    fi
}

# Serve documentation from Docker container
serve_docker() {
    local serve_mode="$1"
    local port="${2:-8000}"
    
    # Check Docker availability
    if ! check_docker_availability; then
        return 1
    fi
    
    print_info "Starting documentation server in Docker container..."
    
    # Ensure we're in the app directory
    cd "$APP_DIR"
    
    # Get container name
    local container_name="rockydocs-rl10-docs"
    
    # Check if container exists and is running
    if ! docker ps --format "{{.Names}}" | grep -q "^$container_name$"; then
        print_error "Container $container_name is not running"
        print_info "Please run deployment first: $0 --deploy --docker"
        return 1
    fi
    
    # Create server tracking file
    mkdir -p "$APP_DIR"
    
    if [ "$serve_mode" = "static" ]; then
        print_info "Starting static documentation server in container..."
        
        # Start static file server in container
        docker exec -d "$container_name" bash -c "
            cd /app
            if [ -d 'site' ]; then
                echo 'Starting static server from site directory...'
                cd site
                python3 -m http.server $port
            else
                echo 'No site directory found. Please run deployment first.'
                exit 1
            fi
        "
        
        # Get container process PID for tracking
        local container_pid=$(docker inspect --format='{{.State.Pid}}' "$container_name")
        echo "$container_pid:$container_name:static" >> "$APP_DIR/.docker-servers"
        
    else
        print_info "Starting live documentation server in container..."
        
        # Start mike serve in container
        docker exec -d "$container_name" bash -c "
            cd /app
            export PATH='/home/rockydocs/.local/bin:\$PATH'
            echo 'Starting mike serve...'
            mike serve --dev-addr 0.0.0.0:$port
        "
        
        # Get container process PID for tracking
        local container_pid=$(docker inspect --format='{{.State.Pid}}' "$container_name")
        echo "$container_pid:$container_name:live" >> "$APP_DIR/.docker-servers"
    fi
    
    # Wait a moment for server to start
    sleep 3
    
    # Check if server is responding
    local attempts=0
    local max_attempts=12
    while [ $attempts -lt $max_attempts ]; do
        if curl -s -f "http://localhost:$port/" >/dev/null 2>&1; then
            print_success "Documentation server started successfully"
            print_info "Server URL: http://localhost:$port/"
            print_info "Container: $container_name"
            print_info "Mode: $serve_mode"
            
            if [ "$serve_mode" = "static" ]; then
                print_info "Static files served from container"
            else
                print_info "Live development server with auto-reload"
            fi
            
            return 0
        fi
        sleep 5
        attempts=$((attempts + 1))
    done
    
    print_error "Documentation server failed to start or is not responding"
    return 1
}

# Stop Docker services and clean up containers
stop_docker_services() {
    print_info "Stopping Docker documentation services..."
    
    # Stop container servers
    if [ -f "$APP_DIR/.docker-servers" ]; then
        while IFS=':' read -r pid container_name mode; do
            if [ -n "$pid" ] && [ -n "$container_name" ]; then
                print_info "Stopping $mode server in container $container_name"
                docker exec "$container_name" pkill -f "python3 -m http.server" 2>/dev/null || true
                docker exec "$container_name" pkill -f "mike serve" 2>/dev/null || true
            fi
        done < "$APP_DIR/.docker-servers"
        rm -f "$APP_DIR/.docker-servers"
    fi
    
    # Stop container
    if [ -f "$APP_DIR/.docker-container" ]; then
        local container_name=$(cat "$APP_DIR/.docker-container")
        if docker ps --format "{{.Names}}" | grep -q "^$container_name$"; then
            print_info "Stopping container $container_name"
            docker stop "$container_name" >/dev/null 2>&1
        fi
    fi
    
    print_success "Docker services stopped"
}

# Utility function to stop Docker container
stop_docker_container() {
    local container_name="$1"
    if docker ps --format "{{.Names}}" | grep -q "^$container_name$"; then
        docker stop "$container_name" >/dev/null 2>&1 || true
    fi
    if docker ps -a --format "{{.Names}}" | grep -q "^$container_name$"; then
        docker rm "$container_name" >/dev/null 2>&1 || true
    fi
}

# === SERVING FUNCTIONS ===

# Setup git worktrees for efficient multi-version deployment
setup_cached_repos() {
    local worktree_base="$APP_DIR/worktrees"
    local repo_url="https://github.com/rocky-linux/documentation.git"
    
    print_info "Setting up git worktrees for efficient deployment..."
    
    # Create worktree base directory if it doesn't exist
    if [ ! -d "$worktree_base" ]; then
        run_cmd "mkdir -p $worktree_base"
    fi
    
    # Check if we have the main repository
    if [ -d "$worktree_base/main/.git" ]; then
        print_info "Found existing worktree setup, using cached repositories..."
        cd "$worktree_base/main"
        cd "$APP_DIR"
    else
        # Clone main repository if we don't have it
        print_info "Creating main repository for git worktrees (one-time setup)..."
        cd "$worktree_base"
        
        # Use --reference optimization if user's content repo exists and has .git
        if [ -d "$CONTENT_DIR/.git" ]; then
            print_info "Optimizing clone using local repository reference (saves bandwidth)..."
            run_cmd "git clone --reference $CONTENT_DIR $repo_url main"
        else
            run_cmd "git clone $repo_url main"
        fi
        
        cd main
        # Fetch all branches we need
        run_cmd "git fetch origin rocky-8:rocky-8 rocky-9:rocky-9" 2>/dev/null || true
        cd "$APP_DIR"
    fi
    
    # Create worktrees for each version if they don't exist
    cd "$worktree_base/main"
    
    # Rocky Linux 8 worktree
    if [ ! -d "$worktree_base/rocky-8" ]; then
        print_info "Creating Rocky Linux 8 worktree..."
        run_cmd "git worktree add ../rocky-8 rocky-8"
        add_cleanup_resource "worktree:$worktree_base/rocky-8"
    fi
    
    # Rocky Linux 9 worktree  
    if [ ! -d "$worktree_base/rocky-9" ]; then
        print_info "Creating Rocky Linux 9 worktree..."
        run_cmd "git worktree add ../rocky-9 rocky-9"
        add_cleanup_resource "worktree:$worktree_base/rocky-9"
    fi
    
    cd "$APP_DIR"
    print_success "Git worktrees ready for efficient deployment"
}

# Deploy specific version locally
deploy_version_local() {
    local version=$1
    local branch=$2
    local alias=$3
    local title=$4
    local worktree_base="$APP_DIR/worktrees"
    local current_version=$(detect_version)
    
    print_info "Deploying Rocky Linux $version (optimized)..."
    
    if [ "$version" = "$current_version" ]; then
        # Deploy current branch content (your edits)
        print_info "Using your current content for Rocky Linux $version"
        
        # Ensure content symlink points to current docs (clean user docs first to avoid loops)
        run_cmd "rm -f $CONTENT_DIR/docs/content"  # Remove any stale content symlinks from user docs
        manage_content_symlink "create" "$CONTENT_DIR/docs" "content"
        
        if [ -n "$alias" ]; then
            run_cmd_with_rollback "source venv/bin/activate && mike deploy $version $alias --title '$title'" "" "Build had warnings for Rocky Linux $version but continuing with deployment" || {
                print_warning "Build had warnings for Rocky Linux $version but continuing with deployment"
            }
        else
            run_cmd_with_rollback "source venv/bin/activate && mike deploy $version --title '$title'" "" "Build had warnings for Rocky Linux $version but continuing with deployment" || {
                print_warning "Build had warnings for Rocky Linux $version but continuing with deployment"
            }
        fi
    else
        # Use git worktrees for efficient deployment
        local worktree_path="$worktree_base/$branch"
        if [ -d "$worktree_path" ]; then
            print_info "Using git worktree for Rocky Linux $version ($branch branch)..."
            
            # Temporarily backup current docs and use worktree content
            manage_content_symlink "backup" "$CONTENT_DIR/docs" "content"
            run_cmd "ln -sf $worktree_path/docs content"
            
            # Deploy this version
            if [ -n "$alias" ]; then
                run_cmd "source venv/bin/activate && mike deploy $version $alias --title '$title'"
            else
                run_cmd "source venv/bin/activate && mike deploy $version --title '$title'"
            fi
            
            # Restore current docs
            manage_content_symlink "restore" "$CONTENT_DIR/docs" "content"
            
            print_success "Rocky Linux $version deployed successfully (worktree)"
        else
            print_warning "No worktree found for $branch branch - skipping Rocky Linux $version"
            print_info "Run setup again to create git worktrees"
        fi
    fi
}

# Deploy all Rocky Linux versions
deploy_all_versions() {
    local current_version="$1"
    
    # Initialize git repo for mike if not exists
    if [ ! -d ".git" ]; then
        print_info "Initializing git repository for mike versioning..."
        run_cmd "git init"
        run_cmd "git config user.name 'Local Dev'"
        run_cmd "git config user.email 'dev@local.dev'"
        run_cmd "git add mkdocs.yml"
        run_cmd "git commit -m 'Initial commit for local development'"
    fi
    
    # Deploy all versions like production
    print_info "Building complete multi-version site like production..."
    deploy_version_local "8" "rocky-8" "" "Rocky Linux 8"
    deploy_version_local "9" "rocky-9" "" "Rocky Linux 9"  
    deploy_version_local "10" "main" "latest" "Rocky Linux 10"
    
    # Set default to latest
    print_info "Setting latest version as default for root access..."
    if ! run_cmd "source venv/bin/activate && mike set-default --allow-empty latest"; then
        print_error "Failed to set default version to 'latest'. Aborting."
        return 1
    fi
}

# Live serving mode with mike serve
serve_live() {
    
    print_info "🚀 FAST SERVE MODE: Using existing deployed versions from gh-pages"
    
    # Basic validation
    if [ ! -d "$APP_DIR" ]; then
        print_error "App directory not found: $APP_DIR"
        print_info "Run: $0 --setup --venv --minimal first"
        return 1
    fi
    
    if [ ! -d "$APP_DIR/venv" ]; then
        print_error "Virtual environment not found. Run: $0 --setup --venv --minimal"
        return 1
    fi
    
    cd "$APP_DIR"
    
    # Check if mike has been deployed
    if ! git show-ref --verify --quiet refs/heads/gh-pages; then
        print_error "No mike deployment found on gh-pages branch. Run: $0 --deploy first"
        return 1
    fi
    
    # Mike serve still needs a valid mkdocs.yml, but will serve from gh-pages branch
    # We need to ensure there's a valid config file and docs_dir exists
    if [ ! -f "mkdocs.yml" ]; then
        if [ -f "configs/mkdocs.minimal.yml" ]; then
            run_cmd "cp configs/mkdocs.minimal.yml mkdocs.yml"
            print_info "Created minimal mkdocs.yml for mike serve"
        else
            print_error "No mkdocs config files found"
            return 1
        fi
    fi
    
    # Ensure the docs_dir referenced in mkdocs.yml exists (mike serve requires it)
    local docs_dir=$(grep "^docs_dir:" mkdocs.yml | cut -d'"' -f2 2>/dev/null || echo "content")
    if [ ! -d "$docs_dir" ]; then
        run_cmd "mkdir -p $docs_dir"
        print_info "Created placeholder $docs_dir directory for mike serve"
    fi
    
    # Find available port with fallback
    local port=$(find_available_port 8000 8001 8002)
    if [ -z "$port" ]; then
        print_error "No available ports (8000, 8001, 8002). Kill existing processes or use different ports."
        return 1
    fi
    
    print_success "🚀 Starting FAST server on port $port"
    print_info "   • Serving pre-built content from gh-pages branch"
    print_info "   • Version selector available"
    print_info "   • No rebuilding - content already deployed"
    print_info "   • Port fallback: 8000 → 8001 → 8002"
    print_info ""
    print_info "Access: http://localhost:$port"
    print_info ""
    
    # Mike serve reads directly from gh-pages branch, no content symlink needed
    print_command "source venv/bin/activate && mike serve -a localhost:$port"
    bash -c "cd $APP_DIR && source venv/bin/activate && mike serve -a localhost:$port"
}

# Extract static site like Vercel
extract_static_site() {
    if ! git show-ref --verify --quiet refs/heads/gh-pages; then
        print_error "No gh-pages branch found - mike deployment may have failed"
        return 1
    fi
    
    print_info "Extracting static site from gh-pages branch (like Vercel)..."
    
    # Clean and create site-static directory
    run_cmd "rm -rf site-static"
    run_cmd "mkdir -p site-static"
    add_cleanup_resource "dir:$PWD/site-static"
    
    # Extract static files from gh-pages using checkout instead of archive to preserve symlinks
    print_info "Using git checkout to preserve symlinks..."
    local current_branch=$(git rev-parse --abbrev-ref HEAD)
    
    # Stash any uncommitted changes
    git stash push -m "Temporary stash for static extraction" >/dev/null 2>&1 || true
    
    # Checkout gh-pages branch temporarily
    if ! run_cmd "git checkout gh-pages"; then
        print_error "Failed to checkout gh-pages branch"
        return 1
    fi
    
    # Copy all files to site-static directory
    run_cmd "cp -r * site-static/ 2>/dev/null || true"
    run_cmd "cp -r .[^.]* site-static/ 2>/dev/null || true"  # Copy hidden files
    
    # Return to original branch
    run_cmd "git checkout $current_branch"
    
    # Restore any stashed changes
    git stash pop >/dev/null 2>&1 || true
    
    if [ ! -d "site-static" ] || [ "$(ls -A site-static 2>/dev/null | wc -l)" -eq 0 ]; then
        print_error "Static extraction produced no content"
        return 1
    fi
    
    print_success "Static site extracted successfully from gh-pages with symlinks preserved!"
    
    # Apply Vercel-style root deployment
    apply_root_deployment
    return $?
}

# Apply root deployment for backward compatibility
apply_root_deployment() {
    print_info "Applying Vercel-style root deployment..."
    
    # First check if root deployment is already applied
    if [ -f "site-static/index.html" ] && [ ! -d "site-static/latest" ] && [ ! -d "site-static/10" ]; then
        print_info "Root deployment already applied - content is already at web root"
        print_success "Root index.html exists (content already deployed to root)"
        return 0
    fi
    
    # Look for latest content to copy to root (handle symlinks)
    local root_source=""
    
    # Check if latest exists (could be directory or symlink)
    if [ -e "site-static/latest" ]; then
        if [ -L "site-static/latest" ]; then
            # Latest is a symlink, resolve it
            local latest_target=$(readlink "site-static/latest" 2>/dev/null || echo "")
            if [ -n "$latest_target" ] && [ -d "site-static/$latest_target" ]; then
                root_source="site-static/$latest_target"
                print_info "Found latest symlink pointing to $latest_target, using as root source..."
            fi
        elif [ -d "site-static/latest" ]; then
            # Latest is a directory
            root_source="site-static/latest"
            print_info "Found latest directory, using as root source..."
        fi
    fi
    
    # Fallback to version 10 if latest not resolved
    if [ -z "$root_source" ] && [ -d "site-static/10" ]; then
        root_source="site-static/10"
        print_info "Using version 10 directory as root source..."
    fi
    
    if [ -z "$root_source" ]; then
        print_warning "No suitable version directory found for root deployment"
        return 1
    fi
    
    # Backup versions.json if it exists
    if [ -f "site-static/versions.json" ]; then
        run_cmd "cp site-static/versions.json site-static/versions.json.backup"
        print_info "Backed up versions.json"
    fi
    
    # Copy version content to root
    print_info "Copying latest content to root for production behavior..."
    run_cmd "cp -r $root_source/* site-static/ 2>/dev/null || true"
    
    # Restore versions.json to maintain version selector functionality
    if [ -f "site-static/versions.json.backup" ]; then
        run_cmd "cp site-static/versions.json.backup site-static/versions.json"
        run_cmd "rm site-static/versions.json.backup"
        print_info "Restored versions.json for version selector"
    fi
    
    # Verify root content
    if [ -f "site-static/index.html" ]; then
        print_success "Root index.html exists (latest content deployed)"
        
        # Check what URLs will work
        print_info "Verifying URL access patterns..."
        if [ -d "site-static/8" ]; then print_info "  ✅ /8/ → Rocky Linux 8"; fi
        if [ -d "site-static/9" ]; then print_info "  ✅ /9/ → Rocky Linux 9"; fi
        if [ -d "site-static/10" ]; then print_info "  ✅ /10/ → Rocky Linux 10"; fi
        if [ -d "site-static/latest" ]; then print_info "  ✅ /latest/ → Rocky Linux 10"; fi
        print_success "  ✅ / → Rocky Linux 10 (DIRECT ACCESS)"
        
        return 0
    else
        print_error "Root index.html missing after root deployment!"
        return 1
    fi
}

# Main serve function - routes to appropriate serving mode
serve_site() {
    local build_type="$1"  # Ignored for serve modes - they use pre-built content
    local static_mode="$2"
    
    # Route to appropriate serving mode
    if [ "$static_mode" = "true" ]; then
        serve_static
    else
        serve_live
    fi
}

# Dual server function
serve_dual() {
    
    print_info "🚀 DUAL SERVER MODE: Starting mike serve + mkdocs live reload"
    print_info "Setting up dual server environment..."
    
    # Validate basic requirements
    if [ ! -d "$APP_DIR" ]; then
        print_error "App directory not found: $APP_DIR"
        print_info "Run setup first: $0 --setup --minimal"
        return 1
    fi
    
    run_cmd "cd $APP_DIR"
    
    # Validate environment (same as serve_live)
    if [ ! -d "$APP_DIR/venv" ]; then
        print_error "Virtual environment not found. Run: $0 --setup --venv --minimal"
        return 1
    fi
    
    # Check if mike has been deployed - dual server requires mike versioning
    if ! git show-ref --verify --quiet refs/heads/gh-pages; then
        print_error "No mike deployment found on 'gh-pages' branch. Dual server requires mike versioning."
        print_info "Run: $0 --deploy first to create the local mike deployment."
        return 1
    fi
    
    # NOTE: No mkdocs config needed - serve_dual serves pre-built content from gh-pages
    
    # Setup content symlink for current content
    manage_content_symlink "create" "$CONTENT_DIR/docs" "content"
    
    # Activate virtual environment if using it
    if [ ! -f "venv/bin/activate" ]; then
        print_error "Virtual environment not found. Run: $0 --setup --venv first"
        return 1
    fi
    print_info "Activating virtual environment..."
    source venv/bin/activate
    
    # Find available ports with conflict resolution
    local mike_port=$(find_available_port 8000 8010 8020)
    local mkdocs_port=$(find_available_port 8001 8011 8021)
    
    if [ -z "$mike_port" ] || [ -z "$mkdocs_port" ]; then
        print_error "Could not find available ports for dual server mode"
        return 1
    fi
    
    print_success "🔧 DUAL SERVER CONFIGURATION:"
    print_info "  • Mike serve (multi-version): http://localhost:$mike_port"
    print_info "  • MkDocs serve (live reload): http://localhost:$mkdocs_port"
    print_info ""
    print_info "🎯 USE CASES:"
    print_info "  • Port $mike_port: Test multi-version functionality, version selector, and web root."
    print_info "  • Port $mkdocs_port: Active content editing with live reload."
    print_info ""
    
    # Start mike serve in background
    print_info "Starting mike serve in background (port $mike_port)..."
    mike serve -a localhost:$mike_port --config-file mkdocs.yml > /tmp/mike-serve-$$.log 2>&1 &
    local mike_pid=$!
    add_cleanup_resource "pid:$mike_pid"
    add_cleanup_resource "file:/tmp/mike-serve-$$.log"
    
    # Give mike serve time to start
    sleep 2
    
    # Check if mike serve started successfully
    if ! kill -0 $mike_pid 2>/dev/null; then
        print_error "Failed to start mike serve. Check log: /tmp/mike-serve-$$.log"
        return 1
    fi
    
    print_success "✅ Mike serve started successfully (PID: $mike_pid)"
    
    # Start mkdocs serve in foreground with live reload
    print_info "Starting mkdocs serve with live reload (port $mkdocs_port)..."
    print_info "📝 LIVE RELOAD FEATURES:"
    print_info "  • File changes auto-refresh browser"
    print_info "  • Theme changes supported"
    print_info "  • Current content only (not versioned)"
    print_info ""
    print_warning "Press Ctrl+C to stop both servers cleanly"
    print_info ""
    
    # Set up signal handler for clean shutdown
    trap 'print_warning "Stopping dual servers..."; kill $mike_pid 2>/dev/null; exit 0' INT TERM
    
    # Start mkdocs serve in foreground
    mkdocs serve -a localhost:$mkdocs_port --watch-theme --config-file mkdocs.yml
}

# Podman dual server mode - runs two containers for development
serve_dual_podman() {
    
    print_info "🐳 PODMAN DUAL SERVER MODE: Multi-version + live development containers"
    print_info "Setting up dual Podman container environment..."
    
    # Validate Podman setup
    if [ ! -d "$APP_DIR" ]; then
        print_error "App directory not found: $APP_DIR"
        print_info "Run setup first: $0 --setup --podman"
        return 1
    fi
    
    # Check if Podman image exists
    if ! podman image inspect rockydocs-dev >/dev/null 2>&1; then
        print_error "Podman image 'rockydocs-dev' not found"
        print_info "Run setup first: $0 --setup --podman"
        return 1
    fi
    
    cd "$APP_DIR"
    
    # Check if deployment exists for multi-version container
    if ! extract_static_site; then
        print_error "No deployment found for multi-version serving"
        print_info "Run deployment first: $0 --deploy --podman"
        return 1
    fi
    
    # Stop any existing dual containers
    local mike_container_name=$(get_docker_container_name "dual-mike")
    local mkdocs_container_name=$(get_docker_container_name "dual-mkdocs")
    
    stop_docker_container "$mike_container_name"
    stop_docker_container "$mkdocs_container_name"
    
    # Find available ports for both containers
    local mike_port=$(find_available_port 8000 8010 8020)
    local mkdocs_port=$(find_available_port 8001 8011 8021)
    
    if [ -z "$mike_port" ] || [ -z "$mkdocs_port" ]; then
        print_error "Could not find available ports for dual server mode"
        return 1
    fi
    
    print_success "🔧 PODMAN DUAL CONTAINER CONFIGURATION:"
    print_info "  • Multi-version (static): http://localhost:$mike_port"
    print_info "  • Live development: http://localhost:$mkdocs_port"
    print_info ""
    print_info "🎯 USE CASES:"
    print_info "  • Port $mike_port: Test multi-version functionality, version selector, production-like"
    print_info "  • Port $mkdocs_port: Active content editing with live reload"
    print_info ""
    
    # Start multi-version static server container (like production)
    print_info "Starting multi-version static server container (port $mike_port)..."
    podman run -d --name "$mike_container_name" \
        -p "$mike_port:8000" \
        -v "$APP_DIR:/app" \
        --workdir /app \
        rockydocs-dev \
        python3 -m http.server 8000 --bind 0.0.0.0 -d /app/site-static
    
    # Add container to cleanup
    add_cleanup_resource "container:$mike_container_name"
    
    # Give static server time to start
    sleep 2
    
    # Check if static server started successfully
    if ! podman container exists "$mike_container_name" || [ "$(podman container inspect "$mike_container_name" --format '{{.State.Status}}')" != "running" ]; then
        print_error "Failed to start multi-version static server container"
        return 1
    fi
    
    print_success "✅ Multi-version static server started successfully"
    
    # Start live development container
    print_info "Starting live development server container (port $mkdocs_port)..."
    print_info "📝 LIVE RELOAD FEATURES:"
    print_info "  • File changes auto-refresh browser"
    print_info "  • Theme changes supported"
    print_info "  • Current content only (not versioned)"
    print_info ""
    print_warning "Press Ctrl+C to stop both containers cleanly"
    print_info ""
    
    # Start mkdocs live development server container in foreground
    podman run --name "$mkdocs_container_name" \
        -p "$mkdocs_port:8000" \
        -v "$APP_DIR:/app" \
        -v "$CONTENT_DIR/docs:/app/content" \
        --workdir /app \
        rockydocs-dev \
        bash -c "source venv/bin/activate && mkdocs serve -a 0.0.0.0:8000 --watch-theme"
}

# Docker dual server mode - similar to Podman but using Docker
serve_dual_docker() {
    
    print_info "🐳 DOCKER DUAL SERVER MODE: Multi-version + live development containers"
    print_info "Setting up dual Docker container environment..."
    
    # Validate Docker setup
    if [ ! -d "$APP_DIR" ]; then
        print_error "App directory not found: $APP_DIR"
        print_info "Run setup first: $0 --setup --docker"
        return 1
    fi
    
    # Check if Docker image exists
    if ! docker image inspect rockydocs-dev >/dev/null 2>&1; then
        print_error "Docker image 'rockydocs-dev' not found"
        print_info "Run setup first: $0 --setup --docker"
        return 1
    fi
    
    cd "$APP_DIR"
    
    # Check if deployment exists for multi-version container
    if ! extract_static_site; then
        print_error "No deployment found for multi-version serving"
        print_info "Run deployment first: $0 --deploy --docker"
        return 1
    fi
    
    # Stop any existing dual containers
    local mike_container_name=$(get_docker_container_name "dual-mike")
    local mkdocs_container_name=$(get_docker_container_name "dual-mkdocs")
    
    stop_docker_container "$mike_container_name"
    stop_docker_container "$mkdocs_container_name"
    
    # Find available ports for both containers
    local mike_port=$(find_available_port 8000 8010 8020)
    local mkdocs_port=$(find_available_port 8001 8011 8021)
    
    if [ -z "$mike_port" ] || [ -z "$mkdocs_port" ]; then
        print_error "Could not find available ports for dual server mode"
        return 1
    fi
    
    print_success "🔧 DOCKER DUAL CONTAINER CONFIGURATION:"
    print_info "  • Multi-version (static): http://localhost:$mike_port"
    print_info "  • Live development: http://localhost:$mkdocs_port"
    print_info ""
    print_info "🎯 USE CASES:"
    print_info "  • Port $mike_port: Test multi-version functionality, version selector, production-like"
    print_info "  • Port $mkdocs_port: Active content editing with live reload"
    print_info ""
    
    # Start multi-version static server container (like production)
    print_info "Starting multi-version static server container (port $mike_port)..."
    docker run -d --name "$mike_container_name" \
        -p "$mike_port:8000" \
        -v "$APP_DIR:/app" \
        --workdir /app \
        rockydocs-dev \
        python3 -m http.server 8000 --bind 0.0.0.0 -d /app/site-static
    
    # Add container to cleanup
    add_cleanup_resource "container:$mike_container_name"
    
    # Give static server time to start
    sleep 2
    
    # Check if static server started successfully
    if ! docker container inspect "$mike_container_name" >/dev/null 2>&1 || [ "$(docker container inspect "$mike_container_name" --format '{{.State.Status}}')" != "running" ]; then
        print_error "Failed to start multi-version static server container"
        return 1
    fi
    
    print_success "✅ Multi-version static server started successfully"
    
    # Start live development container
    print_info "Starting live development server container (port $mkdocs_port)..."
    print_info "📝 LIVE RELOAD FEATURES:"
    print_info "  • File changes auto-refresh browser"
    print_info "  • Theme changes supported"
    print_info "  • Current content only (not versioned)"
    print_info ""
    print_warning "Press Ctrl+C to stop both containers cleanly"
    print_info ""
    
    # Start mkdocs live development server container in foreground
    docker run --name "$mkdocs_container_name" \
        -p "$mkdocs_port:8000" \
        -v "$APP_DIR:/app" \
        -v "$CONTENT_DIR/docs:/app/content" \
        --workdir /app \
        rockydocs-dev \
        bash -c "source venv/bin/activate && mkdocs serve -a 0.0.0.0:8000 --watch-theme"
}

# Deploy site function
deploy_site() {
    local current_version=$(detect_version)
    
    print_info "🚀 DEPLOY MODE: Building and deploying ALL Rocky Linux versions locally"
    print_info "This creates the complete versioned site that --serve uses"
    print_info "Current branch: Rocky Linux $current_version (your edits will be in this version)"
    
    if [ ! -d "$APP_DIR/venv" ]; then
        print_error "Environment not setup. Run: $0 --setup --venv first"
        return 1
    fi
    
    run_cmd "cd $APP_DIR"

    # Delete existing gh-pages branch for a clean LOCAL deployment
    if git show-ref --verify --quiet refs/heads/gh-pages; then
        print_info "Deleting existing local gh-pages branch for a clean deployment..."
        run_cmd "git branch -D gh-pages"
    fi
    
    # Use existing mkdocs.yml config set during setup - no need to reconfigure
    
    # Setup repository caching and deploy all versions
    print_info "Setting up cached repositories and deploying versions..."
    setup_cached_repos
    deploy_all_versions "$current_version"
    
    # Apply the web root override directly to the local gh-pages branch
    apply_web_root_override_local
    
    print_success "🎉 Local deploy complete! All versions are ready for '--serve'."
    print_info "Available versions: Rocky Linux 8, 9, 10 (latest)"
    print_info ""
    print_info "Next steps:"
    print_info "  • Use: $0 --serve --minimal      # Fast serve (no rebuild)"
    print_info "  • Use: $0 --serve --static       # Static production-like serve"
    print_info ""
    print_info "Deployed versions ready for fast serving with mike!"
}

# Docker deployment function
deploy_docker() {
    local current_version=$(detect_version)
    
    print_info "🐳 DOCKER DEPLOY MODE: Container-based multi-version deployment"
    print_info "Building and deploying ALL Rocky Linux versions using Docker containers"
    print_info "Current branch: Rocky Linux $current_version (your edits will be in this version)"
    
    # Validate Docker setup
    if [ ! -d "$APP_DIR" ]; then
        print_error "App directory not found: $APP_DIR"
        print_info "Run setup first: $0 --setup --docker"
        return 1
    fi
    
    # Check if Docker image exists
    if ! docker image inspect rockydocs-dev >/dev/null 2>&1; then
        print_error "Docker image 'rockydocs-dev' not found"
        print_info "Run setup first: $0 --setup --docker"
        return 1
    fi
    
    cd "$APP_DIR"
    
    # Use existing mkdocs.yml config set during setup - no need to reconfigure
    print_info "Using existing mkdocs configuration from setup..."
    
    # Get container name for deployment
    local container_name=$(get_docker_container_name "deploy")
    stop_docker_container "$container_name"
    
    print_info "Setting up cached repositories..."
    setup_cached_repos
    
    print_success "🚀 Starting Docker deployment container..."
    
    # Create deployment script inside container
    local deploy_script="/tmp/deploy_all_versions.sh"
    cat > "$deploy_script" << 'EOF'
#!/bin/bash
set -e

current_version="$1"
echo "🐳 Container deployment starting..."
echo "Current version: $current_version"

# Configure git user for timestamp preservation
git config --global user.name "Rocky Linux Documentation Bot"
git config --global user.email "noreply@rockylinux.org"

# No virtual environment needed in Docker - packages installed globally

# Deploy Rocky Linux 8
if [ -d "worktrees/rocky-8" ]; then
    echo "📦 Deploying Rocky Linux 8..."
    rm -rf content && ln -sf worktrees/rocky-8/docs content
    mike deploy 8 --config-file mkdocs.yml || echo "Warning: Rocky 8 deployment had issues"
fi

# Deploy Rocky Linux 9
if [ -d "worktrees/rocky-9" ]; then
    echo "📦 Deploying Rocky Linux 9..."
    rm -rf content && ln -sf worktrees/rocky-9/docs content
    mike deploy 9 --config-file mkdocs.yml || echo "Warning: Rocky 9 deployment had issues"
fi

# Deploy Rocky Linux 10 (current content with git history)
echo "📦 Deploying Rocky Linux 10 (current)..."
if [ -d "worktrees/main" ]; then
    echo "Using worktree main for Rocky Linux 10 (with git history)..."
    rm -rf content && ln -sf worktrees/main/docs content
else
    echo "Fallback: Using current content directory..."
    rm -rf content && ln -sf /app/content-current content
fi
mike deploy 10 latest --config-file mkdocs.yml
mike set-default latest --config-file mkdocs.yml

echo "✅ Container deployment completed successfully!"
mike list --config-file mkdocs.yml || true
EOF
    chmod +x "$deploy_script"
    
    # Run deployment in container
    print_info "Running deployment inside Docker container..."
    docker run --rm --name "$container_name" \
        -v "$APP_DIR:/app" \
        -v "$CONTENT_DIR/docs:/app/content-current" \
        -v "$deploy_script:$deploy_script" \
        --workdir /app \
        rockydocs-dev \
        bash "$deploy_script" "$current_version"
    
    # Clean up temporary script
    rm -f "$deploy_script"
    
    # Apply web root override (same as venv version)
    print_info "Applying web root override for production-like behavior..."
    apply_web_root_override_local
    
    print_success "🎉 Docker deployment complete! All versions are ready for '--serve'."
    print_info "Available versions: Rocky Linux 8, 9, 10 (latest)"
    print_info ""
    print_info "Next steps:"
    print_info "  • Use: $0 --serve --docker         # Docker-based serving"
    print_info "  • Use: $0 --serve --docker --static # Static production-like serve"
    print_info ""
    print_info "Deployed versions ready for Docker serving!"
}

# Podman deployment function
deploy_podman() {
    local current_version=$(detect_version)
    
    print_info "📦 PODMAN DEPLOY MODE: Container-based multi-version deployment"
    print_info "Building and deploying ALL Rocky Linux versions using Podman containers"
    print_info "Current branch: Rocky Linux $current_version (your edits will be in this version)"
    
    # Validate Podman setup
    if [ ! -d "$APP_DIR" ]; then
        print_error "App directory not found: $APP_DIR"
        print_info "Run setup first: $0 --setup --podman"
        return 1
    fi
    
    # Check if Podman image exists
    if ! podman image inspect rockydocs-dev >/dev/null 2>&1; then
        print_error "Podman image 'rockydocs-dev' not found"
        print_info "Run setup first: $0 --setup --podman"
        return 1
    fi
    
    cd "$APP_DIR"
    
    # Use existing mkdocs.yml config set during setup - no need to reconfigure
    print_info "Using existing mkdocs configuration from setup..."
    
    # Get container name for deployment
    local container_name=$(get_podman_container_name "deploy")
    stop_podman_container "$container_name"
    
    print_info "Setting up cached repositories..."
    setup_cached_repos
    
    print_success "🚀 Starting Podman deployment container..."
    
    # Create deployment script inside container
    local deploy_script="/tmp/deploy_all_versions.sh"
    cat > "$deploy_script" << 'EOF'
#!/bin/bash
set -e

current_version="$1"
echo "📦 Container deployment starting..."
echo "Current version: $current_version"

# Configure git user for timestamp preservation
git config --global user.name "Rocky Linux Documentation Bot"
git config --global user.email "noreply@rockylinux.org"

# No virtual environment needed in Podman - packages installed globally

# Deploy Rocky Linux 8
if [ -d "worktrees/rocky-8" ]; then
    echo "📦 Deploying Rocky Linux 8..."
    rm -rf content && ln -sf worktrees/rocky-8/docs content
    mike deploy 8 --config-file mkdocs.yml || echo "Warning: Rocky 8 deployment had issues"
fi

# Deploy Rocky Linux 9
if [ -d "worktrees/rocky-9" ]; then
    echo "📦 Deploying Rocky Linux 9..."
    rm -rf content && ln -sf worktrees/rocky-9/docs content
    mike deploy 9 --config-file mkdocs.yml || echo "Warning: Rocky 9 deployment had issues"
fi

# Deploy Rocky Linux 10 (current content with git history)
echo "📦 Deploying Rocky Linux 10 (current)..."
if [ -d "worktrees/main" ]; then
    echo "Using worktree main for Rocky Linux 10 (with git history)..."
    rm -rf content && ln -sf worktrees/main/docs content
else
    echo "Fallback: Using current content directory..."
    rm -rf content && ln -sf /app/content-current content
fi
mike deploy 10 latest --config-file mkdocs.yml
mike set-default latest --config-file mkdocs.yml

echo "✅ Container deployment completed successfully!"
mike list --config-file mkdocs.yml || true
EOF
    chmod +x "$deploy_script"
    
    # Run deployment in container with proper user mapping and permissions
    print_info "Running deployment inside Podman container..."
    
    # Use user namespace mapping to fix permission issues
    local container_uid=$(id -u)
    local container_gid=$(id -g)
    
    podman run --rm --name "$container_name" \
        --userns=keep-id \
        --security-opt label=disable \
        -v "$APP_DIR:/app:Z" \
        -v "$CONTENT_DIR/docs:/app/content-current:Z" \
        --workdir /app \
        rockydocs-dev \
        bash -c "
current_version='$current_version'
echo '📦 Container deployment starting...'
echo \"Current version: \$current_version\"

# Configure git user for timestamp preservation
git config --global user.name 'Rocky Linux Documentation Bot'
git config --global user.email 'noreply@rockylinux.org'

# Initialize git repository if needed
if [ ! -d '.git' ]; then
    echo 'Initializing git repository for mike versioning...'
    git init
    git add mkdocs.yml
    git commit -m 'Initial commit for local development'
fi

# No virtual environment needed in Podman - packages installed globally

# Deploy Rocky Linux 8
if [ -d 'worktrees/rocky-8' ]; then
    echo '📦 Deploying Rocky Linux 8...'
    rm -rf content 2>/dev/null || true
    ln -sf worktrees/rocky-8/docs content
    mike deploy 8 --config-file mkdocs.yml || echo 'Warning: Rocky 8 deployment had issues'
fi

# Deploy Rocky Linux 9
if [ -d 'worktrees/rocky-9' ]; then
    echo '📦 Deploying Rocky Linux 9...'
    rm -rf content 2>/dev/null || true
    ln -sf worktrees/rocky-9/docs content
    mike deploy 9 --config-file mkdocs.yml || echo 'Warning: Rocky 9 deployment had issues'
fi

# Deploy Rocky Linux 10 (current content with git history)
echo '📦 Deploying Rocky Linux 10 (current)...'
if [ -d 'worktrees/main' ]; then
    echo 'Using worktree main for Rocky Linux 10 (with git history)...'
    rm -rf content 2>/dev/null || true
    ln -sf worktrees/main/docs content
else
    echo 'Fallback: Using current content directory...'
    rm -rf content 2>/dev/null || true
    ln -sf /app/content-current content
fi
mike deploy 10 latest --config-file mkdocs.yml
mike set-default latest --config-file mkdocs.yml

echo '✅ Container deployment completed successfully!'
mike list --config-file mkdocs.yml || true
"
    
    # Clean up temporary script
    rm -f "$deploy_script"
    
    # Apply web root override (same as venv version)
    print_info "Applying web root override for production-like behavior..."
    apply_web_root_override_local
    
    print_success "🎉 Podman deployment complete! All versions are ready for '--serve'."
    print_info "Available versions: Rocky Linux 8, 9, 10 (latest)"
    print_info ""
    print_info "Next steps:"
    print_info "  • Use: $0 --serve --podman         # Podman-based serving"
    print_info "  • Use: $0 --serve --podman --static # Static production-like serve"
    print_info ""
    print_info "Deployed versions ready for Podman serving!"
}

# Podman serving function
serve_podman() {
    local static_mode="$1"
    
    print_info "📦 PODMAN SERVING MODE: Container-based documentation serving"
    
    # Validate Podman setup
    if [ ! -d "$APP_DIR" ]; then
        print_error "App directory not found: $APP_DIR"
        print_info "Run setup first: $0 --setup --podman"
        return 1
    fi
    
    # Check if Podman image exists
    if ! podman image inspect rockydocs-dev >/dev/null 2>&1; then
        print_error "Podman image 'rockydocs-dev' not found"
        print_info "Run setup first: $0 --setup --podman"
        return 1
    fi
    
    cd "$APP_DIR"
    
    # Get container name and manage lifecycle
    local container_name=$(get_podman_container_name "serve")
    stop_podman_container "$container_name"
    
    # Find available port
    local port=$(find_available_port 8000 8001 8002)
    if [ -z "$port" ]; then
        print_error "No available ports (8000, 8001, 8002). Kill existing processes."
        return 1
    fi
    
    print_success "🚀 Starting Podman container: $container_name"
    print_info "   • Port: $port"
    print_info "   • Access: http://localhost:$port"
    print_info "   • Static mode: $static_mode"
    
    # Start container based on mode
    if [ "$static_mode" = "true" ]; then
        # Static mode: serve pre-built content (if available)
        print_info "   • Mode: Static (production-like)"
        if [ -d "$APP_DIR/site-static" ]; then
            podman run -d --name "$container_name" \
                --userns=keep-id \
                --security-opt label=disable \
                -p "$port:8000" \
                -v "$APP_DIR:/app:Z" \
                --workdir /app \
                rockydocs-dev \
                python3 -m http.server 8000 --bind 0.0.0.0 -d /app/site-static
        else
            print_warning "No static site found. Run deployment first: $0 --deploy --podman"
            print_info "Falling back to live mode with current content..."
            static_mode="false"
        fi
    fi
    
    if [ "$static_mode" = "false" ]; then
        # Live mode: MkDocs development server
        print_info "   • Mode: Live (development with auto-reload)"
        podman run -d --name "$container_name" \
            --userns=keep-id \
            --security-opt label=disable \
            -p "$port:8000" \
            -v "$APP_DIR:/app:Z" \
            -v "$CONTENT_DIR:/content:Z" \
            --workdir /app \
            rockydocs-dev \
            bash -c "sed -i 's/git-revision-date-localized:/git-revision-date-localized:\\n      fallback_to_build_date: true/' mkdocs.yml && mkdocs serve -a 0.0.0.0:8000"
    fi
    
    # Add container to cleanup
    add_cleanup_resource "container:$container_name"
    
    # Health check
    print_info "Waiting for container to be ready..."
    if check_podman_health "$container_name" "$port" 30; then
        print_success "✅ Podman container ready!"
        print_info "Access your documentation at: http://localhost:$port"
        
        # Show container logs briefly
        print_info ""
        print_info "Container logs (last 10 lines):"
        podman logs --tail 10 "$container_name" 2>/dev/null || true
        print_info ""
        print_warning "Press Ctrl+C to stop the container"
        
        # Follow container logs
        podman logs -f "$container_name"
    else
        print_error "Container failed to start properly"
        podman logs "$container_name" 2>/dev/null || true
        stop_podman_container "$container_name"
        return 1
    fi
}

# Docker serving function  
serve_docker() {
    local static_mode="$1"
    
    print_info "🐳 DOCKER SERVING MODE: Container-based documentation serving"
    
    # Validate Docker setup
    if [ ! -d "$APP_DIR" ]; then
        print_error "App directory not found: $APP_DIR"
        print_info "Run setup first: $0 --setup --docker"
        return 1
    fi
    
    # Check if Docker image exists
    if ! docker image inspect rockydocs-dev >/dev/null 2>&1; then
        print_error "Docker image 'rockydocs-dev' not found"
        print_info "Run setup first: $0 --setup --docker"
        return 1
    fi
    
    cd "$APP_DIR"
    
    # Get container name and manage lifecycle
    local container_name=$(get_docker_container_name "serve")
    stop_docker_container "$container_name"
    
    # Find available port
    local port=$(find_available_port 8000 8001 8002)
    if [ -z "$port" ]; then
        print_error "No available ports (8000, 8001, 8002). Kill existing processes."
        return 1
    fi
    
    print_success "🚀 Starting Docker container: $container_name"
    print_info "   • Port: $port"
    print_info "   • Access: http://localhost:$port"
    print_info "   • Static mode: $static_mode"
    
    # Start container based on mode
    if [ "$static_mode" = "true" ]; then
        # Static mode: serve pre-built content (if available)
        print_info "   • Mode: Static (production-like)"
        if [ -d "$APP_DIR/site-static" ]; then
            docker run -d --name "$container_name" \
                -p "$port:8000" \
                -v "$APP_DIR:/app" \
                --workdir /app \
                rockydocs-dev \
                python3 -m http.server 8000 --bind 0.0.0.0 -d /app/site-static
        else
            print_warning "No static site found. Run deployment first: $0 --deploy --docker"
            print_info "Falling back to live mode with current content..."
            static_mode="false"
        fi
    fi
    
    if [ "$static_mode" = "false" ]; then
        # Live mode: MkDocs development server
        print_info "   • Mode: Live (development with auto-reload)"
        docker run -d --name "$container_name" \
            -p "$port:8000" \
            -v "$APP_DIR:/app" \
            -v "$CONTENT_DIR:/content" \
            --workdir /app \
            rockydocs-dev \
            bash -c "sed -i 's/git-revision-date-localized:/git-revision-date-localized:\\n      fallback_to_build_date: true/' mkdocs.yml && mkdocs serve -a 0.0.0.0:8000"
    fi
    
    # Add container to cleanup
    add_cleanup_resource "container:$container_name"
    
    # Health check
    print_info "Waiting for container to be ready..."
    if check_docker_health "$container_name" "$port" 30; then
        print_success "✅ Docker container ready!"
        print_info "Access your documentation at: http://localhost:$port"
        
        # Show container logs briefly
        print_info ""
        print_info "Container logs (last 10 lines):"
        docker logs --tail 10 "$container_name" 2>/dev/null || true
        print_info ""
        print_warning "Press Ctrl+C to stop the container"
        
        # Follow container logs
        docker logs -f "$container_name"
    else
        print_error "Container failed to start properly"
        docker logs "$container_name" 2>/dev/null || true
        stop_docker_container "$container_name"
        return 1
    fi
}

# === STATUS FUNCTIONS ===

show_system_info() {
    print_success "System Information:"
    echo "  • Script version: $FULL_VERSION"
    echo "  • Current directory: $CONTENT_DIR"
    echo "  • Rocky Linux version: $(detect_version) (branch: $(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown"))"
    echo "  • Platform: $(uname -s) $(uname -m)"
}

# Merged environment and configuration info
show_config_env_info() {
    print_success "Configuration & Environment:"
    echo "  • Config file: $CONFIG_FILE"
    if [ -f "$CONFIG_FILE" ]; then
        echo "  • Saved workspace: $SAVED_WORKSPACE_BASE_DIR"
    fi
    echo "  • Current workspace (WORKSPACE_BASE_DIR): $WORKSPACE_BASE_DIR"
    echo "  • Content directory (CONTENT_DIR): $CONTENT_DIR"
    echo "  • App directory (APP_DIR): $APP_DIR"
}


show_repo_status() {
    local repo_type="$1"
    local repo_dir="$2"
    
    if [ -d "$repo_dir/.git" ]; then
        cd "$repo_dir"
        local remote=$(git remote get-url origin 2>/dev/null || echo "unknown")
        local commit=$(git rev-parse HEAD 2>/dev/null || echo "unknown")
        local upstream_commit="unknown"
        if git ls-remote origin HEAD >/dev/null 2>&1; then
            upstream_commit=$(git ls-remote origin HEAD | cut -f1 2>/dev/null || echo "unknown")
        fi
        echo "  • Origin: $remote"
        echo "  • Local commit: ${commit:0:8}"
        echo "  • Remote commit: ${upstream_commit:0:8}"
        
        # Show other remotes if they exist
        local other_remotes=$(git remote | grep -v "^origin$" 2>/dev/null || true)
        if [ -n "$other_remotes" ]; then
            for remote_name in $other_remotes; do
                local remote_url=$(git remote get-url "$remote_name" 2>/dev/null || echo "unknown")
                echo "  • $remote_name: $remote_url"
            done
        fi
        
        if [ "$repo_type" = "content" ]; then
            local git_status=$(git status --porcelain 2>/dev/null | wc -l | tr -d ' ')
            if [ "$git_status" -gt 0 ]; then
                print_warning "  • $git_status uncommitted changes"
            else
                echo "  • Working tree clean"
            fi
        fi
        cd "$CONTENT_DIR"
    else
        echo "  • Not a git repository"
    fi
}

show_process_status() {
    print_success "Active Processes:"
    local mike_pids=$(pgrep -f "mike serve" 2>/dev/null || true)
    local python_pids=$(pgrep -f "python.*http\.server" 2>/dev/null || true)
    local mkdocs_pids=$(pgrep -f "mkdocs serve" 2>/dev/null || true)
    
    if [ -n "$mike_pids" ]; then
        echo "  • Mike serve PIDs: $mike_pids"
    fi
    if [ -n "$python_pids" ]; then
        echo "  • Python HTTP server PIDs: $python_pids"
    fi
    if [ -n "$mkdocs_pids" ]; then
        echo "  • MkDocs serve PIDs: $mkdocs_pids"
    fi
    if [ -z "$mike_pids" ] && [ -z "$python_pids" ] && [ -z "$mkdocs_pids" ]; then
        echo "  • No active documentation servers found"
    fi
}

show_port_status() {
    print_success "Port Usage:"
    for port in 8000 8001 8002; do
        if lsof -i :$port >/dev/null 2>&1; then
            local process_info=$(lsof -i :$port 2>/dev/null | tail -n 1 | awk '{print $1 " (PID " $2 ")"}')
            echo "  • Port $port: In use by $process_info"
        else
            echo "  • Port $port: Available"
        fi
    done
}

# Enhanced build artifacts with disk usage
show_build_artifacts() {
    print_success "Build Artifacts & Disk Usage:"
    
    # Helper function for fast disk usage
    get_disk_usage_fast() {
        local path="$1"
        if [ -d "$path" ]; then
            du -sh "$path" 2>/dev/null | cut -f1
        else
            echo "0B"
        fi
    }
    
    # Build artifacts status
    if [ -d "$APP_DIR/site" ]; then
        local site_size=$(get_disk_usage_fast "$APP_DIR/site")
        echo "  • Site directory: Found ($site_size)"
    else
        echo "  • Site directory: Not found"
    fi
    
    if [ -d "$APP_DIR/site-static" ]; then
        local static_size=$(get_disk_usage_fast "$APP_DIR/site-static")
        echo "  • Static site directory: Found ($static_size)"
    else
        echo "  • Static site directory: Not found"
    fi
    
    if [ -f "$APP_DIR/versions.json" ]; then
        echo "  • Versions file: Found"
    else
        echo "  • Versions file: Not found"
    fi
    
    # Simple disk usage totals
    local workspace_size=$(get_disk_usage_fast "$WORKSPACE_BASE_DIR")
    local worktree_size=$(get_disk_usage_fast "$APP_DIR/worktrees")
    echo "  • Total workspace: $workspace_size"
    echo "  • Cached worktrees: $worktree_size"
}

# List deployed versions (mimics mike list behavior)
list_versions() {
    print_info "Listing deployed versions..."
    
    # Check if app directory exists
    if [ ! -d "$APP_DIR" ]; then
        print_error "App directory not found: $APP_DIR"
        print_info "Run --setup first to create the build environment"
        return 1
    fi
    
    cd "$APP_DIR"
    
    # Check if gh-pages branch exists (indicates deployment has happened)
    if ! git show-ref --verify --quiet refs/heads/gh-pages; then
        print_warning "No versions deployed yet"
        print_info "Run --deploy first to create version deployments"
        return 0
    fi
    
    # Extract version information from gh-pages branch
    local current_branch=$(git rev-parse --abbrev-ref HEAD)
    
    # Check if versions.json exists on gh-pages branch
    if git ls-tree gh-pages | grep -q "versions.json"; then
        print_success "Deployed versions:"
        # Extract version info directly from gh-pages branch without switching
        git show gh-pages:versions.json | jq -r '.[] | "\(.version) [\(.title)] \(.aliases // [] | join(", ") | if . == "" then "" else "(" + . + ")" end)"' 2>/dev/null || {
            # Fallback if jq fails - simple extraction
            git show gh-pages:versions.json 2>/dev/null | grep -E '"version"|"title"|"aliases"' | paste - - - | sed 's/"version": "\([^"]*\)".*"title": "\([^"]*\)".*/\1 [\2]/'
        }
    else
        print_warning "No versions.json found on gh-pages branch"
        print_info "Checking for version directories..."
        # List version directories directly from gh-pages
        git ls-tree gh-pages | grep "^040000 tree" | awk '{print $4}' | grep -E "^[0-9]+$|^latest$" | sort -V || print_warning "No version directories found"
    fi
}

# Docker status display function
show_docker_status() {
    print_success "Docker Environment:"
    
    # Check if Docker is available
    if ! command -v docker >/dev/null 2>&1; then
        echo "  • Docker: Not available"
        return
    fi
    
    # Check Docker daemon status
    if ! docker info >/dev/null 2>&1; then
        echo "  • Docker: Available but daemon not running"
        return
    fi
    
    echo "  • Docker: Available and running"
    
    # Check for rockydocs-dev image (faster check)
    if docker images -q rockydocs-dev 2>/dev/null | grep -q .; then
        echo "  • Docker image: rockydocs-dev (available)"
    else
        echo "  • Docker image: rockydocs-dev (not found)"
    fi
    
    # Check for active containers (faster)
    local serve_container=$(get_docker_container_name "serve")
    local deploy_container=$(get_docker_container_name "deploy")
    
    local serve_running=$(docker ps -q -f name="$serve_container" 2>/dev/null)
    local deploy_running=$(docker ps -q -f name="$deploy_container" 2>/dev/null)
    
    if [ -n "$serve_running" ] || [ -n "$deploy_running" ]; then
        echo "  • Active containers: Yes"
        if [ -n "$serve_running" ]; then
            local port=$(docker port "$serve_container" 8000 2>/dev/null | cut -d: -f2)
            echo "    - Serving on port ${port:-unknown}"
        fi
        if [ -n "$deploy_running" ]; then
            echo "    - Deploy container running"
        fi
    else
        echo "  • Active containers: None"
    fi
}

# Podman status display function
show_podman_status() {
    print_success "Podman Environment:"
    
    # Check if Podman is available
    if ! command -v podman >/dev/null 2>&1; then
        echo "  • Podman: Not available"
        return
    fi
    
    # Check Podman daemon status
    if ! podman info >/dev/null 2>&1; then
        echo "  • Podman: Available but service not running"
        return
    fi
    
    echo "  • Podman: Available and running"
    
    # Check for rockydocs-dev image (faster check)
    if podman images -q rockydocs-dev 2>/dev/null | grep -q .; then
        echo "  • Podman image: rockydocs-dev (available)"
    else
        echo "  • Podman image: rockydocs-dev (not found)"
    fi
    
    # Check for active containers (faster)
    local serve_container=$(get_podman_container_name "serve")
    local deploy_container=$(get_podman_container_name "deploy")
    
    local serve_running=$(podman ps -q -f name="$serve_container" 2>/dev/null)
    local deploy_running=$(podman ps -q -f name="$deploy_container" 2>/dev/null)
    
    if [ -n "$serve_running" ] || [ -n "$deploy_running" ]; then
        echo "  • Active containers:"
        if [ -n "$serve_running" ]; then
            local port=$(podman port "$serve_container" 8000 2>/dev/null | cut -d: -f2)
            echo "    - Serve container running (port: ${port:-unknown})"
        fi
        if [ -n "$deploy_running" ]; then
            echo "    - Deploy container running"
        fi
    else
        echo "  • Active containers: None"
    fi
}

# Main status function - optimized and streamlined
show_status() {
    print_info "Rocky Linux Documentation System Status"
    echo ""
    
    show_system_info
    echo ""
    
    show_config_env_info
    echo ""
    
    print_success "Content Repository Status:"
    show_repo_status "content" "$CONTENT_DIR"
    echo ""
    
    print_success "App Repository Status:"
    if [ -d "$APP_DIR" ]; then
        show_repo_status "app" "$APP_DIR"
    else
        echo "  • App directory not found: $APP_DIR"
    fi
    echo ""
    
    show_process_status
    echo ""
    
    show_port_status
    echo ""
    
    show_docker_status
    echo ""
    
    show_podman_status
    echo ""
    
    show_build_artifacts
}

# === CLEANUP FUNCTIONS ===

# Reset configuration function
reset_configuration() {
    print_info "Resetting saved configuration..."
    
    if [ -f "$CONFIG_FILE" ]; then
        print_warning "This will remove saved workspace configuration: $CONFIG_FILE"
        read -p "Continue? (y/N): " confirm
        if [[ "$confirm" =~ ^[Yy]$ ]]; then
            run_cmd "rm -f $CONFIG_FILE"
            print_success "Configuration reset - next setup will use default workspace"
        else
            print_info "Reset operation cancelled"
        fi
    else
        print_info "No saved configuration found to reset"
    fi
}

# Clean function with enhanced resource management
clean_workspace() {
    print_info "Cleaning workspace and build artifacts..."
    
    if [ -d "$WORKSPACE_BASE_DIR" ]; then
        print_warning "This will remove the entire workspace directory: $WORKSPACE_BASE_DIR"
        print_warning "This includes the app repository and all build artifacts"
        print_info "Repository cache will be preserved for faster subsequent runs"
        read -p "Continue? (y/N): " confirm
        if [[ "$confirm" =~ ^[Yy]$ ]]; then
            # Clean up git worktrees first to avoid permission issues
            if [ -d "$APP_DIR" ]; then
                print_info "Cleaning up git worktrees..."
                cd "$APP_DIR" 2>/dev/null || true
                for worktree in rocky-8 rocky-9 main; do
                    if [ -d "worktrees/$worktree" ]; then
                        git worktree remove --force "worktrees/$worktree" 2>/dev/null || true
                    fi
                done
                cd - >/dev/null 2>&1 || true
            fi
            
            # Preserve cached repos for performance
            if [ -d "$APP_DIR/cached-repos" ]; then
                print_info "Preserving repository cache for faster startup..."
                run_cmd_with_rollback "mv $APP_DIR/cached-repos /tmp/rockydocs-cache-backup" "" "Failed to backup cache"
            fi
            
            # Fix permissions before removal
            if [ -d "$WORKSPACE_BASE_DIR" ]; then
                chmod -R 755 "$WORKSPACE_BASE_DIR" 2>/dev/null || true
            fi
            
            run_cmd "rm -rf $WORKSPACE_BASE_DIR"
            print_success "Workspace cleaned: $WORKSPACE_BASE_DIR"
            
            # Restore cache if it existed
            if [ -d "/tmp/rockydocs-cache-backup" ]; then
                run_cmd "mkdir -p $APP_DIR"
                run_cmd "mv /tmp/rockydocs-cache-backup $APP_DIR/cached-repos"
                print_info "Repository cache restored for next run"
            fi
        else
            print_info "Clean operation cancelled"
        fi
    else
        print_info "No workspace directory found to clean"
    fi
    
    # Also clean any local build artifacts in current directory
    if [ -d "site" ]; then
        run_cmd "rm -rf site"
        print_success "Local build artifacts cleaned"
    fi
    
    # Option to clean cache completely
    if [ -d "$APP_DIR/cached-repos" ]; then
        print_info ""
        print_warning "Repository cache found: $APP_DIR/cached-repos"
        print_info "This cache makes subsequent runs much faster"
        read -p "Also remove repository cache? (y/N): " clean_cache
        if [[ "$clean_cache" =~ ^[Yy]$ ]]; then
            run_cmd "rm -rf $APP_DIR/cached-repos"
            # Also remove the empty parent directory to avoid setup issues
            if [ -d "$APP_DIR" ] && [ "$(ls -A $APP_DIR 2>/dev/null | wc -l)" -eq 0 ]; then
                run_cmd "rm -rf $APP_DIR"
                print_info "Removed empty app directory"
            fi
            print_success "Repository cache cleaned (next run will be slower)"
        else
            print_info "Repository cache preserved for faster startup"
        fi
    fi
    
    # Option to clean Docker volumes
    if command -v docker >/dev/null 2>&1 && docker info >/dev/null 2>&1; then
        local workspace_volume="rockydocs-workspace-${USER}"
        local content_volume="rockydocs-content-${USER}"
        
        if docker volume inspect "$workspace_volume" >/dev/null 2>&1 || docker volume inspect "$content_volume" >/dev/null 2>&1; then
            print_info ""
            print_warning "Docker volumes found for Rocky Linux Documentation"
            cleanup_docker_volumes
        fi
    fi
    
    # Option to clean Podman volumes
    if command -v podman >/dev/null 2>&1 && podman info >/dev/null 2>&1; then
        local workspace_volume="rockydocs-workspace-${USER}"
        local content_volume="rockydocs-content-${USER}"
        
        if podman volume inspect "$workspace_volume" >/dev/null 2>&1 || podman volume inspect "$content_volume" >/dev/null 2>&1; then
            print_info ""
            print_warning "Podman volumes found for Rocky Linux Documentation"
            cleanup_podman_volumes
        fi
    fi
    
    # Option to clean saved configuration
    if [ -f "$CONFIG_FILE" ]; then
        print_info ""
        print_warning "Saved configuration found: $CONFIG_FILE"
        print_info "This contains your workspace preferences"
        read -p "Also remove saved configuration? (y/N): " clean_config
        if [[ "$clean_config" =~ ^[Yy]$ ]]; then
            run_cmd "rm -f $CONFIG_FILE"
            print_success "Saved configuration cleared - next setup will use defaults"
        else
            print_info "Saved configuration preserved"
        fi
    fi
}