---
title: firewalld від iptables
author: Steven Spencer
contributors: wsoyinka, Antoine Le Morvan, Ezequiel Bruni, qyecst
update: 22 червня 2023 р
tags:
  - безпека
  - firewalld
---

# `iptables` Посібник із `firewalld` – Вступ

З тих пір, як `firewalld` став брандмауером за замовчуванням (я думаю, це було з CentOS 7, хоча він був представлений у 2011 році), я зробив своєю місією в житті повернутися до `iptables ` будь-якою ціною. На це було дві причини. По-перше, документація, яка була доступна на той час, використовувала спрощені правила, які не показували належним чином, як сервер був захищений *аж до рівня IP*. По-друге, і, мабуть, головна причина: у мене була довга історія використання `iptables`, що сягає багатьох років, і мені було відверто легше продовжувати використовувати `iptables`. Кожен сервер, який я розгорнув, незалежно від того, відкритий чи внутрішній, використовував набір правил брандмауера `iptables`. Було легко налаштувати стандартний набір правил для сервера, з яким ми мали справу та розгортали. Щоб зробити це в CentOS 7, CentOS 8, а тепер і Rocky Linux 8, мені потрібно було використати [цю процедуру](enabling_iptables_firewall.md).

То чому я пишу цей документ? По-перше, щоб усунути обмеження більшості посилань на `firewalld` і, по-друге, змусити мене знайти способи використання `firewalld` для імітації цих детальніших правил брандмауера.

І, звичайно, щоб допомогти початківцям розібратися з брандмауером Rocky Linux за замовчуванням.

З довідкової сторінки: «`firewalld` надає динамічно керований брандмауер із підтримкою мережевих зон/зон брандмауера для визначення рівня довіри мережевих з’єднань або інтерфейсів. Він підтримує налаштування брандмауера IPv4, IPv6 і мостів Ethernet, а також розділення параметрів часу виконання та постійної конфігурації. Він також підтримує інтерфейс для служб або програм для безпосереднього додавання правил брандмауера».

Цікавий факт: `firewalld` — це інтерфейс до підсистем ядра netfilter і nftables у Rocky Linux.

Цей посібник присвячено застосуванню правил із брандмауера `iptables` до брандмауера `firewalld`. Якщо ви справді лише на початку свого шляху до брандмауера, [цей документ](firewalld-beginners.md) може допомогти вам більше. Прочитайте обидва документи, щоб максимально використати `firewalld`.

## Передумови та припущення

* У цьому документі ми припускаємо, що ви або користувач root, або використовували `sudo`, щоб стати ним.
* Побіжне знання правил брандмауера, зокрема `iptables` або, як мінімум, бажання дізнатися щось про `firewalld`.
* Вам зручно вводити команди в командному рядку.
* Усі наведені тут приклади стосуються IP-адрес IPv4.

## Зони

Щоб зрозуміти `firewalld`, вам потрібно зрозуміти використання зон. Зони – це деталізація наборів правил брандмауера.

`firewalld` має декілька вбудованих зон:

| зона     | приклад використання                                                                                                                                                     |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| drop     | скинути вхідні з'єднання без відповіді - дозволені лише вихідні пакети.                                                                                                  |
| block    | вхідні з’єднання відхиляються повідомленням icmp-host-prohibited для IPv4 та icmp6-adm-prohibited для IPv6 – можливі лише мережеві з’єднання, ініційовані в цій системі. |
| public   | для використання в громадських місцях - приймаються лише вибрані вхідні з'єднання.                                                                                       |
| external | лише вибрані вхідні підключення приймаються для використання в зовнішніх мережах із увімкненим маскуванням.                                                              |
| dmz      | для загальнодоступних комп’ютерів у вашій демілітаризованій зоні з обмеженим доступом до внутрішньої мережі приймаються лише вибрані вхідні з’єднання.                   |
| work     | для комп’ютерів у робочих зонах (ні, я також не отримую цей) – приймаються лише вибрані вхідні з’єднання.                                                                |
| home     | для використання в домашніх умовах (ні, я також не отримую цей) – приймаються лише вибрані вхідні з’єднання.                                                             |
| internal | для доступу до внутрішнього мережевого пристрою – приймаються лише вибрані вхідні з’єднання.                                                                             |
| trusted  | приймаються всі мережеві підключення.                                                                                                                                    |

!!! Note "Примітка"

    `firewall-cmd` — програма командного рядка для керування демоном `firewalld`.

Щоб отримати список існуючих зон у вашій системі, введіть:

`firewall-cmd --get-zones` !!! Warning "Важливо"

    Не забудьте перевірити стан свого брандмауера, якщо `firewalld-cmd` повертає помилку, за допомогою:
    
    команда `firewall-cmd`:

    ```
    $ firewall-cmd --state
    running
    ```


    команда `systemctl`:

    ```
    $ systemctl status firewalld
    ```

Чесно кажучи, я б не сказав, що мені подобаються назви цих зон. drop, block, public і trusted є зрозумілими, але деякі з них недостатньо хороші для ідеальної детальної безпеки. Розглянемо цей розділ правил `iptables` як приклад:

`iptables -A INPUT -p tcp -m tcp -s 192.168.1.122 --dport 22 -j ACCEPT`

Тут ми маємо єдину IP-адресу, яка дозволяє SSH (порт 22) до сервера. Якщо ми вирішимо використовувати вбудовані зони, ми можемо використовувати для цього «trusted». По-перше, ми б додали IP до зони, а по-друге, ми б застосували правило до зони:

```
firewall-cmd --zone=trusted --add-source=192.168.1.122 --permanent
firewall-cmd --zone trusted --add-service=ssh --permanent
```

Але що, якщо на цьому сервері ми також маємо інтрамережу, яка доступна лише для IP-блоків, призначених нашій організації?  Чи застосували б ми тепер «внутрішню» зону до цього правила? Відверто кажучи, я волів би створити зону, яка має справу з IP-адресами користувачів-адміністраторів (тих, яким дозволено безпечне підключення до сервера). Я вважаю за краще додати всі свої зони, але це може здатися смішним.

### Додавання зон

Щоб додати зону, нам потрібно використати `firewall-cmd` з параметром `--new-zone`. Ми збираємося додати "admin" (для адміністратора) як зону:

`firewall-cmd --new-zone=admin --permanent`

!!! Note "Примітка"

    Ми широко використовували прапорець `--permanent`. Для тестування рекомендується додати правило без прапорця `--permanent`, перевірити його та, якщо воно працює належним чином, використати `firewall-cmd --runtime-to-permanent`, щоб перемістити правило до активного використання. запустивши `firewall-cmd --reload`. Якщо ризик низький (іншими словами, ви не заблокуєте себе), ви можете додати прапорець `--permanent`, як я зробив тут.

Перш ніж цю зону можна буде використовувати, нам потрібно перезавантажити брандмауер:

`firewall-cmd --reload`

!!! tip "Підказка"

    Примітка щодо користувальницьких зон: якщо вам потрібно додати зону, яка буде довіреною, але міститиме лише певну IP-адресу джерела чи інтерфейс, а не протоколи чи служби, і «довірена» зона не працює для вас, ймовірно, тому, що ви Ви вже використовували його для чогось іншого тощо. Для цього ви можете додати спеціальну зону, але ви повинні змінити ціль зони з «за замовчуванням» на «ПРИЙНЯТИ» (можна також використовувати REJECT або DROP, залежно від ваших цілей). Ось приклад використання інтерфейсу мосту (lxdbr0 у цьому випадку) на машині LXD.
    
    Спочатку ми додаємо зону та перезавантажуємо її, щоб ми могли її використовувати:

    ```
    firewall-cmd --new-zone=bridge --permanent
    firewall-cmd --reload
    ```


    Далі ми змінюємо ціль зони з «за замовчуванням» на «ACCEPT» (**зауважте, що параметр «--permanent» необхідний для зміни цілі**), потім призначаємо інтерфейс і перезавантажуємо:

    ```
    firewall-cmd --zone=bridge --set-target=ACCEPT --permanent
    firewall-cmd --zone=bridge --add-interface=lxdbr0 --permanent
    firewall-cmd --reload
    ```


    Це повідомляє брандмауеру, що ви:

    1. змінюєте ціль зони на ACCEPT
    2. додаєте до зони інтерфейс мосту "lxdbr0".
    3. перезавантажуєте брандмауер

    Все це означає, що ви приймаєте весь трафік з інтерфейсу мосту.

### Перелік зон

Перш ніж йти далі, нам потрібно поглянути на процес перерахування зон. Ви отримуєте єдиний робочий стовпець із заголовками, а не табличний вивід, наданий `iptables -L`. Перерахування зони виконується командою `firewall-cmd --zone=[zone_name] --list-all`. Ось як це виглядає, коли ми перераховуємо щойно створену зону «admin»:

`firewall-cmd --zone=admin --list-all`

```bash
admin
  target: default
  icmp-block-inversion: no
  interfaces:
  sources:
  services:
  ports:
  protocols:
  forward: no
  masquerade: no
  forward-ports:
  source-ports:
  icmp-blocks:
  rich rules:
```
Ви можете вивести список активних зон у вашій системі за допомогою цієї команди:

`firewall-cmd --get-active-zones`

!!! Note "Важливо: активні зони"

    Зона може *тільки* бути в активному стані, якщо вона має одну з цих двох умов:

    1. Зона призначається мережевому інтерфейсу.
    2. Зоні призначаються вихідні IP-адреси або діапазони мережі.

### Видалення IP і служби із зони

Якщо ви виконали попередні вказівки щодо додавання IP-адреси до «довіреної» зони, ми повинні видалити її зараз. Пам’ятаєте нашу примітку про використання позначки `--permanent`? Це гарне місце, щоб уникати його використання під час належного тестування перед тим, як застосувати це правило:

`firewall-cmd --zone=trusted --remove-source=192.168.1.122`

Ми також хочемо видалити службу ssh із зони:

`firewall-cmd --zone=trusted --remove-service ssh`

Тоді тестуйте. Ви хочете переконатися, що у вас є вихід через `ssh` з іншої зони перед виконанням останніх двох кроків. (Див. **Попередження** нижче!). Якщо ви не внесли жодних інших змін, у «public» зоні все одно буде дозволено ssh, оскільки він є там за замовчуванням.

Коли ви задоволені, перенесіть правила виконання на постійні:

`firewall-cmd --runtime-to-permanent`

і перезавантажте:

`firewall-cmd --reload`

!!! Warning "Важливо"

    Потримайте останню інструкцію, якщо ви працюєте на віддаленому сервері або VPS! *НІКОЛИ не видаляйте службу `ssh` з віддаленого сервера*, якщо у вас немає іншого способу доступу до оболонки (див. нижче).
    
    Припустімо, ви заблокували собі доступ до `ssh` через брандмауер. У такому випадку вам доведеться (у найгіршому випадку) особисто відремонтувати сервер, звернутися до служби підтримки або, можливо, перевстановити ОС із панелі керування (залежно від того, фізичний чи віртуальний сервер).

### Використання нової зони - додавання адміністративних IP-адрес

Тепер просто повторіть наші початкові кроки, використовуючи зону «admin»:

```
firewall-cmd --zone=admin --add-source=192.168.1.122
firewall-cmd --zone admin --add-service=ssh
```

Тепер укажіть зону, щоб переконатися, що вона виглядає правильно та правильно додано службу:

`firewall-cmd --zone=admin --list-all`

Перевірте своє правило, щоб переконатися, що воно працює. Для тестування:

1. SSH як root або ваш користувач із підтримкою sudo з вашої вихідної IP-адреси (вище це 192.168.1.122) (*користувач root використовується тут, оскільки ми збираємося виконувати команди на хості, який вимагає це. Якщо ви використовуєте користувача sudo, не забудьте `sudo -s` після підключення.*)
2. Після підключення запустіть `tail /var/log/secure`, і ви маєте отримати приблизно такий результат:

```bash
Feb 14 22:02:34 serverhostname sshd[9805]: Accepted password for root from 192.168.1.122 port 42854 ssh2
Feb 14 22:02:34 serverhostname sshd[9805]: pam_unix(sshd:session): session opened for user root by (uid=0)
```
Це показує, що вихідна IP-адреса для нашого SSH-з’єднання справді була тією самою IP-адресою, яку ми щойно додали до зони «admin». Тому ми повинні бути безпечними, якщо перенести це правило на постійне значення:

`firewall-cmd --runtime-to-permanent`

Коли ви закінчите додавати правила, не забудьте перезавантажити:

`firewall-cmd --reload`

Очевидно, є інші служби, які, можливо, потрібно буде додати до зони «admin», але ssh наразі є найлогічнішим.

!!! Warning "Важливо"

    За замовчуванням у «загальнодоступній» зоні ввімкнено службу `ssh`; це може бути зобов'язанням безпеки. Після створення адміністративної зони, призначення `ssh` і перевірки ви можете видалити службу з публічної зони.

Якщо у вас є кілька адміністративних IP-адрес, які вам потрібно додати (цілком імовірно), додайте їх до джерел для зони. У цьому випадку ми додаємо IP в зону «admin»:

`firewall-cmd --zone=admin --add-source=192.168.1.151 --permanent`

!!! Note "Примітка"

    Пам’ятайте, що якщо ви працюєте на віддаленому сервері або VPS і маєте підключення до Інтернету, яке не завжди використовує ту саму IP-адресу, ви можете відкрити свою службу `ssh` для діапазону IP-адрес, які використовує ваш постачальник послуг Інтернету або географічний регіон. Знову ж таки, це робиться для того, щоб вас не заблокував ваш власний брандмауер.
    
    Якщо взагалі пропонуються, багато провайдерів стягують додаткову плату за виділені IP-адреси, тому це справжнє занепокоєння.
    
    У наведених тут прикладах передбачається, що ви використовуєте IP-адреси у власній приватній мережі для доступу до сервера, який також є локальним.

## Правила ICMP

Давайте подивимося на інший рядок у нашому брандмауері `iptables`, який ми хочемо емулювати в `firewalld` – наше правило ICMP:

`iptables -A INPUT -p icmp -m icmp --icmp-type 8 -s 192.168.1.136 -j ACCEPT`

Для новачків ICMP — це протокол передачі даних для звітування про помилки. Він повідомляє вам, коли виникли проблеми з підключенням до машини.

Насправді ми, ймовірно, залишимо ICMP відкритим для всіх наших локальних IP (у цьому випадку 192.168.1.0/24). Однак пам’ятайте, що в наших «загальнодоступних» і «адміністраторських» зонах ICMP буде ввімкнено за замовчуванням, тому перше, що потрібно зробити, щоб обмежити ICMP цією однією мережевою адресою, це заблокувати ці запити для «загальнодоступних» і «адміністраторських» .

Знову ж таки, це для демонстраційних цілей. Ви б точно хотіли, щоб ваші користувачі-адміністратори мали ICMP для ваших серверів, і вони, ймовірно, все одно будуть, оскільки вони є членами IP-адреси локальної мережі.

Щоб вимкнути ICMP у «публічній» зоні, ми б:

`firewall-cmd --zone=public --add-icmp-block={echo-request,echo-reply} --permanent`

А потім зробіть те ж саме в нашій «довіреній» зоні:

`firewall-cmd --zone=trusted --add-icmp-block={echo-request,echo-reply} --permanent`

Ми представили тут щось нове: фігурні дужки "{}" дозволяють нам вказати більше одного параметра.  Як завжди, після внесення подібних змін нам потрібно перезавантажити:

`firewall-cmd --reload`

Тестування за допомогою ping із забороненої IP-адреси дасть вам:

```bash
ping 192.168.1.104
PING 192.168.1.104 (192.168.1.104) 56(84) bytes of data.
From 192.168.1.104 icmp_seq=1 Packet filtered
From 192.168.1.104 icmp_seq=2 Packet filtered
From 192.168.1.104 icmp_seq=3 Packet filtered
```

## Порти веб-сервера

Ось сценарій `iptables` для публічного дозволу `http` і `https`, протоколів, які вам знадобляться для обслуговування веб-сторінок:

```
iptables -A INPUT -p tcp -m tcp --dport 80 -j ACCEPT
iptables -A INPUT -p tcp -m tcp --dport 443 -j ACCEPT
```

А ось еквівалент `firewalld`, який ви, мабуть, бачили багато разів раніше:

```
firewall-cmd --zone=public --add-service=http --add-service=https --permanent
```

Гаразд, усе добре, але що, якщо ви використовуєте, наприклад, службу Nextcloud на http/https і хочете, щоб ваша довірена мережа мала доступ до неї?  Це не дивно! Подібне трапляється постійно, і просто відкритий дозвіл трафіку без урахування того, хто насправді потребує доступу, є величезною дірою в безпеці.

Ми не можемо використовувати інформацію про «довірену» зону, яку ми використовували вище. Це було для тестування. Ми повинні припустити, що у нас є, як мінімум, IP-блок нашої локальної мережі, доданий до «довіреного». Це виглядало б так:

`firewall-cmd --zone=trusted --add-source=192.168.1.0/24 --permanent`

Потім нам потрібно додати служби в зону:

`firewall-cmd --zone=trusted --add-service=http --add-service=https --permanent`

Якби ви також додали ці служби до «публічної» зони, вам потрібно було б їх видалити:

`firewall-cmd --zone=public --remove-service=http --remove-service=https --permanent`

Тепер перезавантажте:

`firewall-cmd --reload`

## Порти FTP

Будь ласка, поверніться до нашого сценарію `iptables`. У нас є такі правила роботи з FTP:

```
iptables -A INPUT -p tcp -m tcp --dport 20-21 -j ACCEPT
iptables -A INPUT -p tcp -m tcp --dport 7000-7500 -j ACCEPT
```

Ця частина сценарію стосується стандартних портів FTP (20 і 21), а також відкриття деяких додаткових пасивних портів. Для таких FTP-серверів часто потрібен такий набір правил, як [VSFTPD](../file_sharing/secure_ftp_server_vsftpd.md). Як правило, таке правило буде на загальнодоступному веб-сервері та призначене для дозволу ftp-з’єднань ваших клієнтів.

Немає служби даних ftp (порт 20) із `firewalld`. Перелічені тут порти з 7000 по 7500 призначені для пасивних з’єднань FTP, і знову ж таки, немає прямого способу зробити це в `firewalld`. Ви можете перейти на SFTP, який спрощує правила дозволу портів і, ймовірно, є рекомендованим способом.

Однак ми намагаємося продемонструвати тут перетворення набору правил `iptables` на `firewalld`. Щоб вирішити всі ці проблеми, ми можемо зробити наступне.

Спочатку додайте службу FTP до зони розміщення веб-служб. Ймовірно, у цьому прикладі це буде "публічним":

`firewall-cmd --zone=public --add-service=ftp --permanent`

Тоді давайте додамо порт даних FTP:

`firewall-cmd --zone=public --add-port=20/tcp --permanent`

Далі додамо порти пасивного підключення:

`firewall-cmd --zone=public --add-port=7000-7500/tcp --permanent`

А потім, як ви здогадалися, перезавантажте:

`firewall-cmd --reload`

## Порти бази даних

Якщо ви маєте справу з веб-сервером, ви майже напевно маєте справу з базою даних. Доступ до цієї бази даних слід обробляти так само обережно, як і до інших служб. Якщо доступ не потрібен зі світу, застосуйте своє правило до чогось іншого, ніж "публічне".  Інше міркування: чи потрібно взагалі пропонувати доступ? Знову ж таки, це, ймовірно, залежить від вашого середовища. Там, де я раніше працював, ми керували розміщеним веб-сервером для наших клієнтів. У багатьох були сайти WordPress; ніхто не потребує доступу до будь-якого інтерфейсу для `MariaDB`. Якщо клієнту потрібен був додатковий доступ, ми створювали контейнер LXD для його веб-сервера, встановлювали брандмауер так, як цього бажав клієнт, і залишали на них відповідальність за те, що відбувається на сервері. Проте, якщо ваш сервер загальнодоступний, вам може знадобитися надати доступ до `phpmyadmin` або іншого інтерфейсу `MariaDB`. У цьому випадку вам потрібно подбати про вимоги до пароля для бази даних і встановити для користувача бази даних щось інше, ніж значення за замовчуванням. Для мене довжина пароля є [основним фактором під час створення паролів](https://xkcd.com/936/).

Безпека паролів є обговоренням для іншого документа, який стосується саме цього, тому ми припустимо, що у вас є хороша політика паролів для доступу до бази даних, а рядок `iptables` у вашому брандмауері, що стосується бази даних, виглядає так:

`iptables -A INPUT -p tcp -m tcp --dport=3600 -j ACCEPT`

 У цьому випадку ми просто додаємо службу до «публічної» зони для перетворення `firewalld`:

`firewall-cmd --zone=public --add-service=mysql --permanent`

### Postgresql

Postgresql використовує свій службовий порт. Ось приклад правила таблиці IP-адрес:

`iptables -A INPUT -p tcp -m tcp --dport 5432 -s 192.168.1.0/24 -j ACCEPT`

Хоча він менш поширений на загальнодоступних веб-серверах, він може бути більш поширеним як внутрішній ресурс. Застосовуються ті самі міркування безпеки. Якщо у вас є сервер у вашій довіреній мережі (192.168.1.0/24 у нашому прикладі), ви можете не захотіти або не потрібно надавати доступ усім у цій мережі. Postgresql має доступний список доступу для більш детальних прав доступу. Наше правило `firewalld` виглядатиме приблизно так:

`firewall-cmd --zone=trusted --add-service=postgresql`

## Порти DNS

Наявність приватного чи загальнодоступного DNS-сервера також означає вживання запобіжних заходів у правилах, які ви пишете, щоб захистити ці служби. Якщо у вас є приватний DNS-сервер із правилами iptables, які виглядають так (зверніть увагу, що більшість служб DNS є UDP, а не TCP, але не завжди):

`iptables -A INPUT -p udp -m udp -s 192.168.1.0/24 --dport 53 -j ACCEPT`

тоді дозволити лише вашій «довіреній» зоні буде правильно. Ми вже налаштували джерела нашої «надійної» зони, тому все, що вам потрібно зробити, це додати службу до зони:

`firewall-cmd --zone=trusted --add-service=dns`

З загальнодоступним DNS-сервером вам просто потрібно буде додати ту саму службу до «публічної» зони:

`firewall-cmd --zone=public --add-service=dns`

## Докладніше про правила лістингу

!!! Note "Примітка"

    Ви *можете* перерахувати всі правила, якщо хочете, перерахувавши правила nftables. Це негарно, і я не рекомендую цього, але якщо вам справді потрібно, ви можете створити `набір правил списку nft`.

Єдине, чого ми ще не зробили, це перелік правил. Це те, що ви можете зробити за зоною. Ось приклади зон, які ми використовували. Будь ласка, зверніть увагу, що ви також можете вказати зону перед переміщенням постійного правила, що є хорошою ідеєю.

`firewall-cmd --list-all --zone=trusted`

Тут ми можемо побачити, що ми застосували вище:

```bash
trusted (active)
  target: ACCEPT
  icmp-block-inversion: no
  interfaces:
  sources: 192.168.1.0/24
  services: dns
  ports:
  protocols:
  forward: no
  masquerade: no
  forward-ports:
  source-ports:
  icmp-blocks: echo-reply echo-request
  rich rules:
```

Це можна застосувати до будь-якої зони. Ось, наприклад, поки що «публічна» зона:

`firewall-cmd --list-all --zone=public`

```bash
public
  target: default
  icmp-block-inversion: no
  interfaces:
  sources:
  services: cockpit dhcpv6-client ftp http https
  ports: 20/tcp 7000-7500/tcp
  protocols:
  forward: no
  masquerade: no
  forward-ports:
  source-ports:
  icmp-blocks: echo-reply echo-request
  rich rules:
```
Зауважте, що ми видалили доступ "ssh" із служб і заблокували ICMP "echo-reply" і "echo-request".

У нашій «адміністративній» зоні поки що це виглядає так:

`firewall-cmd --list-all --zone=admin`

```bash
  admin (active)
  target: default
  icmp-block-inversion: no
  interfaces:
  sources: 192.168.1.122 192.168.1.151
  services: ssh
  ports:
  protocols:
  forward: no
  masquerade: no
  forward-ports:
  source-ports:
  icmp-blocks:
  rich rules:
```

## Встановлені відповідні правила

Хоча я не можу знайти жодного документа, який би конкретно це вказував, здається, що `firewalld` внутрішньо обробляє наступне правило `iptables` за умовчанням (якщо ви знаєте, що це неправильно, виправте це! ):

`iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT`

## Інтерфейси

`firewalld` за замовчуванням слухатиме всі доступні інтерфейси. На базовому сервері з декількома інтерфейсами, які стикаються з декількома мережами, вам потрібно буде призначити інтерфейс зоні на основі мережі, з якою він зустрічається.

Ми не додали жодних інтерфейсів у наші приклади, оскільки ми працюємо з контейнером LXD для лабораторних тестів. У нас є лише один інтерфейс для роботи. Припустімо, що вашу «загальнодоступну» зону потрібно налаштувати на використання порту Ethernet enp3s0, оскільки на цьому порту є загальнодоступна IP-адреса, і припустимо, що ваші «довірені» та «адміністративні» зони знаходяться на інтерфейсі LAN, який може бути enp3s1.

Щоб призначити ці зони відповідному інтерфейсу, ми б використали такі команди:

```
firewall-cmd --zone=public --change-interface=enp3s0 --permanent
firewall-cmd --zone=trusted --change-interface=enp3s1 --permanent
firewall-cmd --zone=admin --change-interface=enp3s1 --permanent
firewall-cmd --reload
```
## Загальні команди firewall-cmd

Ми вже використали деякі команди. Ось ще кілька поширених команд і те, що вони роблять:

| Команда                                      | Результат                                                                                                            |
| -------------------------------------------- | -------------------------------------------------------------------------------------------------------------------- |
| `firewall-cmd --list-all-zones`              | подібно до `firewall-cmd --list-all --zone=[zone]`, за винятком того, що тут перераховано *усі* зони та їхній вміст. |
| `firewall-cmd --get-default-zone`            | показує стандартну зону, яка є "загальнодоступною", якщо її не було змінено.                                         |
| `firewall-cmd --list-services --zone=[zone]` | показує всі служби, активовані для зони.                                                                             |
| `firewall-cmd --list-ports --zone=[zone]`    | показує всі відкриті порти в зоні.                                                                                   |
| `firewall-cmd --get-active-zones`            | показує активні зони в системі, їхні активні інтерфейси, служби та порти.                                            |
| `firewall-cmd --get-services`                | показує всі доступні послуги, які можна використовувати.                                                             |
| `firewall-cmd --runtime-to-permanent`        | якщо ви ввели багато правил без параметра `--permanent`, зробіть це перед перезавантаженням.                         |

Існує багато параметрів `firewall-cmd`, які тут не розглядаються, але тут ви знайдете команди, які найчастіше використовуються.

## Висновок

Оскільки `firewalld` рекомендований і включає брандмауер із Rocky Linux, гарною ідеєю буде ознайомитися з тим, як він працює. Спрощені правила, включені в документацію для застосування служб за допомогою `firewalld`, часто не враховують, для чого використовується сервер, і не пропонують жодних варіантів, окрім публічного дозволу служби. Цей недолік пов’язаний з дірками в безпеці, яких не обов’язково бути.

Коли ви побачите ці інструкції, подумайте, для чого використовується ваш сервер і чи потрібно, щоб служба була відкритою для світу. Якщо ні, розгляньте можливість використання більшої деталізації у своїх правилах, як описано вище. Хоча автор все ще не на 100% задоволений переходом на `firewalld`, дуже ймовірно, що я буду використовувати `firewalld` у майбутній документації.

Процес написання цього документа та лабораторного тестування результатів був для мене корисним. Сподіваюся, вони також будуть корисні комусь іншому. Це не вичерпний посібник із `firewalld`, а початкова точка.                                         
