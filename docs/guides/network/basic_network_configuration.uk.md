---
title: Конфігурація мережі
contributors: Steven Spencer, Hayden Young, Ganna Zhyrnova
tested_with: 8.5, 8.6, 9.0
tags:
  - мережі
  - конфігурація
  - мережа
---

# Вступ

У наші дні ви не можете багато чого зробити з комп’ютером без підключення до мережі. Незалежно від того, чи потрібно вам оновити пакети на сервері чи переглядати зовнішні веб-сайти зі свого ноутбука, вам знадобиться доступ до мережі! Метою цього посібника є надання користувачам Rocky Linux базових знань щодо налаштування підключення до мережі.

## Передумови

- Певний комфорт роботи з командного рядка
- Підвищені або адміністративні привілеї в системі (наприклад, root, `sudo` тощо)
- Додатково: знайомство з мережевими концепціями

=== "9"

    ## Конфігурація мережі - Rocky Linux 9
    
    З Rocky Linux 9 багато чого змінилося в конфігурації мережі. Однією з головних змін є перехід від мережевих сценаріїв (досі доступних для встановлення, але фактично застарілих) до використання Менеджера мережі та ключових файлів, а не файлів на основі `ifcfg`. `NetworkManager`, починаючи з 9, надає пріоритет `keyfiles` над попередніми `ifcfg` файлами. Оскільки зараз це значення за замовчуванням, налаштування мережі має прийняти значення за замовчуванням як правильний спосіб виконання завдань, враховуючи, що інші зміни протягом багатьох років означали остаточне припинення підтримки та видалення старіших утиліт. Цей посібник спробує ознайомити вас із використанням Network Manager та останніми змінами в Rocky Linux 9. 
    
    ## Передумови

    - Певний комфорт роботи з командного рядка
    - Підвищені або адміністративні привілеї в системі (наприклад, root, `sudo` тощо)
    - Додатково: знайомство з мережевими концепціями


    ## Використання служби NetworkManager

    На рівні користувача мережевим стеком керує `NetworkManager`. Цей інструмент працює як служба, і ви можете перевірити його стан за допомогою такої команди:

    ```bash
    systemctl status NetworkManager
    ```


    ## Файли конфігурації

    Як зазначалося на початку, файли конфігурації за замовчуванням тепер життєво важливі. Ви можете побачити, як `NetworkManager` визначає пріоритет цих файлів, виконавши таку команду:

    ```
    NetworkManager --print-config
    ```

    Це дає результат, який виглядає так:

    ```
    [main]
    # plugins=keyfile,ifcfg-rh
    # rc-manager=auto
    # auth-polkit=true
    # iwd-config-path=
    dhcp=dhclient
    configure-and-quit=no

    [logging]
    # backend=journal
    # audit=false

    [device]
    # wifi.backend=wpa_supplicant

    # no-auto-default file "/var/lib/NetworkManager/no-auto-default.state"
    ```

    Зверніть увагу на те, що у верхній частині файлу конфігурації є посилання на `keyfile`, а потім `ifcfg-rh`. Це означає, що типовим є `keyfile`. Кожного разу, коли ви запускаєте будь-який із інструментів `NetworkManager` для налаштування інтерфейсу (приклад: `nmcli` або `nmtui`), він автоматично створюватиме або оновлюватиме ключові файли.

    !!! tip "Місце зберігання конфігурації"

        У Rocky Linux 8 місце зберігання конфігурації мережі було в `/etc/sysconfig/Network-Scripts/`. У Rocky Linux 9 нове місце зберігання ключових файлів за умовчанням знаходиться в `/etc/NetworkManager/system-connections`.

    Основною (але не єдиною) утилітою, яка використовується для налаштування мережевого інтерфейсу, є команда `nmtui`. Це також можна зробити за допомогою команди `nmcli`, але це набагато менш інтуїтивно зрозуміло. Ми можемо показати інтерфейс, як він наразі налаштований за допомогою `nmcli` за допомогою:

    ```
    nmcli device show enp0s3
    GENERAL.DEVICE:                         enp0s3
    GENERAL.TYPE:                           ethernet
    GENERAL.HWADDR:                         08:00:27:BA:CE:88
    GENERAL.MTU:                            1500
    GENERAL.STATE:                          100 (connected)
    GENERAL.CONNECTION:                     enp0s3
    GENERAL.CON-PATH:                       /org/freedesktop/NetworkManager/ActiveConnection/1
    WIRED-PROPERTIES.CARRIER:               on
    IP4.ADDRESS[1]:                         192.168.1.151/24
    IP4.GATEWAY:                            192.168.1.1
    IP4.ROUTE[1]:                           dst = 192.168.1.0/24, nh = 0.0.0.0, mt = 100
    IP4.ROUTE[2]:                           dst = 0.0.0.0/0, nh = 192.168.1.1, mt = 100
    IP4.DNS[1]:                             8.8.8.8
    IP4.DNS[2]:                             8.8.4.4
    IP4.DNS[3]:                             192.168.1.1
    IP6.ADDRESS[1]:                         fe80::a00:27ff:feba:ce88/64
    IP6.GATEWAY:                            --
    IP6.ROUTE[1]:                           dst = fe80::/64, nh = ::, mt = 1024
    ```


    !!! tip "**Поради:**"

        Існує кілька способів або механізмів, за допомогою яких системам можна призначити інформацію про конфігурацію IP. Два найпоширеніші методи: схема **конфігурації статичної IP-адреси** та схема **конфігурації динамічної IP-адреси**.

        Схема конфігурації статичного IP є модною в системах або мережах серверного класу.

        Динамічний IP-підхід популярний у домашніх і офісних мережах, робочих станціях і настільних системах у бізнес-середовищі.  Динамічна схема зазвичай потребує *щось* додаткового, що є локально доступним і може надати правильну інформацію про конфігурацію IP для запитуючих робочих станцій і робочих столів. Це *щось* називається протоколом динамічної конфігурації хоста (DHCP). У домашній мережі та навіть у більшості бізнес-мереж ця послуга надається сервером DHCP, налаштованим для цієї мети. Це може бути окремий сервер або частина конфігурації маршрутизатора.


    ## IP-адреса

    У попередньому розділі показана конфігурація для інтерфейсу `enp0s3` що генерується з файлу `.ini` `/etc/NetworkManager/system-connections/enp0s3.nmconnection`. Це показує, що IP4.ADDRESS[1] було налаштовано статично, а не динамічно через DHCP. Якщо ми хочемо перемкнути цей інтерфейс назад на динамічно виділену адресу, найпростішим способом є використання команди `nmtui`.

    1. Спочатку запустіть команду `nmtui` в командному рядку, яка має показати наступне

        ![nmtui](images/nmtui_first.png)

    2. Нам уже потрібне «Редагувати з’єднання» у виділеному пункті, тож натисніть клавішу ++tab++, щоб виділити «ОК», і натисніть ++enter++

    3. Відкриється екран, на якому показано підключення Ethernet на машині, і ви зможете вибрати одне з них. У нашому випадку є *ЛИШЕ* один, тому він уже виділений, нам просто потрібно натиснути клавішу ++tab++, доки не буде виділено «Редагувати», а потім натисніть ++enter++

        ![nmtui_edit](images/nmtui_edit.png)

    4. Коли ми це зробимо, ми будемо на екрані, де буде показано нашу поточну конфігурацію. Що нам потрібно зробити, це перемкнутися з «Вручну» на «Автоматично», тому кілька разів натисніть клавішу ++tab++, доки не дійдете до місця, де буде виділено «Вручну», а потім натисніть ++enter++.

        ![nmtui_manual](images/nmtui_manual.png)

    5. Стрілка вгору, доки не буде виділено «Автоматично», а потім натисніть ++enter++

        ![nmtui_automatic](images/nmtui_automatic.png)

    6. Після того, як ми перемкнули інтерфейс на «Автоматичний», нам потрібно видалити статично призначену IP-адресу, тому натисніть клавішу ++tab++, доки «Видалити» не буде виділено поруч із IP-адресою, і натисніть ++enter++.

        ![nmtui_remove](images/nmtui_remove.png)

    7. Нарешті натисніть клавішу ++tab++ кілька разів, доки не дійдете до нижньої частини екрана `nmtui` і не буде виділено «OK», а потім натисніть ++enter++

    Ви також можете вимкнути та знову активувати свій інтерфейс за допомогою `nmtui`, але натомість зробимо це за допомогою `nmcli`. Таким чином ми можемо зв’язати деактивацію та повторну активацію інтерфейсу, щоб інтерфейс ніколи не був недоступним надовго:

    ```
    nmcli con down enp0s3 && nmcli con up enp0s3
    ```

    Подумайте про це як про еквівалент старого `ifdown enp0s3 && ifup enp0s3` використовується в старих версіях ОС.

    Щоб переконатися, що це спрацювало, перевірте за допомогою команди `ip addr` або команди `nmcli device show enp0s3`, яку ми використовували раніше.

    ```
    ip addr
    ```

    У разі успіху ви побачите, що статичну IP-адресу видалено та додано динамічно виділену адресу, подібну до цієї:

    ```bash
    2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 08:00:27:ba:ce:88 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.137/24 brd 192.168.1.255 scope global dynamic noprefixroute enp0s3
       valid_lft 6342sec preferred_lft 6342sec
    inet6 fe80::a00:27ff:feba:ce88/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever
    ```


    ### Зміна IP-адреси за допомогою `nmcli`

    Користуватися `nmtui` добре, але якщо ви хочете швидко переналаштувати мережевий інтерфейс, не витрачаючи час між екранами, ви, ймовірно, захочете використовувати `nmcli` окремо. Давайте розглянемо наведений вище приклад статично призначеної IP-адреси та кроки для переналаштування інтерфейсу на DHCP лише за допомогою `nmcli`.

    Перш ніж почати, майте на увазі, що для переналаштування інтерфейсу на DHCP нам потрібно:

    - Видаліть шлюз IPv4
    - Видаліть IPv4-адресу, яку ми статично призначили
    - Змініть метод IPv4 на автоматичний
    - Інтерфейс вниз і вгору

    Зауважте, що ми не використовуємо приклади, які говорять вам про використання -ipv4.address тощо. Вони не змінюють повністю інтерфейс. Для цього ми повинні встановити порожній рядок для ipv4.address і ipv4.gateway. Знову ж таки, щоб заощадити якомога більше часу за допомогою нашої команди, ми збираємося об’єднати їх усі в один рядок:

    ```
    nmcli con mod enp0s3 ipv4.gateway '' && nmcli con mod enp0s3 ipv4.address '' && nmcli con mod enp0s3 ipv4.method auto && nmcli con down enp0s3 && nmcli con up enp0s3
    ```

    Повторне виконання команди `ip addr` має показати ті самі результати, що й під час виконання змін за допомогою `nmtui`. Очевидно, ми могли б зробити все і навпаки (змінити адресу DHCP на статичну). Для цього ми б запустили команди у зворотному порядку, починаючи зі зміни `ipv4.method` на ручний, налаштувавши `ipv4.gateway`, а потім налаштувавши `ipv4.address`. Оскільки в усіх цих прикладах ми повністю змінюємо конфігурацію інтерфейсу, а не додаємо чи віднімаємо до нього значення, ми знову не будемо використовувати моделі, які говорять про використання `+ipv4.method`,` +ipv4.gateway` та `+ipv4.address`. Якщо ви використаєте ці команди замість тих, які ми використовували вище, ви отримаєте інтерфейс із *ОБОДВА* адресою, призначеною DHCP, і адресою, призначеною статично. Проте інколи це може бути дуже зручно. Якщо у вас є веб-служба, яка слухає одну IP-адресу, а SFTP-сервер – іншу IP-адресу. Наявність методу призначення кількох IP-адрес інтерфейсу є досить корисним.


    ## Роздільна здатність DNS

    Налаштувати DNS-сервери можна за допомогою `nmtui` або `nmcli`. Хоча інтерфейс `nmtui` простий у навігації та набагато більш інтуїтивно зрозумілий, процес набагато повільніший. Зробити це за допомогою `nmcli` набагато швидше. У випадку адреси, призначеної DHCP, зазвичай немає необхідності встановлювати DNS-сервери, оскільки вони зазвичай пересилаються з сервера DHCP. Проте ви *можете* статично додавати DNS-сервери до інтерфейсу DHCP. У випадку зі статично призначеним інтерфейсом ви *МАЄТЕ* це зробити, оскільки йому потрібно знати, як отримати дозвіл DNS, і не матимете автоматично призначеного методу.

    Оскільки найкращим прикладом для всього цього є статично призначений IP, давайте повернемося до нашої вихідної статично призначеної адреси в нашому прикладі інтерфейсу (enp0s3). Перш ніж змінювати значення DNS, нам потрібно побачити, які вони зараз. Щоб отримати правильний дозвіл імен, видаліть уже налаштовані DNS-сервери та додайте інші. Наразі для `ipv4.dns` встановлено `8.8.8.8,8.8.4.4,192.168.1.1`. У цьому випадку нам не потрібно встановлювати для ipv4.dns порожній рядок. Ми можемо використовувати таку команду, щоб замінити наші значення:

    ```
    nmcli con mod enp0s3 ipv4.dns '208.67.222.222,208.67.220.220,192.168.1.1'
    ```

    Запуск `nmcli con show enp0s3 | grep ipv4.dns` має показати, що ми успішно змінили сервери DNS. Щоб активувати все, давайте перенесемо наш інтерфейс вниз і знову, щоб наші зміни були активними:

    ```
    nmcli con down enp0s3 && nmcli con up enp0s3
    ```

    Щоб перевірити, чи ми *робимо* розпізнавання імен, спробуйте перевірити ping на відомому хості. Ми будемо використовувати google.com як приклад:

    ```bash
    ping google.com
    PING google.com (172.217.4.46) 56(84) bytes of data.
    64 bytes from lga15s46-in-f14.1e100.net (172.217.4.46): icmp_seq=1 ttl=119 time=14.5 ms
    64 bytes from lga15s46-in-f14.1e100.net (172.217.4.46): icmp_seq=2 ttl=119 time=14.6 ms
    64 bytes from lga15s46-in-f14.1e100.net (172.217.4.46): icmp_seq=3 ttl=119 time=14.4 ms
    ^C
    ```


    ## Використання утиліти `ip`

    Команда `ip` (надається пакетом *iproute2*) є потужним інструментом для отримання інформації та налаштування мережі сучасної системи Linux, такої як Rocky Linux.

    У цьому прикладі ми припустимо такі параметри:

    - interface name: enp0s3
    - ip address: 192.168.1.151
    - subnet mask: 24
    - gateway: 192.168.1.1


    ### Отримання загальної інформації

    Щоб переглянути детальний стан усіх інтерфейсів, використовуйте

    ```bash
    ip a
    ```

    !!! tip "**Професійні поради:**"

        * використовуйте прапорець `-c`, щоб отримати більш читабельний кольоровий вивід: `ip -c a`.
        * `ip` приймає абревіатуру, тому `ip a`, `ip addr` та `ip address` еквівалентні


    ### Переміщення інтерфейсу вгору або вниз

    !!! note "Примітка"

        Незважаючи на те, що цей метод все ще можна використовувати для зміни інтерфейсу в Rocky Linux 9, команда реагує набагато повільніше, ніж просто використання команди `nmcli` у наших попередніх прикладах.

    Щоб повернути *enp0s3* вниз і знову, ми можемо просто використати:

    ```
    ip link set enp0s3 down && ip link set enp0s3 up
    ```


    ### Призначення інтерфейсу статичної адреси

    Наразі наш інтерфейс enp0s3 має IP-адресу 192.168.1.151. Щоб перемкнути його на 192.168.1.152, ми видалимо старий IP-адресу за допомогою

    ```bash
    ip addr delete 192.168.1.151/24 dev enp0s3 && ip addr add 192.168.1.152/24 dev enp0s3
    ```

    Якби ми хотіли, щоб інтерфейсу було призначено другий IP замість видалення адреси 192.168.1.151, ми б просто додали другу адресу за допомогою:

    ```bash
    ip addr add 192.168.1.152/24 dev enp0s3
    ```

    Ми можемо перевірити, чи було додано IP-адресу за допомогою

    ```bash
    ip a show dev enp0s3
    ```

    виведе:

    ```bash
    2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 08:00:27:ba:ce:88 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.151/24 brd 192.168.1.255 scope global noprefixroute enp0s3
       valid_lft forever preferred_lft forever
    inet 192.168.1.152/24 scope global secondary enp0s3
       valid_lft forever preferred_lft forever
    inet6 fe80::a00:27ff:feba:ce88/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever
    ```

    Хоча перемикання інтерфейсу за допомогою утиліти `ip` набагато повільніше, ніж `nmcli`, `ip` має явну перевагу під час встановлення нових або додаткових IP-адрес, як це відбувається в режимі реального часу, без переривання інтерфейсу.


    ### Конфігурація шлюзу


    Тепер, коли інтерфейс має адресу, ми повинні встановити його маршрут за замовчуванням. Це можна зробити за допомогою:

    ```bash
    ip route add default via 192.168.1.1 dev enp0s3
    ```

    Таблицю маршрутизації ядра можна відобразити за допомогою

    ```bash
    ip route
    ```

    або скорочено `ip r`.

    Це має вивести щось на зразок цього:

    ```bash
    default via 192.168.1.1 dev enp0s3 
    192.168.1.0/24 dev enp0s3 proto kernel scope link src 192.168.1.151 metric 100
    ```


    ## Перевірка підключення до мережі

    У наведених вище прикладах ми провели певне тестування. Найкращий вибір для тестування — почати з перевірки ping шлюзу за замовчуванням. Це завжди має працювати:

    ```bash
    ping -c3 192.168.1.1
    PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data.
    64 bytes from 192.168.1.1: icmp_seq=1 ttl=64 time=0.437 ms
    64 bytes from 192.168.1.1: icmp_seq=2 ttl=64 time=0.879 ms
    64 bytes from 192.168.1.1: icmp_seq=3 ttl=64 time=0.633 ms
    ```

    Далі перевірте, чи ваша маршрутизація локальної мережі працює повністю, виконавши ping до хосту у вашій локальній мережі:

    ```bash
    ping -c3 192.168.1.10
    PING 192.168.1.10 (192.168.1.10) 56(84) bytes of data.
    64 bytes from 192.168.1.10: icmp_seq=2 ttl=255 time=0.684 ms
    64 bytes from 192.168.1.10: icmp_seq=3 ttl=255 time=0.676 ms
    ```

    Перевірте, щоб переконатися, що ми можемо бачити доступний хост поза вашою мережею. Для наведеного нижче тесту ми використовуємо відкритий DNS-сервер Google:

    ```bash
    ping -c3 8.8.8.8
    PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.
    64 bytes from 8.8.8.8: icmp_seq=1 ttl=119 time=19.8 ms
    64 bytes from 8.8.8.8: icmp_seq=2 ttl=119 time=20.2 ms
    64 bytes from 8.8.8.8: icmp_seq=3 ttl=119 time=20.1 ms
    ```

    Останнім тестом є перевірка роботи роздільної здатності DNS. Для цього прикладу ми використовуємо google.com:

    ```bash
    ping -c3 google.com
    PING google.com (172.217.4.46) 56(84) bytes of data.
    64 bytes from lga15s46-in-f14.1e100.net (172.217.4.46): icmp_seq=1 ttl=119 time=14.5 ms
    64 bytes from lga15s46-in-f14.1e100.net (172.217.4.46): icmp_seq=2 ttl=119 time=15.1 ms
    64 bytes from lga15s46-in-f14.1e100.net (172.217.4.46): icmp_seq=3 ttl=119 time=14.6 ms
    ```

    Якщо ваша машина має кілька інтерфейсів і ви хочете протестувати з певного інтерфейсу, просто скористайтеся опцією `-I` з ping:

    ```bash
    ping -I enp0s3 -c3 192.168.1.10
    ```


    ## Висновок

    У Rocky Linux 9 є багато змін у мережевому стеку. Серед них пріоритетність `keyfile` над раніше використовуваними файлами `ifcfg`, знайденими в Network-Scripts. Оскільки в наступних версіях Rocky Linux мережеві сценарії будуть застарілими та видаленими, краще зосередити увагу на таких методологіях, як `nmcli`, `nmtui` та в у деяких випадках `ip`, для налаштування мережі.

=== "8"

    ## Конфігурація мережі - Rocky Linux 8
    
    ## Використання служби NetworkManager
    
    На рівні користувача мережевим стеком керує *NetworkManager*. Цей інструмент працює як служба, і ви можете перевірити його стан за допомогою такої команди:

    ```bash
    systemctl status NetworkManager
    ```


    ### Конфігураційні файли
    
    NetworkManager просто застосовує конфігурацію, зчитану з файлів, знайдених у `/etc/sysconfig/network-scripts/ifcfg-<IFACE_NAME>`.
    Кожен мережевий інтерфейс має свій конфігураційний файл. Нижче показано приклад стандартної конфігурації сервера:

    ```bash
    TYPE=Ethernet
    PROXY_METHOD=none
    BROWSER_ONLY=no
    BOOTPROTO=none
    DEFROUTE=yes
    IPV4_FAILURE_FATAL=no
    IPV6INIT=no
    NAME=enp1s0
    UUID=74c5ccee-c1f4-4f45-883f-fc4f765a8477
    DEVICE=enp1s0
    ONBOOT=yes
    IPADDR=10.0.0.10
    PREFIX=24
    GATEWAY=10.0.0.1
    DNS1=10.0.0.1
    DNS2=1.1.1.1
    IPV6_DISABLED=yes
    ```


    Ім’я інтерфейсу – **enp1s0**, тому ім’я цього файлу буде `/etc/sysconfig/network-scripts/ifcfg-enp1s0`.
    
    !!! tip "**Поради:**"  
    
        Існує кілька способів або механізмів, за допомогою яких системам можна призначити інформацію про конфігурацію IP. Два найпоширеніші методи: схема **конфігурації статичної IP-адреси** та схема **конфігурації динамічної IP-адреси**.
    
        Схема конфігурації статичного IP є модною в системах або мережах серверного класу.
    
        Динамічний IP-підхід популярний у домашніх і офісних мережах або в системах робочих станцій і настільних комп’ютерів.  Динамічна схема зазвичай потребує _щось_ додаткового, що є локально доступним, що може надати належну інформацію про конфігурацію IP для запитуючих робочих станцій і настільних комп’ютерів. Це *щось* називається протоколом динамічної конфігурації хоста (DHCP).
    
       Домашнім/офісним користувачам часто не потрібно турбуватися або знати про DHCP. Це тому, що хтось інший автоматично піклується про це у фоновому режимі. Кінцевий користувач має фізично чи бездротово підключитися до правильної мережі (і, звичайно, переконатися, що його системи увімкнено)!
    
    ### IP-адреса
    
    У попередньому списку `/etc/sysconfig/network-scripts/ifcfg-enp1s0` значення параметра або ключа `BOOTPROTO` має значення `none`. Налаштована система налаштована на схему статичної IP-адреси.
    
    Якщо натомість ви хочете налаштувати систему на використання схеми динамічної IP-адреси, вам доведеться змінити значення параметра `BOOTPROTO` з `none` на `dhcp`, а також видалити `IPADDR`, `PREFIX` і рядки `GATEWAY`. Це необхідно, оскільки вся ця інформація буде автоматично отримана з будь-якого доступного сервера DHCP.
    
    Щоб налаштувати атрибуцію статичної IP-адреси, установіть наступне:

    * IPADDR: IP-адреса для призначення інтерфейсу
    * PREFIX: маска підмережі в [нотації CIDR](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
    * GATEWAY: шлюз за умовчанням

    Параметр `ONBOOT` зі значенням `yes` вказує на те, що це підключення буде активовано під час завантаження.


    ### Роздільна здатність DNS

    Для правильного розпізнавання імен необхідно встановити наступні параметри:

    * DNS1: IP-адреса основного сервера імен
    * DNS2: IP-адреса вторинного сервера імен


    ### Перевірка конфігурації

    Перевірити правильність застосування конфігурації можна за допомогою такої команди `nmcli`:

    ```bash
    [user@server ~]$ sudo nmcli device show enp1s0
    ```

    який повинен дати вам наступний результат:

    ```conf
    GENERAL.DEVICE:                         enp1s0
    GENERAL.TYPE:                           ethernet
    GENERAL.HWADDR:                         6E:86:C0:4E:15:DB
    GENERAL.MTU:                            1500
    GENERAL.STATE:                          100 (connecté)
    GENERAL.CONNECTION:                     enp1s0
    GENERAL.CON-PATH:                       /org/freedesktop/NetworkManager/ActiveConnection/1
    WIRED-PROPERTIES.CARRIER:               marche
    IP4.ADDRESS[1]:                         10.0.0.10/24
    IP4.GATEWAY:                            10.0.0.1
    IP4.ROUTE[1]:                           dst = 10.0.0.0/24, nh = 0.0.0.0, mt = 100
    IP4.ROUTE[2]:                           dst = 0.0.0.0/0, nh = 10.0.0.1, mt = 100
    IP4.DNS[1]:                             10.0.0.1
    IP4.DNS[2]:                             1.1.1.1
    IP6.GATEWAY:                            --
    ```


    ### CLI

    Основною функцією NetworkManager є керування «з’єднаннями», які відображають фізичний пристрій для більш логічних мережевих компонентів, таких як IP-адреса та налаштування DNS. Щоб переглянути наявні підключення, які підтримує NetworkManager, ви можете запустити `nmcli connection show`.

    ```bash
    [user@server ~]$ sudo nmcli connection show
    NAME    UUID                                  TYPE      DEVICE
    enp1s0  625a8aef-175d-4692-934c-2c4a85f11b8c  ethernet  enp1s0
    ```

    З результатів вище ми можемо визначити, що NetworkManager керує з’єднанням (`NAME`) під назвою `enp1s0`, яке відображається на фізичному пристрої (`DEVICE`) `enp1s0`.

    !!! tip "Назва з'єднання"

        У цьому прикладі з’єднання та пристрій мають однакове ім’я, але це не завжди так. Зазвичай можна побачити підключення під назвою `System eth0`, яке, наприклад, відображається на пристрої під назвою `eth0`.

    Тепер, коли ми знаємо назву нашого підключення, ми можемо переглянути його налаштування. Для цього скористайтеся командою `nmcli connection show [connection]`, яка роздрукує всі параметри, зареєстровані NetworkManager для даного з’єднання.

    ```bash
    [user@server ~]$ sudo nmcli connection show enp1s0
    ...
    ipv4.method:                            auto
    ipv4.dns:                               --
    ipv4.dns-search:                        --
    ipv4.dns-options:                       --
    ipv4.dns-priority:                      0
    ipv4.addresses:                         --
    ipv4.gateway:                           --
    ipv4.routes:                            --
    ipv4.route-metric:                      -1
    ipv4.route-table:                       0 (unspec)
    ipv4.routing-rules:                     --
    ipv4.ignore-auto-routes:                no
    ipv4.ignore-auto-dns:                   no
    ipv4.dhcp-client-id:                    --
    ipv4.dhcp-iaid:                         --
    ipv4.dhcp-timeout:                      0 (default)
    ipv4.dhcp-send-hostname:                yes
    ...
    ```

    Унизу лівого стовпця ми бачимо назву параметра, а внизу праворуч – значення.

    Наприклад, ми бачимо, що `ipv4.method` тут наразі встановлено на `auto`. Існує багато дозволених значень для параметра `ipv4.method`, але два основні, які ви, швидше за все, побачите:

    - `auto`: для інтерфейсу використовується відповідний автоматичний метод (DHCP, PPP тощо), більшість інших властивостей можна не налаштовувати.
    - `manual`: використовується статична IP-адреса, і принаймні одну IP-адресу потрібно вказати у властивості 'addresses'.

    Якщо замість цього ви хочете налаштувати систему на використання схеми статичної IP-адреси, вам доведеться змінити значення `ipv4.method` на `manual`, а також вказати `ipv4.gateway` та `ipv4.addresses`.

    Щоб змінити налаштування, ви можете скористатися командою nmcli `nmcli connection modify [connection] [setting] [value]`.

    ```bash
    # set 10.0.0.10 as the static ipv4 address
    [user@server ~]$ sudo nmcli connection modify enp1s0 ipv4.addresses 10.0.0.10

    # set 10.0.0.1 as the ipv4 gateway
    [user@server ~]$ sudo nmcli connection modify enp1s0 ipv4.gateway 10.0.0.1

    # change ipv4 method to use static assignments (set in the previous two commands)
    [user@server ~]$ sudo nmcli connection modify enp1s0 ipv4.method manual
    ```

    !!! tip "Коли з’єднання оновлюється?"

        `nmcli connection modify` не змінюватиме конфігурацію *runtime*, але оновлюватиме конфігурацію `/etc/sysconfig/network-scripts` файли з відповідними значеннями на основі того, що ви сказали `nmcli` налаштувати.

    Щоб налаштувати ваші DNS-сервери за допомогою NetworkManager через CLI, ви можете змінити параметр `ipv4.dns`.

    ```bash
    # set 10.0.0.1 and 1.1.1.1 as the primary and secondary DNS servers
    [user@server ~]$ sudo nmcli connection modify enp1s0 ipv4.dns '10.0.0.1 1.1.1.1'
    ```


    ### Застосування конфігурації

    Щоб застосувати конфігурацію мережі, ви можете скористатися командою `nmcli connection up [connection]`.

    ```bash
    [user@server ~]$ sudo nmcli connection up enp1s0
    Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/2)
    ```

    Щоб отримати стан підключення, просто використовуйте:

    ```bash
    [user@server ~]$ sudo nmcli connection show
    NAME    UUID                                  TYPE      DEVICE
    enp1s0  625a8aef-175d-4692-934c-2c4a85f11b8c  ethernet  enp1s0
    ```

    Ви також можете використати команди `ifup` та `ifdown`, щоб змінити інтерфейс (вони є простими обгортками навколо `nmcli`):

    ```bash
    [user@server ~]$ sudo ifup enp1s0
    [user@server ~]$ sudo ifdown enp1s0
    ```


    ## Використання утиліти ip

    Команда `ip` (надається пакетом *iproute2*) є потужним інструментом для отримання інформації та налаштування мережі сучасної системи Linux, такої як Rocky Linux.

    У цьому прикладі ми припустимо такі параметри:

    - назва інтерфейсу: ens19
    - ip-адреса: 192.168.20.10
    - subnet mask: 24
    - шлюз: 192.168.20.254


    ### Отримання загальної інформації

    Щоб переглянути детальний стан усіх інтерфейсів, використовуйте

    ```bash
    ip a
    ```

    !!! tip "**Професійні поради:**"

        - використовуйте прапорець `-c`, щоб отримати більш читабельний кольоровий вивід: `ip -c a`.
        - `ip` приймає абревіатуру, тому `ip a`, `ip addr` та `ip address` еквівалентні


    ### Переміщення інтерфейсу вгору або вниз

    Щоб активувати інтерфейс *ens19*, просто скористайтеся `ip link set ens19 up`, а щоб вивести його з ладу, використовуйте `ip link set ens19 down`.


    ### Призначення інтерфейсу статичної адреси

    Команда, яка буде використана, має вигляд:

    ```bash
    ip addr add <IP ADDRESS/CIDR> dev <IFACE NAME>
    ```

    Щоб призначити наведені вище приклади параметрів, ми використаємо:

    ```bash
    ip a add 192.168.20.10/24 dev ens19
    ```

    Потім перевірте результат за допомогою:

    ```bash
    ip a show dev ens19
    ```

    виведе:

    ```bash
    3: ens19: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
        link/ether 4a:f2:f5:b6:aa:9f brd ff:ff:ff:ff:ff:ff
        inet 192.168.20.10/24 scope global ens19
        valid_lft forever preferred_lft forever
    ```

    Наш інтерфейс працює та налаштований, але йому все ще чогось не вистачає!


    ### Використання утиліти ifcfg

    Щоб додати інтерфейс *ens19* до нашої нової прикладної IP-адреси, скористайтеся такою командою:

    ```bash
    ifcfg ens19 add 192.168.20.10/24
    ```

    Щоб видалити адресу:

    ```bash
    ifcfg ens19 del 192.168.20.10/24
    ```

    Щоб повністю вимкнути IP-адресу в цьому інтерфейсі:

    ```bash
    ifcfg ens19 stop
    ```

    *Зауважте, що це не призведе до роботи інтерфейсу; він просто скасовує всі IP-адреси з інтерфейсу.*


    ### Конфігурація шлюзу

    Тепер, коли інтерфейс має адресу, ми повинні встановити його маршрут за замовчуванням; це можна зробити за допомогою наступного:

    ```bash
    ip route add default via 192.168.20.254 dev ens19
    ```

    Таблицю маршрутизації ядра можна відобразити за допомогою

    ```bash
    ip route
    ```

    або скорочено `ip r`.


    ## Перевірка підключення до мережі

    На цьому етапі ваш мережевий інтерфейс має бути належним чином налаштований. Є кілька способів перевірити підключення.

    Шляхом *pinging* іншої IP-адреси в тій же мережі (ми використаємо `192.168.20.42` як приклад):

    ```bash
    ping -c3 192.168.20.42
    ```

    Ця команда надішле 3 *пінги* (відомі як запит ICMP) і чекає на відповідь. Якщо все пройшло добре, ви повинні отримати такий результат:

    ```bash
    PING 192.168.20.42 (192.168.20.42) 56(84) bytes of data.
    64 bytes from 192.168.20.42: icmp_seq=1 ttl=64 time=1.07 ms
    64 bytes from 192.168.20.42: icmp_seq=2 ttl=64 time=0.915 ms
    64 bytes from 192.168.20.42: icmp_seq=3 ttl=64 time=0.850 ms

    --- 192.168.20.42 ping statistics ---
    3 packets transmitted, 3 received, 0% packet loss, time 5ms
    rtt min/avg/max/mdev = 0.850/0.946/1.074/0.097 ms
    ```

    Потім, щоб переконатися, що ваша конфігурація маршрутизації правильна, спробуйте *ping* зовнішнього хосту, наприклад, цього добре відомого загальнодоступного розпізнавача DNS:

    ```bash
    ping -c3 8.8.8.8
    ```

    Якщо ваша машина має кілька мережевих інтерфейсів і ви хочете зробити запит ICMP через певний інтерфейс, ви можете використати позначку `-I`:

    ```bash
    ping -I ens19 -c3 192.168.20.42
    ```

    Настав час переконатися, що роздільна здатність DNS працює правильно. Нагадуємо, що роздільна здатність DNS — це механізм, який використовується для перетворення зрозумілих для людини імен машин на їхні IP-адреси та навпаки (зворотний DNS).

    Якщо файл `/etc/resolv.conf` вказує на доступний DNS-сервер, тоді має працювати наступне:

    ```bash
    host rockylinux.org
    ```

    Результат має бути:

    ```bash
    rockylinux.org has address 76.76.21.21
    ```


    ## Висновок

    У Rocky Linux 8 є інструменти для налаштування мережі за допомогою командного рядка. Цей документ допоможе вам швидко почати роботу з цими інструментами.
