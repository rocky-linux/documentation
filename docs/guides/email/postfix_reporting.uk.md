---
title: Звітування про процес Postfix
author: Steven Spencer
contributors: Ezequiel Bruni, Ganna Zhyrnova
tested_with: 8.5, 8.6, 9.0
tags:
  - email
  - звіти
  - інструменти
---

# Використання `postfix` для звітування про процеси сервера

## Передумови

- Повний комфорт роботи з командного рядка на сервері Rocky Linux
- Знайомство з редактором на ваш вибір (у цьому документі використовується редактор \`vi, але ви можете замінити його улюбленим редактором)
- Розуміння DNS (системи доменних імен) та імен хостів
- Можливість призначати змінні в сценарії bash
- Знання того, що роблять команди `tail`, `more`, `grep`, та `date`

## Вступ

Багато адміністраторів серверів Rocky Linux пишуть сценарії для виконання певних завдань, таких як резервне копіювання або синхронізація файлів, і багато з цих сценаріїв створюють журнали, які містять корисну, а часом і дуже важливу інформацію. Однак мати лише журнали недостатньо. Якщо процес дає збій і реєструє цю помилку, але зайнятий адміністратор не переглядає журнал, тоді може бути катастрофа.

У цьому документі показано, як використовувати MTA (агент передачі пошти) `postfix` для отримання даних журналу з певного процесу та надсилання їх вам електронною поштою. Він також торкається форматів дати в журналах і допомагає визначити, який формат використовувати в процедурі звітування.

Пам'ятайте, що це лише верхівка айсберга щодо того, що ви можете робити зі звітами через `postfix`. Зауважте, що обмежити запущені процеси лише тими, які вам будуть потрібні постійно, завжди є хорошим заходом безпеки.

У цьому документі показано, як увімкнути Postfix лише для звітів, які вам потрібні, а потім знову вимкнути його.

## Визначення `postfix`

`postfix` — це демон сервера, який використовується для надсилання електронної пошти. Це більш безпечний і зрозумілий, ніж sendmail, ще один MTA, який роками використовувався за умовчанням. Ви можете використовувати його як частину повнофункціонального поштового сервера.

## Встановлення `postfix`

Окрім `postfix`, вам знадобиться `mailx`, щоб перевірити свою здатність надсилати електронні листи. Щоб установити ці та будь-які необхідні залежності, введіть наступне в командному рядку сервера Rocky Linux:

`dnf install postfix mailx`

!!! warning "Зміни у Rocky Linux 9.0"

    Ця процедура чудово працює в Rocky Linux 9.0. Різниця тут полягає в тому, звідки походить команда `mailx`. Хоча ви можете встановити його за назвою у 8.x, `mailx` походить із пакета appstream `s-nail` у 9.0. Щоб встановити необхідні пакети, потрібно використовувати:
    
    `     dnf install postfix s-nail     `

## Тестування та налаштування `postfix`

### Тестування пошти

Перш ніж налаштовувати `postfix`, вам потрібно з'ясувати, як виглядатиме пошта після відправлення із сервера, оскільки ви, ймовірно, захочете це змінити. Щоб це зробити, запустіть `postfix`:

`systemctl start postfix`

Перевірте за допомогою `mail`, наданого `mailx` (або `s-nail`):

`mail -s "Testing from server" myname@mydomain.com`

Це відобразить порожній рядок. Введіть своє тестове повідомлення тут:

`testing from the server`

Тепер натисніть enter і введіть одну крапку:

`.`

Система відповість наступним чином:

`EOT`

Мета цього — побачити, як виглядає наша пошта для зовнішнього світу. Ви можете отримати уявлення про це з _maillog_, який активується після запуску `postfix`.

Використовуйте цю команду, щоб переглянути вихідні дані файлу журналу:

`tail /var/log/maillog`

Ви побачите щось подібне, хоча файл журналу матиме різні домени для адреси електронної пошти та інших елементів:

```bash
Mar  4 16:51:40 hedgehogct postfix/postfix-script[735]: starting the Postfix mail system
Mar  4 16:51:40 hedgehogct postfix/master[737]: daemon started -- version 3.3.1, configuration /etc/postfix
Mar  4 16:52:04 hedgehogct postfix/pickup[738]: C9D42EC0ADD: uid=0 from=<root>
Mar  4 16:52:04 hedgehogct postfix/cleanup[743]: C9D42EC0ADD: message-id=<20210304165204.C9D42EC0ADD@somehost.localdomain>
Mar  4 16:52:04 hedgehogct postfix/qmgr[739]: C9D42EC0ADD: from=<root@somehost.localdomain>, size=457, nrcpt=1 (queue active)
Mar  4 16:52:05 hedgehogct postfix/smtp[745]: connect to gmail-smtp-in.l.google.com[2607:f8b0:4001:c03::1a]:25: Network is unreachable
Mar  4 16:52:06 hedgehogct postfix/smtp[745]: C9D42EC0ADD: to=<myname@mydomain.com>, relay=gmail-smtp-in.l.google.com[172.217.212.26]
:25, delay=1.4, delays=0.02/0.02/0.99/0.32, dsn=2.0.0, status=sent (250 2.0.0 OK  1614876726 z8si17418573ilq.142 - gsmtp)
Mar  4 16:52:06 hedgehogct postfix/qmgr[739]: C9D42EC0ADD: removed
```

"somehost.localdomain" показує, що вам потрібно внести зміни. Спочатку зупиніть демон `postfix`:

`systemctl stop postfix`

## Налаштування `postfix`

Оскільки ви не налаштовуєте повний, повністю функціональний поштовий сервер, параметри конфігурації, які ви використовуватимете, не такі великі. Перше, що потрібно зробити, це змінити файл _main.cf_ (буквально, головний файл конфігурації для `postfix`). Спочатку зробіть резервну копію:

`cp /etc/postfix/main.cf /etc/postfix/main.cf.bak`

Потім відредагуйте його:

`vi /etc/postfix/main.cf`

У нашому прикладі ім’я нашого сервера — «bruno», а ім’я домену — «ourdomain.com». Знайдіть у файлі рядок:

`#myhostname = host.domain.tld`

Ви можете видалити примітку (#) або додати новий рядок під цим рядком. На основі нашого прикладу рядок буде виглядати так:

`myhostname = bruno.ourdomain.com`

Далі знайдіть рядок для доменного імені:

`#mydomain = domain.tld`

Або видаліть зауваження та змініть його, або додайте новий рядок:

`mydomain = ourdomain.com`

Нарешті, перейдіть у нижню частину файлу та додайте цей рядок:

`smtp_generic_maps = hash:/etc/postfix/generic`

Збережіть зміни (у vi це буде `Shift : wq!`) і закрийте файл.

Перш ніж продовжити редагування загального файлу, вам потрібно побачити, як виглядатиме електронний лист. Зокрема, вам потрібно створити "загальний" файл, на який ви посилалися у файлі _main.cf_ вище:

`vi /etc/postfix/generic`

Цей файл повідомляє `postfix`, як виглядатиме будь-який електронний лист, що надходить з цього сервера. Пам’ятаєте наш тестовий електронний лист і файл журналу? Тут ми все виправляємо:

```bash
root@somehost.localdomain       root@bruno.ourdomain.com
@somehost.localdomain           root@bruno.ourdomain.com
```

Далі вам потрібно вказати `postfix` використовувати всі наші зміни. Це робиться за допомогою команди postmap:

`postmap /etc/postfix/generic`

Запустіть `postfix` та знову перевірте свою електронну пошту, виконавши ту саму процедуру, що й вище. Тепер ви побачите, що всі екземпляри "localdomain" тепер є фактичним доменом.

### Команда `date` і змінна, яка називається today

Не кожна програма використовуватиме однаковий формат дати. Можливо, вам доведеться проявити креативність до будь-якого сценарію, який ви пишете для звітності за датою.

Скажімо, ви хочете переглянути свій системний журнал як приклад, витягніть усе, що стосується dbus-daemon на сьогоднішню дату, і надішліть це собі електронною поштою. (Це, мабуть, не найкращий приклад, але він дасть вам уявлення про те, як ви можете це зробити.)

Вам потрібно використовувати змінну у вашому скрипті. Назвіть це "today". Ви хочете, щоб він пов'язувався з виводом команди "date" та форматувався певним чином, щоб ви могли отримати потрібні дані з нашого системного журналу (у _/var/log/messages_). Для початку проведемо розслідування.

Спочатку введіть команду date в командному рядку:

`date`

Це дасть вам вихід системної дати за замовчуванням, який може виглядати приблизно так:

`Thu Mar  4 18:52:28 UTC 2021`

Перевірте наш системний журнал і подивіться, як він записує інформацію. Для цього скористайтеся командами `more` та `grep`:

`more /var/log/messages | grep dbus-daemon`

Що має дати вам щось на зразок цього:

```bash
Mar  4 18:23:53 hedgehogct dbus-daemon[60]: [system] Successfully activated service 'org.freedesktop.nm_dispatcher'
Mar  4 18:50:41 hedgehogct dbus-daemon[60]: [system] Activating via systemd: service name='org.freedesktop.nm_dispatcher' unit='dbus-org.freedesktop.nm-dispatcher.service' requested by ':1.1' (uid=0 pid=61 comm="/usr/sbin/NetworkManager --no-daemon " label="unconfined")
Mar  4 18:50:41 hedgehogct dbus-daemon[60]: [system] Successfully activated service 'org.freedesktop.nm_dispatcher
```

Дата та вихідні дані журналу мають бути точно однаковими в нашому сценарії. Давайте розглянемо, як відформатувати дату за допомогою змінної під назвою "today".

Перевірте, що вам потрібно зробити з датою, щоб отримати той самий результат, що й системний журнал. Ви можете звернутися до [довідкової сторінки Linux](https://man7.org/linux/man-pages/man1/date.1.html) або ввести `man date` у командному рядку, щоб відкрити сторінку довідки з дати та отримати потрібну інформацію.

Що ви знайдете, це форматувати дату так само, як _/var/log/messages_ , вам потрібно використовувати рядки формату %b і %e з %b це місяць із 3 символів, а %e — день із пробілами.

### Сценарій

Для нашого bash-скрипта, як ви можете бачити, ви збираєтеся використовувати команду `date` та змінну з назвою "today". (Майте на увазі, що "today" є довільним. Ви можете назвати цю змінну "late_for_dinner", якщо хочете!). У цьому прикладі ви викличете свій скрипт `test.sh` та помістите його в _/usr/local/sbin_:

`vi /usr/local/sbin/test.sh`

На початку зауважте, що хоча коментар у нашому файлі говорить, що ви надсилаєте ці повідомлення на електронну пошту, наразі ви просто надсилаєте їх у стандартний вихід журналу, щоб перевірити, чи вони правильні.

Крім того, у нашій першій спробі ви захоплюєте всі повідомлення на поточну дату, а не лише повідомлення dbus-daemon. Ви незабаром розберетеся з цим.

Майте на увазі, що команда `grep` поверне ім'я файлу у виводі, що вам у цьому випадку не знадобиться. Щоб видалити це, додайте опцію "-h" до grep. Крім того, коли ви встановлюєте змінну "today", вам потрібно шукати всю змінну як рядок, для якого потрібен рядок у лапках:

```bash
#!/bin/bash

# set the date string to match /var/log/messages
today=`date +"%b %e"`

# grab the dbus-daemon messages and send them to email
grep -h "$today" /var/log/messages
```

Наразі це все. Збережіть зміни та зробіть сценарій виконуваним:

`chmod +x /usr/local/sbin/test.sh`

А потім перевірте:

`/usr/local/sbin/test.sh`

Якщо все працює правильно, ви отримаєте довгий список усіх повідомлень у _/var/log/messages_ за сьогодні, включаючи, але не обмежуючись повідомленнями dbus-daemon. Наступним кроком є обмеження повідомлень повідомленнями демона dbus. Знову змініть сценарій:

`vi /usr/local/sbin/test.sh`

```bash
#!/bin/bash

# set the date string to match /var/log/messages
today=`date +"%b %e"`

# grab the dbus-daemon messages and send them to email
grep -h "$today" /var/log/messages | grep dbus-daemon
```

Повторний запуск сценарію призведе до отримання лише повідомлень демона dbus і тих, які виникли сьогодні.

Однак є ще один останній крок. Пам’ятайте, вам потрібно надіслати це електронною поштою адміністратору для перевірки. Оскільки ви використовуєте `postfix` на цьому сервері лише для звітності, ви не хочете залишати службу запущеною. Запускайте його на початку сценарію та зупиняйте в кінці. Тут команда `sleep` призупиняється на 20 секунд, забезпечуючи надсилання електронного листа перед повторним вимкненням `postfix`. Це остаточне редагування додає проблеми зупинки, запуску та сну, які щойно обговорювалися, а також передає вміст на електронну пошту адміністратора.

`vi /usr/local/sbin/test.sh`

І змініть сценарій:

```bash
#!/bin/bash

# start postfix
/usr/bin/systemctl start postfix

# set the date string to match /var/log/messages
today=`date +"%b %e"`

# grab the dbus-daemon messages and send them to email
grep -h "$today" /var/log/messages | grep dbus-daemon | mail -s "dbus-daemon messages for today" myname@mydomain.com

# make sure the email has finished before continuing
sleep 20

# stop postfix
/usr/bin/systemctl stop postfix
```

Запустіть сценарій знову, і тепер ви повинні отримати електронний лист від сервера з повідомленням dbus-daemon.

Тепер ви можете використовувати [crontab](../automation/cron_jobs_howto.md), щоб запланувати його виконання в певний час.

## Висновок

Використання `postfix` може допомогти вам відстежувати журнали процесів, які ви хочете контролювати. Ви можете використовувати його разом із сценаріями bash, щоб отримати чітке розуміння системних процесів і бути поінформованим у разі виникнення проблем.
