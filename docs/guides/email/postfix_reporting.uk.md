---
title: Звітування про процес Postfix
author: Steven Spencer
contributors: Ezequiel Bruni
tested_with: 8.5, 8.6, 9.0
tags:
  - email
  - звіти
  - інструменти
---

# Використання `postfix` для звітування про процеси сервера

## Передумови

* Повний комфорт роботи з командного рядка на сервері Rocky Linux
* Знайомство з редактором на ваш вибір (у цьому документі використовується редактор _vi_, але ви можете замінити його улюбленим редактором)
* Розуміння DNS (системи доменних імен) та імен хостів
* Можливість призначати змінні в сценарії bash
* Знання того, що роблять команди _tail_, _more_, _grep_ і _date_

## Вступ

Багато адміністраторів серверів Rocky Linux пишуть сценарії для виконання певних завдань, таких як резервне копіювання або синхронізація файлів, і багато з цих сценаріїв створюють журнали, які містять корисну, а часом і дуже важливу інформацію. Однак мати лише журнали недостатньо. Якщо процес дає збій і реєструє цю помилку, але зайнятий адміністратор не переглядає журнал, тоді може бути катастрофа.

У цьому документі показано, як використовувати `postfix` MTA (агент передачі пошти), щоб отримати подробиці журналу з певного процесу та надіслати їх вам електронною поштою. Він також торкається форматів дати в журналах і допомагає визначити, який формат використовувати в процедурі звітування.

Пам’ятайте, що це лише верхівка айсберга щодо того, що ви можете зробити, створюючи звіти за допомогою `postfix`. Зауважте, що обмежити запущені процеси лише тими, які вам будуть потрібні постійно, завжди є хорошим заходом безпеки.

У цьому документі показано, як увімкнути Postfix лише для звітів, які вам потрібні, а потім знову вимкнути його.

## Визначення `postfix`

Postfix — це серверний демон, який використовується для надсилання електронної пошти. Це більш безпечний і зрозумілий, ніж sendmail, ще один MTA, який роками використовувався за умовчанням. Ви можете використовувати його як частину повнофункціонального поштового сервера.

## Встановлення `postfix`

Окрім `postfix`, вам знадобиться `mailx`, щоб перевірити вашу здатність надсилати електронні листи. Щоб установити ці та будь-які необхідні залежності, введіть наступне в командному рядку сервера Rocky Linux:

`dnf install postfix mailx`

!!! warning "Зміни у Rocky Linux 9.0"

    Ця процедура чудово працює в Rocky Linux 9.0. Різниця тут полягає в тому, звідки походить команда `mailx`. Хоча ви можете встановити його за назвою у 8.x, `mailx` походить із пакета appstream `s-nail` у 9.0. Щоб встановити необхідні пакети, потрібно використовувати:

    ```
    dnf install postfix s-nail
    ```

## Тестування та налаштування `postfix`

### Тестування пошти

Перш ніж налаштувати `postfix`, вам потрібно дізнатися, як виглядатиме пошта, коли вона залишає сервер, оскільки ви, ймовірно, захочете це змінити. Для цього запустіть `postfix`:

`systemctl start postfix`

Перевірте за допомогою `mail`, наданого `mailx` (або `s-nail`):

`mail -s "Testing from server" myname@mydomain.com`

Це відобразить порожній рядок. Введіть своє тестове повідомлення тут:

`testing from the server`

Тепер натисніть enter і введіть одну крапку:

`.`

Система відповість наступним чином:

`EOT`

Мета цього — побачити, як виглядає наша пошта для зовнішнього світу. Ви можете відчути це з _maillog_, який стає активним із запуском `postfix`.

Використовуйте цю команду, щоб переглянути вихідні дані файлу журналу:

`tail /var/log/maillog`

Ви побачите щось подібне, хоча файл журналу матиме різні домени для адреси електронної пошти та інших елементів:

```
Mar  4 16:51:40 hedgehogct postfix/postfix-script[735]: starting the Postfix mail system
Mar  4 16:51:40 hedgehogct postfix/master[737]: daemon started -- version 3.3.1, configuration /etc/postfix
Mar  4 16:52:04 hedgehogct postfix/pickup[738]: C9D42EC0ADD: uid=0 from=<root>
Mar  4 16:52:04 hedgehogct postfix/cleanup[743]: C9D42EC0ADD: message-id=<20210304165204.C9D42EC0ADD@somehost.localdomain>
Mar  4 16:52:04 hedgehogct postfix/qmgr[739]: C9D42EC0ADD: from=<root@somehost.localdomain>, size=457, nrcpt=1 (queue active)
Mar  4 16:52:05 hedgehogct postfix/smtp[745]: connect to gmail-smtp-in.l.google.com[2607:f8b0:4001:c03::1a]:25: Network is unreachable
Mar  4 16:52:06 hedgehogct postfix/smtp[745]: C9D42EC0ADD: to=<myname@mydomain.com>, relay=gmail-smtp-in.l.google.com[172.217.212.26]
:25, delay=1.4, delays=0.02/0.02/0.99/0.32, dsn=2.0.0, status=sent (250 2.0.0 OK  1614876726 z8si17418573ilq.142 - gsmtp)
Mar  4 16:52:06 hedgehogct postfix/qmgr[739]: C9D42EC0ADD: removed
```
"somehost.localdomain" показує, що вам потрібно внести зміни. Спочатку зупиніть демон `postfix`:

`systemctl stop postfix`

## Налаштування `postfix`

Оскільки ви не налаштовуєте повний, повністю функціональний поштовий сервер, параметри конфігурації, які ви використовуватимете, не такі великі. Перше, що потрібно зробити, це змінити файл _main.cf_ (буквально основний файл конфігурації для `postfix`). Спочатку зробіть резервну копію:

`cp /etc/postfix/main.cf /etc/postfix/main.cf.bak`

Потім відредагуйте його:

`vi /etc/postfix/main.cf`

У нашому прикладі ім’я нашого сервера — «bruno», а ім’я домену — «ourdomain.com». Знайдіть у файлі рядок:

`#myhostname = host.domain.tld`

Ви можете видалити примітку (#) або додати новий рядок під цим рядком. На основі нашого прикладу рядок буде виглядати так:

`myhostname = bruno.ourdomain.com`

Далі знайдіть рядок для доменного імені:

`#mydomain = domain.tld`

Або видаліть зауваження та змініть його, або додайте новий рядок:

`mydomain = ourdomain.com`

Нарешті, перейдіть у нижню частину файлу та додайте цей рядок:

`smtp_generic_maps = hash:/etc/postfix/generic`

Збережіть зміни (у vi це буде `Shift : wq!`) і закрийте файл.

Перш ніж редагувати загальний файл, ви повинні побачити, як буде виглядати електронний лист. Зокрема, ви хочете створити «загальний» файл, на який ви посилалися у файлі _main.cf_ вище:

`vi /etc/postfix/generic`

Цей файл повідомляє `postfix`, як виглядатиме будь-який електронний лист із цього сервера. Пам’ятаєте наш тестовий електронний лист і файл журналу? Тут ми все виправляємо:

```
root@somehost.localdomain       root@bruno.ourdomain.com
@somehost.localdomain           root@bruno.ourdomain.com
```
Далі вам потрібно вказати `postfix` використовувати всі наші зміни. Це робиться за допомогою команди postmap:

`postmap /etc/postfix/generic`

Запустіть `postfix` і знову перевірте свою електронну пошту за допомогою описаної вище процедури. Тепер ви побачите, що всі екземпляри "localdomain" тепер є фактичним доменом.

### Команда `date` і змінна, яка називається today

Не кожна програма використовуватиме той самий формат журналювання для дати. Можливо, вам доведеться підійти творчо до будь-якого сценарію, який ви створите для звітування за датою.

Скажімо, ви хочете переглянути свій системний журнал як приклад, витягніть усе, що стосується dbus-daemon на сьогоднішню дату, і надішліть це собі електронною поштою. (Це, мабуть, не найкращий приклад, але він дасть вам уявлення про те, як ви можете це зробити.)

Вам потрібно використовувати змінну у вашому сценарії. Назвіть це "today". Ви хочете, щоб він стосувався виводу команди "date" і форматував його в певний спосіб, щоб ви могли отримати потрібні дані з нашого системного журналу (у _/var/log /повідомлення_). Для початку проведіть пошукову роботу.

Спочатку введіть команду date в командному рядку:

`date`

Це дасть вам вихід системної дати за замовчуванням, який може виглядати приблизно так:

`Thu Mar  4 18:52:28 UTC 2021`

Перевірте наш системний журнал і подивіться, як він записує інформацію. Для цього скористайтеся командами `more` та `grep`:

`more /var/log/messages | grep dbus-daemon`

Що має дати вам щось на зразок цього:

```
Mar  4 18:23:53 hedgehogct dbus-daemon[60]: [system] Successfully activated service 'org.freedesktop.nm_dispatcher'
Mar  4 18:50:41 hedgehogct dbus-daemon[60]: [system] Activating via systemd: service name='org.freedesktop.nm_dispatcher' unit='dbus-org.freedesktop.nm-dispatcher.service' requested by ':1.1' (uid=0 pid=61 comm="/usr/sbin/NetworkManager --no-daemon " label="unconfined")
Mar  4 18:50:41 hedgehogct dbus-daemon[60]: [system] Successfully activated service 'org.freedesktop.nm_dispatcher
```

Дата та вихідні дані журналу мають бути точно однаковими в нашому сценарії. Давайте подивимося, як відформатувати дату за допомогою змінної під назвою "today".

Перевірте, що вам потрібно зробити з датою, щоб отримати той самий результат, що й системний журнал. Ви можете посилатися на [довідкову сторінку Linux](https://man7.org/linux/man-pages/man1/date.1.html) або ввести `man-date` у командному рядку, щоб відкрити сторінку посібника з датою та отримати потрібну інформацію.

Що ви знайдете, це форматувати дату так само, як _/var/log/messages_ , вам потрібно використовувати рядки формату %b і %e з %b це місяць із 3 символів, а %e — день із пробілами.

### Сценарій

Для нашого сценарію bash ви бачите, що ви збираєтеся використовувати команду `date` і змінну під назвою «сьогодні». (Майте на увазі, що "today" є довільним. Ви можете назвати цю змінну "late_for_dinner", якщо хочете!). Ви викличете свій сценарій у цьому прикладі `test.sh` і розмістите його в _/usr/local/sbin_:

`vi /usr/local/sbin/test.sh`

На початку зауважте, що хоча коментар у нашому файлі говорить, що ви надсилаєте ці повідомлення на електронну пошту, наразі ви просто надсилаєте їх у стандартний вихід журналу, щоб перевірити, чи вони правильні.

Крім того, у нашій першій спробі ви захоплюєте всі повідомлення на поточну дату, а не лише повідомлення dbus-daemon. Ви незабаром розберетеся з цим.

Майте на увазі, що команда `grep` поверне ім'я файлу у вихідних даних, що вам не потрібно в цьому випадку. Щоб видалити це, додайте опцію "-h" до grep. Крім того, коли ви встановлюєте змінну «сьогодні», вам потрібно шукати всю змінну як рядок, для якого потрібен рядок у лапках:

```
#!/bin/bash

# встановити рядок дати відповідно до /var/log/messages
сьогодні=`дата +"%b %e"`

# отримати повідомлення dbus-daemon і надіслати їх електронною поштою
grep -h "$today" /var/log/messages
```

Наразі це все. Збережіть зміни та зробіть сценарій виконуваним:

`chmod +x /usr/local/sbin/test.sh`

А потім перевірте:

`/usr/local/sbin/test.sh`

Якщо все працює правильно, ви отримаєте довгий список усіх повідомлень у _/var/log/messages_ від сьогодні, включаючи, але не обмежуючись повідомленнями dbus-daemon. Наступним кроком є обмеження повідомлень повідомленнями демона dbus. Знову змініть сценарій:

`vi /usr/local/sbin/test.sh`

```
#!/bin/bash

# встановити рядок дати відповідно до /var/log/messages
сьогодні=`дата +"%b %e"`

# отримати повідомлення dbus-daemon і надіслати їх електронною поштою
grep -h "$today" /var/log/messages | grep dbus-демон
```

Повторний запуск сценарію призведе до отримання лише повідомлень демона dbus і тих, які виникли сьогодні.

Однак є ще один останній крок. Пам’ятайте, вам потрібно надіслати це електронною поштою адміністратору для перевірки. Ви не хочете залишати службу запущеною, тому що ви використовуєте лише `postfix` на цьому сервері для звітування. Запускайте його на початку сценарію та зупиняйте в кінці. Тут команда `sleep` призупиняється на 20 секунд, забезпечуючи надсилання електронної пошти перед повторним вимкненням `postfix`. Це остаточне редагування додає проблеми зупинки, запуску та сну, які щойно обговорювалися, а також передає вміст на електронну пошту адміністратора.

`vi /usr/local/sbin/test.sh`

І змініть сценарій:

```
#!/bin/bash

# запуск postfix
/usr/bin/systemctl start postfix

# встановити рядок дати відповідно до /var/log/messages
today=`date +"%b %e"`

# візьміть повідомлення dbus-daemon і надішліть їх електронною поштою
grep -h "$today" /var/log/messages | grep dbus-daemon | mail -s "dbus-daemon messages for today" myname@mydomain.com

# перш ніж продовжити, переконайтеся, що електронний лист закінчено
sleep 20

# зупинити postfix
/usr/bin/systemctl stop postfix
```

Запустіть сценарій знову, і тепер ви повинні отримати електронний лист від сервера з повідомленням dbus-daemon.

Тепер ви можете використовувати [crontab](../automation/cron_jobs_howto.md), щоб запланувати його виконання в певний час.

## Висновок

Використання `postfix` може допомогти вам відстежувати журнали процесів, які ви хочете контролювати. Ви можете використовувати його разом із сценаріями bash, щоб отримати чітке розуміння системних процесів і бути поінформованим у разі виникнення проблем.
