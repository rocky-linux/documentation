---
title: 사용자 지정 Linux 커널 빌드 및 설치
author: Wale Soyinka
contributors: Steven Spencer, Louis Abel
tags:
  - 커스텀 커널
  - 커널
---

# 개요
이 가이드에서는 커널 소스 트리를 획득하고, 구성하고, 컴파일하고, 마지막으로 커널을 설치하고 부팅하는 과정을 안내합니다.

!!! warning "Rocky Linux에서는 커널 재빌드를 권장하거나 지원하지 않습니다. 사용자 정의 커널을 빌드하기 전에 다음 질문을 스스로에게 물어보십시오."

    * [elrepo](https://elrepo.org)에서 커널 모듈을 설치하여 필요한 기능을 사용할 수 있습니까?
    * 필요한 기능이 커널 자체의 별도 모듈로 제공됩니까?
    * 직접 보안을 유지하려는 의지가 있습니까?
    * **확실합니까**? Rocky Linux와 대부분의 다른 EL 파생 배포판은 완전한 환경으로 작동하도록 설계되었습니다. 중요한 구성 요소를 대체하면 시스템 작동에 영향을 줄 수 있습니다.
    * **확실히 필요합니까**? 99.9%의 사용자는 더 이상 자체 커널을 빌드할 필요가 없습니다. 커널 모듈/드라이버만 필요할 수도 있으며, 이 경우 [elrepo](https://elrepo.org)를 사용하거나 자체 커널 모듈(kmod/dkms)을 빌드할 수 있습니다.
    * **그저 더 최신 커널 버전이 필요한 것은 아닌지 확인하셨습니까**? 최신 커널은 [elrepo](https://elrepo.org)에서 찾을 수 있습니다.

    마지막으로 경고합니다: 커널을 손상시키면 시스템에 대한 책임이 발생합니다. Rocky Linux 봉사자 또는 개발자는 이러한 문제에 대해 지원할 수 없습니다.

## 커널

대부분의 경우, 사람들이 _Linux_ 이라고 말할 때 그들은 일반적으로 "_Linux 배포판_"을 의미합니다. 예를 들어, Rocky Linux와 Debian은 Linux 배포판의 종류입니다. 배포판은 Linux을 기능적인 운영 체제로 사용하기 위해 필요한 모든 것을 포함합니다. 배포판은 Linux과 독립적인 다양한 오픈 소스 프로젝트의 코드를 사용합니다.

Linux은 커널입니다. 커널은 말 그대로 [운영 체제]의 핵심에 위치합니다.

커널보다 더 기본적인 것은 시스템 하드웨어 자체입니다. 커널은 완전한 Linux 배포판의 작은 부분이지만, 훨씬 중요한 요소입니다. 커널이 실패하거나 충돌하면 시스템의 나머지 부분도 영향을 받습니다.


## 커널 소스 코드

Rocky Linux 배포판은 지원하는 특정 커널 버전의 소스 코드를 한 형태 또는 다른 형태로 제공합니다. 이는 컴파일된 이진 파일 (*.src.rpm), 소스 RPM (*.srpm) 등의 형태로 제공될 수 있습니다.

특정 Rocky Linux 배포판에서 제공하는 것과 다른 (보다 최신) 버전을 다운로드해야 할 경우, 소스 코드를 찾을 수 있는 첫 번째 장소는 공식 커널 웹사이트입니다:

[www.kernel.org](https://www.kernel.org)

이 사이트는 커널 소스를 포함하여 다양한 오픈 소스 소프트웨어, 배포판 및 일반적인 유틸리티의 웹 사이트를 유지 관리합니다.

거울 웹 사이트 목록은 다음 위치에서 유지 관리됩니다:

[mirrors.kernel.org](http://mirrors.kernel.org)


!!! tip "팁"

    다음 섹션에서 수행한 Linux 커널 다운로드, 구성 및 컴파일의 대부분은 권한 없는 사용자로서 수행할 수 있습니다. 그러나 시스템 파일 및 이진 파일을 실제 설치하거나 변경해야 하는 마지막 단계는 높은 권한으로 수행해야 합니다.
    
    사용자 지정 작업 또는 출력 디렉터리를 지정할 수 있는 특수 커널 빌드 옵션을 사용하기 때문에 권한 없는 사용자로서 대부분의 작업을 수행할 수 있습니다. 구체적으로, 우리는 'O=~/build/kernel' 옵션을 적용 가능한 모든 make 호출에 사용할 것입니다.
    
    여기서 '~/build/kernel'은 '/home/$USER/build/kernel' 또는 '$HOME/build/kernel'과 동일합니다

## 커널 버전 및 명명 규칙

사용 가능한 커널 목록 웹 사이트에는 v1.0, v2.5, v2.6, v3.0, v3.x, v4.x, v5.x, v6.x 등의 폴더가 포함됩니다. 최신 버전을 얻기 위해 자연스러운 경향에 따르기 전에 Linux 커널 버전 관리 시스템이 어떻게 작동하는지 이해해야 합니다.

현재의 규칙은 주요 새로운 커널 릴리스를 "Linux 5.x"로 이름 지정하고 번호를 매기는 것입니다 (또는 vanilla 또는 mainline 커널이라고도 함). 따라서 이 시리즈의 첫 번째 버전은 Linux 버전 5.0 (5.0.0과 동일), 다음 버전은 Linux 버전 5.1 (5.1.0과 동일), 그 다음은 Linux 버전 5.2 등입니다.

각 주요 릴리스 버전 내에서의 작은 변경 또는 업데이트는 세 번째 숫자의 증가로 반영됩니다. 이는 안정된 포인트 릴리스로 일반적으로 언급됩니다. 따라서 5.0.0 시리즈 커널의 다음 안정된 포인트 릴리스는 Linux 버전 5.0.1이고, 그 다음은 버전 5.0.2 등입니다. 다른 방식으로 말하면, Linux 버전 5.0.4는 Linux 5.0.0 시리즈를 기반으로 한 네 번째 안정 릴리스라고 할 수 있습니다.

## 사전 요구 도구 및 라이브러리 설치

커널 빌드 프로세스 중 발생할 수 있는 실패의 일반적인 원인은 주요 Linux 커널을 컴파일하고 빌드하기 위한 필요한 소프트웨어가 모두 설치되어 있지 않은 경우입니다.  DNF 패키지 관리자를 사용하여 Rocky Linux 배포판에 소프트웨어 도구 및 라이브러리를 설치할 수 있습니다. 이를 위해 다음 섹션에서 처리하겠습니다.

1. Rocky Linux 배포판에서 다음 명령을 실행하여 필요한 대부분의 개발 도구를 빠르게 설치할 수 있습니다:

    ```
    > sudo dnf -y groupinstall 'C Development Tools and Libraries'
    ```

    'Module or Group 'C Development Tools and Libraries' is not available.' 오류가 발생하는 경우 아래 명령이 위의 명령과 동일합니다:

    ```
    > sudo dnf -y groupinstall 'Development Tools'
    ```

2. 다음 패키지를 설치하여 필요한 다른 라이브러리, 헤더 파일 및 응용 프로그램을 얻을 수도 있습니다. 다음을 입력하세요.

    ```
    > sudo dnf -y install \
    ncurses-devel openssl-devel elfutils-libelf-devel python3
    ```

3. 다음으로 지원되는 일부 타사 리포지토리에서만 사용할 수 있는 다른 유틸리티가 필요합니다. 이러한 리포지토리 중 하나는 Powertools 리포지토리입니다. Rocky 시스템에서 해당 저장소를 활성화합시다. 다음을 입력하세요.

    ```
    > sudo dnf config-manager --set-enabled powertools
    ```

4. Rocky 배포판에서 몇 가지 추가 사용자 정의를 완료해야 합니다. 다음을 입력하세요:

    ```
    > sudo  dnf -y install dwarves
    ```

실제 커널 빌드에 필요한 전제 조건 패키지는 여기까지입니다!

## Linux 커널 다운로드 및 압축 풀기

다음 섹션에서 빌드할 커널 버전은 버전 5.16.9이며 다음 위치에서 사용할 수 있습니다.

[www.kernel.org/pub/linux/kernel/v5.x/linux-5.16.9.tar.xz](https://www.kernel.org/pub/linux/kernel/v5.x/linux-5.16.9.tar.xz)

프로세스를 시작하겠습니다.

1. 먼저 다음 curl 명령을 사용하여 필요한 커널 소스를 현재 작업 디렉터리에 다운로드합니다. 다음을 입력하세요,

    ```
    curl -L -o linux-5.16.9.tar.xz \
    https://www.kernel.org/pub/linux/kernel/v5.x/linux-5.16.9.tar.xz
    ```

2. 인터넷에서 다운로드할 커널 소스는 압축 및 tar 처리된 파일입니다. 따라서 소스를 사용하려면 소스 파일의 압축을 풀고 압축을 풀어야 합니다.

    커널 tarball을 다운로드하는 디렉토리에 있는지 확인하십시오. tar 명령을 사용하여 다음을 실행하여 파일의 압축을 풀고 압축을 풉니다.

    ```
    tar xvJf linux-5.*.tar.xz
    ```

## 커널 빌드

이 섹션에서는 커널을 구성하고 빌드하는 과정을 검토합니다. 이는 macOS나 Windows 기반 운영 체제와는 대조적으로, 미리 구성되어 다양한 기능을 지원합니다.

리눅스 디자인 철학은 개인이 커널의 중요한 부분을 결정할 수 있도록 해줍니다. 이러한 개별화된 설계는 Linux를 최대한 효율적으로 실행할 수 있도록 기능 목록을 축소할 수 있도록 하는 중요한 이점이 있습니다.

이것은 또한 Linux를 저사양 시스템부터 임베디드 시스템, 고성능 시스템까지 다양한 하드웨어 구성에서 실행할 수 있도록 사용자 정의할 수 있는 이유 중 하나입니다.

커널을 빌드하는 데는 두 가지 주요 단계가 필요합니다:

- 구성
- 컴파일

커널을 빌드하기 위한 첫 번째 단계는 기능을 구성하는 것입니다. 일반적으로 원하는 기능 목록은 지원해야 할 하드웨어에 따라 결정됩니다. 이는 당연히 해당 하드웨어의 목록이 필요하다는 것을 의미합니다.

Linux를 이미 실행 중인 시스템에서는 lspci, lshw 등의 명령을 실행하여 시스템의 정확한 하드웨어 구성에 대한 자세한 정보를 표시할 수 있습니다. RPM 기반 배포판에서는 이러한 유틸리티가 pciutils*.rpm 및 lshw*.rpm 패키지에 포함되어 제공됩니다.

기본 하드웨어 구성 요소를 더 잘 이해하면 사용자 정의 커널에 필요한 요소를 더욱 잘 판단할 수 있습니다. 이제 커널을 구성하기 시작할 준비가 되었습니다.

### 빌드 환경 정리

새로운 커널이 지원해야 할 하드웨어 유형과 기능의 대략적인 개념을 가지고 있으므로 실제 구성을 시작할 수 있습니다. 하지만 먼저 약간의 배경 정보가 필요합니다.

Linux 커널 소스 트리에는 Makefile이라는 이름의 여러 파일이 포함되어 있습니다. (makefile은 단순한 지시문이 있는 텍스트 파일로, 프로그램의 파일 간 관계를 설명합니다).

These makefiles help to glue together the thousands of other files that make up the kernel source. 우리에게 더 중요한 것은 makefile에 목표(target)가 포함되어 있다는 사실입니다. 목표는 make 프로그램에서 실행되는 명령이나 지시문입니다.


!!! warning "경고: 불필요한 커널 업그레이드 피하기"

    안정적이고 잘 작동하는 시스템이 이미 있는 경우, 다음 조건 중 하나가 해당되지 않는 한 커널을 업그레이드할 이유는 거의 없습니다:

    - 시스템에 영향을 미치는 보안 또는 버그 수정이 필요한 경우
    - 안정된 릴리스에서 특정 새로운 기능이 필요한 경우

    보안 수정의 경우, 실제로 영향을 받는 위험 여부를 결정하세요. 예를 들어, 사용하지 않는 디바이스 드라이버에서 보안 문제가 발견된 경우, 업그레이드할 이유가 없을 수 있습니다. 버그 수정 릴리스의 경우, 릴리스 노트를 주의 깊게 읽고 해당 버그가 실제로 영향을 미치는지 결정하세요. 안정된 시스템이 있다면 사용하지 않는 패치로 커널을 업그레이드하는 것은 무의미할 수 있습니다.

    운영 시스템에서 커널을 최신 상태로 유지하기 위해 간단히 "최신 커널"을 업그레이드해서는 안 됩니다. 업그레이드할 충분한 이유가 있어야 합니다.

커널 소스 트리의 루트에 있는 Makefile에는 커널 빌드 환경을 준비하고, 커널을 구성하고, 커널을 컴파일하고, 커널을 설치하는 등 특정 목표가 포함되어 있습니다. 여기에서는 일부 목표에 대해 더 자세히 설명합니다.

- **make mrproper** 이 목표는 이전 커널 빌드에서 남은 오래된 파일과 종속성을 빌드 환경에서 정리합니다. 이전 커널 구성은 빌드 환경에서 정리(삭제)됩니다.
- **make clean** 이 목표는 mrproper 목표만큼 철저한 작업을 수행하지 않습니다. 대부분의 생성된 파일만 삭제합니다. 커널 구성 파일 (.config)은 삭제하지 않습니다.
- **make menuconfig** 이 목표는 메뉴와 옵션 목록, 텍스트 기반 대화 상자를 사용하여 커널을 구성하는 텍스트 기반 편집기 인터페이스를 호출합니다.
- **make xconfig** 이는 Qt 그래픽 개발 라이브러리를 사용하는 GUI 기반 커널 구성 도구/목표입니다. 이 라이브러리는 KDE/Plasma 기반 애플리케이션에서 사용됩니다.
- **make gconfig** 이것도 GUI 기반 커널 구성 도구/목표이지만 GTK+ 툴킷을 사용합니다. 이 GTK 툴킷은 GNOME 데스크톱 환경에서 널리 사용됩니다.
- **make olddefconfig** 이 목표는 현재 작업 디렉터리의 기존 .config 파일을 사용하고 종속성을 업데이트하며 새로운 심볼을 자동으로 기본 값으로 설정합니다.
- **make help** 이 목표는 다른 모든 make 목표를 보여주며 빠른 온라인 도움말 시스템으로 사용됩니다.

이 섹션에서 커널을 구성하기 위해 여러 목표 중 하나만 사용할 것입니다. 특히 make menuconfig 명령을 사용할 것입니다. menuconfig 커널 구성 편집기는 메뉴, 라디오 버튼 목록 및 대화 상자로 구성된 간단하고 인기 있는 텍스트 기반 구성 유틸리티입니다.

이 편집기는 키보드로 쉽게 탐색할 수 있는 간단하고 깔끔한 인터페이스를 가지고 있으며 거의 직관적으로 사용할 수 있습니다.

커널 소스 디렉토리로 변경(cd)해야 커널 구성을 시작할 수 있습니다. 그러나 실제 커널 구성을 시작하기 전에 make mrproperty 명령을 사용하여 커널 빌드 환경을 정리(준비)해야 합니다:

```
> cd linux-5.*
> make  O=~/build/kernel mrproper
```

### 커널 구성

다음으로, Linux 5.* 시리즈 커널의 구성 과정을 따라가보겠습니다. 이 과정의 일부 내용을 살펴보기 위해, 시스템에서 반드시 가져야 하는 특정 기능을 지원하도록 설정해볼 것입니다. 이 작업 방법을 이해하면 다른 원하는 새로운 커널 기능을 지원하기 위해 동일한 절차를 적용할 수 있습니다. 특히, 사용자 정의 커널에 NTFS 파일 시스템 지원을 활성화할 것입니다.

대부분의 현대적인 Linux 배포판은 로컬 파일 시스템에 압축 또는 일반 파일로 있는 실행 중인 커널의 구성 파일을 함께 제공합니다. 예를 들어, 샘플 Rocky 시스템에서 이 파일은 /boot 디렉터리에 위치하며 일반적으로 config-4.*와 같은 이름으로 지정됩니다.

The configuration file contains a list of the options and features that were enabled for the particular kernel it represents. 우리는 이러한 커널 구성 과정을 통해 생성할 파일이 이와 유사하도록 만들기를 원합니다. 생성할 파일과 준비된 파일의 유일한 차이점은 우리가 우리의 파일에 추가적인 소소한 사용자 정의를 추가한다는 것입니다.


!!! tip "팁"

    알려진, 기존의 구성 파일을 프레임워크로 사용하여 우리만의 사용자 정의 파일을 만드는 것은 다른 사람들이 이미 동작하는지 여부를 찾기 위해 소모한 노력을 중복해서 낭비하지 않도록 도와줍니다!

다음 단계에서는 커널을 구성하는 방법을 다룹니다. GUI 데스크톱 환경을 사용하든 않던지에 상관없이 터미널에서 따라 할 수 있는 텍스트 기반 커널 구성 도구를 사용할 것입니다.

1. 먼저, 기존의 구성 파일을 /boot 디렉터리에서 우리의 커널 빌드 환경으로 복사하고 이름을 바꿉니다:
    ```
    > cp /boot/config-`uname -r` ~/build/kernel/.config
    ```
    여기서 `uname -r`을 사용하여 실행 중인 커널의 구성 파일을 얻습니다. uname -r 명령은 실행 중인 커널의 릴리스를 출력합니다. 이를 사용하여 원하는 정확한 버전을 가져올 수 있도록 해주어 다른 버전이 존재할 경우에도 정확한 버전을 얻게 됩니다.

    !!! 참고사항

     Linux 커널 구성 편집기는 명시적으로 커널 소스 트리의 루트에 .config (도트 컨피그라고 읽음)라는 이름의 파일을 찾아 생성하도록 시작됩니다. 이 파일은 숨겨져 있습니다.

2. 그래픽 커널 구성 도구를 시작합니다:

    ```       
    > make O=~/build/kernel menuconfig
    ```

    위와 비슷한 화면이 표시됩니다:

![기본 커널 구성 화면](images/Il01-kernel.png)

    표시된 커널 구성 화면은 대략적으로 세 가지 영역으로 나뉩니다.
    상단 부분에는 다양한 도움말, 키보드 단축키 및 사용자가 응용 프로그램을 탐색하는 데 도움이 되는 정보가 표시됩니다.
    화면의 본문에는 전체적으로 구성 가능한 커널 옵션의 확장 가능한 트리 구조 목록이 표시됩니다. 부모 항목에 화살표가 있는 항목을 확장하여 하위 메뉴(또는 자식) 항목을 보고/구성할 수 있습니다. 마지막으로 화면의 하단에는 실제 사용자가 선택할 수 있는 동작/옵션이 표시됩니다.

3. 이제 데모를 위해 NTFS 지원을 사용자 정의 커널에 추가해보겠습니다.

    주 구성 화면에서 화살표 키를 사용하여 File systems 항목으로 이동하고 강조 표시합니다. File systems이 선택되면 엔터 키를 눌러 File systems의 하위 메뉴 또는 자식 항목을 보고/구성할 수 있습니다.

    File Systems 섹션에서 화살표 키를 사용하여 DOS/FAT/NT Filesystems로 이동합니다. 엔터 키를 눌러 DOS/FAT/NT Filesystems의 하위 메뉴를 확인합니다.

4. DOS/FAT/NT Filesystems 섹션에서 NTFS 파일 시스템 지원으로 이동합니다.

    대문자 M을 입력하여 NTFS 파일 시스템 지원을 모듈을 통해 활성화합니다.

    화살표 키를 사용하여 NTFS debugging support (NEW)로 이동한 다음 y를 눌러 포함합니다.

    화살표 키를 사용하여 NTFS write support로 이동한 다음 y를 눌러 포함합니다. 완료하면 M 또는 별표 기호 (*)가 각 옵션 옆에 나타나야 합니다. 다음과 같이 표시됩니다:

    ![커널 구성 파일 시스템 화면](images/Il02-kernel.png)

    !!! tip "팁"
   
        커널 구성 도구에서 각 구성 가능한 옵션에 대해 빈 꺽쇠 괄호, <>,는 해당 기능이 비활성화된 것을 나타냅니다. 대문자 M이 꺽쇠 괄호로 둘러싸인 경우, <M>, 해당 기능은 모듈로 컴파일되어야 함을 나타냅니다.

    별표 기호는 꺽쇠 괄호로 둘러싸여 있으며, <*>, 해당 기능에 대한 지원이 커널에 직접 내장될 것임을 나타냅니다. 일반적으로 키보드의 스페이스바를 사용하여 모든 가능한 옵션을 전환할 수 있습니다.

5. DOS/FAT/NT 파일 시스템 화면에서 키보드의 esc 키를 두 번 눌러 상위 파일 시스템 화면으로 다시 이동합니다. 키보드에서 esc를 다시 두 번 눌러 메인 커널 구성 화면으로 돌아갑니다.

6. 마지막으로, 커널 소스 트리의 루트에 .config 파일에 대한 변경 사항을 저장하고 커널 구성 응용 프로그램을 종료한 다음 파일을 저장하기 위해 키보드의 esc 키를 다시 두 번 누릅니다.

7. 대화 상자가 나타나고 새 구성을 저장할 것인지 확인합니다. Yes가 선택되어 있는지 확인한 다음 엔터 키를 누릅니다.

8. 커널 구성 유틸리티가 종료되면 커널 소스 트리 내부의 셸로 다시 보내집니다. 이제 커널을 만들 준비가 거의 되었습니다!

9. Rocky 배포판에서 몇 가지 추가 사용자 정의를 완료해야 합니다. 다음과 같이 입력합니다:

    ```
    sed -ri '/CONFIG_SYSTEM_TRUSTED_KEYS/s/=.+/=""/g' ~/build/kernel/.config
    ```

    !!! tip "팁"

     menuconfig 도구를 사용하여 수행한 일부 변경 사항의 결과를 보려면 grep 유틸리티를 사용하여 직접 저장한 .config 파일을 확인할 수 있습니다. 예를 들어, 이전에 활성화한 NTFS 파일 시스템 지원의 효과를 보려면 다음과 같이 입력합니다:
        ```
        > grep NTFS ~/build/kernel/.config
        CONFIG_NTFS_FS=m
        CONFIG_NTFS_DEBUG=y
        CONFIG_NTFS_RW=y
        ```
    !!! 참고 "커널 모듈에 대한 간단한 설명"

     로드 가능한 모듈 지원은 Linux 커널 기능으로, 커널 모듈을 동적으로 로드하거나 제거할 수 있게 해줍니다.
    
     커널 모듈은 컴파일된 코드 조각으로, 커널에 영구적으로 내장되는 것이 아니라 실행 중인 커널에 동적으로 삽입될 수 있습니다. 자주 사용되지 않는 기능은 활성화할 수 있지만, 사용되지 않을 때는 메모리 공간을 차지하지 않습니다.
    
     운 좋게도 Linux 커널은 무엇을 언제 로드할지 자동으로 판단할 수 있습니다. 그러나 모든 기능이 모듈로 컴파일될 수 있는 것은 아닙니다. 커널은 모듈을 로드하고 언로드하기 전에 하드 디스크에 액세스하고 로드 가능한 모듈이 저장된 파일 시스템을 구문 분석하는 등 몇 가지 정보를 알아야 합니다. 일부 커널 모듈은 드라이버로도 불리기도 합니다.

### 커널 컴파일

In the preceding section, we walked through the process of creating a configuration file for the custom kernel that we want to build. 이번 섹션에서는 실제로 커널을 빌드할 것입니다. 그러기 전에 전체 프로세스에 하나의 간단한 사용자 정의를 추가하겠습니다.

마지막으로, 커널의 최종 이름에 사용되는 추가 정보를 추가할 것입니다. 이를 통해 동일한 버전 번호를 가진 다른 커널과 구별할 수 있습니다. 커널 버전 정보에 "custom" 태그를 추가할 것입니다. 이는 메인 Makefile을 편집하고 원하는 태그를 EXTRAVERSION 변수에 추가함으로써 수행할 수 있습니다.

커널 빌드 프로세스의 컴파일 단계는 가장 쉽지만 가장 많은 시간이 소요됩니다. 이 시점에서 필요한 것은 단순히 make 명령을 실행하는 것뿐입니다. 이 명령은 의존성 문제를 자동으로 처리하고 커널 자체를 컴파일하며, 로드 가능한 모듈로 활성화된 기능이나 드라이버도 컴파일합니다.

컴파일해야 할 코드 양 때문에, 시스템의 처리 능력에 따라 최소한 몇 분은 대기해야 합니다. 이제 새로운 커널을 컴파일하기 위해 필요한 구체적인 단계를 알아보겠습니다.

1. 빌드할 커널의 식별 문자열에 추가 정보를 추가합니다. 여전히 커널 소스 트리의 루트 위치에 있는 상태에서, sed 유틸리티를 사용하여 Makefile을 편집합니다. 변경하려는 변수는 파일의 상단 근처에 위치해 있습니다. 다음과 같은 형식의 줄을 변경하려고 합니다:

    ```
    EXTRAVERSION =
    ```

    다음으로:

    ```
    EXTRAVERSION = -custom
    ```

    다음 `sed` 명령을 사용하여 변경사항을 적용하세요: 유형: 다음과 같이 입력합니다:

    ```
    sed  -i 's/^EXTRAVERSION.*/EXTRAVERSION = -custom/'  Makefile
    ```

    물론, 변경사항을 적용하는 데 편한 텍스트 편집기를 사용해도 됩니다. 변경 내용을 파일에 저장하는 것을 잊지 마세요!

2. 커스터마이즈한 커널의 전체 버전을 확인하기 위해 make 명령에 kernelversion 타겟을 전달하세요:

    ```
    > make O=~/build/kernel kernelversion
    ```

    !!! tip "팁"

     대부분의 최신 시스템은 CPU, 코어 등의 추가 처리 능력을 활용하여 커널 컴파일과 같은 CPU 집약적인 작업을 크게 빠르게 할 수 있습니다. 이를 위해 make 명령에 동시에 실행할 작업 수를 지정하는 매개변수를 전달할 수 있습니다. 지정된 작업 수는 각 CPU 코어에서 동시에 분산되고 실행됩니다. 명령의 구문은 다음과 같습니다:

    ```
    > make -j N
    ```
    여기서 N은 동시에 실행할 작업 수입니다. 예를 들어, 8개의 코어를 가진 CPU를 사용하는 경우 다음과 같이 입력할 수 있습니다:

    ```
    > make -j 8
    ```

3. 커널을 컴파일하는 데 필요한 유일한 명령은 make 명령입니다.

    ```
    > make  O=~/build/kernel**
    make[1]: Entering directory '/home/super/build/kernel'
    SYNC    include/config/auto.conf.cmd
    GEN     Makefile
    HOSTCC  scripts/kconfig/conf.o
    HOSTLD  scripts/kconfig/conf
    GEN     Makefile
    ...<OUTPUT TRUNCATED>…
    LD [M]  sound/usb/usx2y/snd-usb-usx2y.ko
    LD [M]  sound/x86/snd-hdmi-lpe-audio.ko
    LD [M]  sound/xen/snd_xen_front.ko
    LD [M]  virt/lib/irqbypass.ko
    make[1]: Leaving directory '/home/super/build/kernel'
    ```

4. 커맨드의 최종 결과물인 커널은 다음 경로에 위치해 있습니다:

    ```
    ~/build/kernel/arch/x86/boot/bzImage
    ```

5. 커널의 일부를 모듈로 컴파일했기 때문에 (예: NTFS 모듈), 모듈을 설치해야 합니다. 다음과 같이 입력하세요:

    ```
    > sudo make O=~/build/kernel modules_install
    ```

    Rocky 시스템에서 이 명령은 모든 컴파일된 커널 모듈을 /lib/modules//<new_kernel-version> 디렉토리에 설치합니다. 이 예에서는 해당 경로가 /lib/modules/5.16.9-custom/로 변환됩니다. 이 경로는 커널이 필요할 때 로드 가능한 모듈을 로드하는 경로입니다.

    !!! TIP

     "make modules_install"을 통해 설치된 커널 모듈의 풋프린트(크기)는 디버깅 심볼을 포함하기 때문에 상당히 크게 될 수 있습니다. 결과적으로 <code>/lib/modules/5.16.9-custom/ 디렉토리의 크기가 5GB에 가까워질 수 있습니다!
    
     이 가이드에서는 "make modules_install" 호출에 INSTALL_MOD_STRIP=1 옵션을 포함하여 크기를 줄였습니다. 이 디버깅 심볼을 제거함으로써 총 크기를 여러 배로 줄일 수 있습니다 (예: 200MB 미만!!).  
    
     이 가이드에서는 "make modules_install" 호출에 INSTALL_MOD_STRIP=1 옵션을 포함하여 크기를 줄였습니다.
    </code>

## 커널 설치

PC를 사용하고 `~/build/kernel/` 디렉토리에서 작업하고 있다고 가정하면, 이전 연습에서 생성된 컴파일된 커널은 다음 경로에 있을 것입니다. `<kernel-build-dir>/arch/x86/boot/bzImage` 또는 정확히 말하면, 이 예제에서는 `~/build/kernel/arch/x86/boot/bzImage`에 위치합니다.

이에 해당하는 맵 파일은 ~/build/kernel/System.map 경로에 있을 것입니다. 설치 단계에는 두 파일이 모두 필요합니다.

시스템이 정상 작동하지 않고 "Oops" 메시지를 생성하는 경우에는 System.map 파일이 유용합니다. "Oops"는 커널 버그나 불량 하드웨어로 인해 몇 가지 커널 오류가 발생할 때 생성됩니다.

이 오류는 마이크로소프트 윈도우의 블루 스크린 오브 데스 (BSOD- Blue Screen of Death)와 유사합니다. 이 메시지에는 현재 시스템 상태를 나타내는 여러 개의 16진수 숫자가 포함됩니다.

System.map은 Linux에게 해당 16진수 숫자를 읽기 쉬운 이름으로 변환하는 기회를 제공하여 디버깅을 더 쉽게 만듭니다. 이는 주로 개발자들에게 이점을 제공하지만 문제를 보고할 때 유용할 수 있습니다.

새 커널 이미지를 설치하는 데 필요한 단계를 진행해 봅시다.

1. 커널 빌드 디렉토리의 최상위 디렉토리에서 bzImage 파일을 /boot 디렉토리로 복사하고 이름을 바꿉니다.

    ```
    > **sudo cp ~/build/kernel/arch/x86/boot/bzImage  \
    /boot/vmlinuz-<kernel-version>**
    ```

    여기서 커널-버전은 커널의 버전 번호입니다. 이 가이드에서 사용하는 샘플 커널의 경우, 파일 이름은 vmlinuz-5.16.9-custom이 될 것입니다. 따라서 이 예제에 대한 정확한 명령은 다음과 같습니다.

    ```
    > sudo cp ~/build/kernel/arch/x86/boot/bzImage  \
    /boot/vmlinuz-5.16.9-custom
    ```

    !!! 참고 사항

     커널 이미지의 이름을 vmlinuz-5.16.9-custom으로 지정한 결정은 다소 임의적입니다. 커널 이미지는 일반적으로 vmlinuz로 참조되며, 버전 번호의 접미사는 여러 개의 사용 가능한 커널이나 특정 기능을 제공하는 커널을 가지고 있는 경우 유용합니다 (예: vmlinuz-6.50.0-ws).

2. 이제 커널 이미지가 준비되었으므로 동일한 네이밍 규칙을 사용하여 해당하는 System.map 파일을 /boot 디렉토리로 복사하고 이름을 바꿉니다.

    ```
    > sudo cp -v  ~/build/kernel/System.map \
    /boot/System.map-5.16.9-custom
    ```

3. 커널이 준비되었고, System.map 파일도 준비되었으며, 모듈도 준비되었습니다. 이제 마지막 단계를 수행할 준비가 되었습니다. 필요한 명령의 구문은 다음과 같습니다.

    ```
    > kernel-install add   <kernel-version>  <kernel-image>
    ```

    여기 <kernel-version> <커널-버전>은 커널의 버전 번호 (및 이름)입니다. 그리고 <kernel-image> 여기서 <커널-버전>은 커널의 버전 번호 (및 이름)이고, <커널-이미지>는 새로 컴파일된 커널 이미지의 경로입니다.

    예제를 위해 다음을 입력하세요.

    ```
    > sudo kernel-install \
    add  5.16.9-custom /boot/vmlinuz-5.16.9-custom
    ```

여기서 사용하는 kernel-install 명령은 편리한 셸 스크립트입니다. 모든 Linux 배포판에서 사용 가능하지는 않을 수 있지만, 최신 Fedora, RHEL, CentOS 배포판에서 사용할 수 있습니다. 이 도구는 우리가 방금 빌드한 새 커널을 부팅하기 위해 시스템을 설정하는 데 필요한 많은 최종 수동 작업을 자동화합니다.

특히, 이 도구는 다음을 수행합니다.

- 적절한 초기 RAM 파일 시스템 이미지 (initramfs 이미지 또는 /boot/initramfs-<kernel-version>.img file)를 생성합니다. kernel-install을 사용할 수 없는 시스템에서 수동으로 수행하려면 mkinitramfs 명령을 사용하세요.
- depmod 명령을 실행합니다 (모듈 종속성 목록을 생성합니다).
- 부트 로더 설정을 업데이트합니다.

최신 버전의 GRUB2를 사용하는 시스템의 경우 파일은 `/boot/grub2/grub.cfg`에 있습니다. EFI 기반 시스템의 경우 /boot/efi/<distro>/fedora/grub.cfg도 업데이트됩니다.

그리고 이전 버전의 GRUB를 사용하는 시스템의 경우 /boot/grub/grub.conf 또는 /boot/grub/menu.lst 파일이 될 것입니다. 그리고 새로운 부트 로더 사양 (Boot Loader Specification, BLS)을 구현한 매우 새로운 배포판의 경우 새로운 부트 로더 항목이 /boot/loader/entries/ 디렉토리나 "blsdir" 변수가 가리키는 디렉토리에 추가됩니다.

우리의 데모 EFI 기반 Rocky 서버에서 GRUB 2와 BLS를 사용하여 새로운 부트 항목이 생성되며, 부트 로더 파일은 `/boot/loader/entries/6fa25ca775f64accb0d3e53f0e4e6e92-5.16.9-custom.conf`에 위치합니다.

```
> sudo cat  /boot/loader/entries/6fa25ca775f64accb0d3e53f0e4e6e92-5.16.9-custom.conf
title Rocky Linux (5.16.9-custom) 8.5 (Green Obsidian)
version 5.16.9-custom
linux /vmlinuz-5.16.9-custom
initrd /initramfs-5.16.9-custom.img $tuned_initrd
options $kernelopts $tuned_params
id rocky-20220212013135-5.16.9-custom
grub_users $grub_users
grub_arg --unrestricted
grub_class kernel
```

!!! note "참고 사항"

    대부분의 배포판에서는 GRUB2와 부트 로더 유지 관리 작업을 수행하는 데 사용할 수 있는 여러 가지 grub2-* 유틸리티가 이미 제공됩니다. 예를 들어 grub2-set-default 명령을 사용하여 시스템 부팅 시 기본 커널을 변경하거나 설정할 수 있습니다.

## 커스텀 커널 부팅
다음 단계는 시스템이 실제로 해당 커널로 부팅할 수 있는지 확인하기 위해 새로운 커널을 테스트하는 것입니다.

1. 의사가 처방한 대로 정확히 모든 작업을 수행하고 의사가 말한 대로 모든 것이 정확히 작동한 것으로 가정하고 시스템을 안전하게 재부팅하고 부팅 시 부트 로더 메뉴에서 새로운 커널을 선택합니다.

    ```
    >  sudo reboot
    ```

2. 시스템이 부팅되면 uname 명령을 사용하여 현재 커널의 이름을 확인할 수 있습니다.

    ```
    >  uname -r
    5.16.9-custom
    ```

3. 새로운 커널에 NTFS 파일 시스템 지원 기능을 추가한 것을 기억하실 것입니다. NTFS 모듈에 대한 정보를 표시하여 새로운 커널이 실제로 NTFS를 지원하는지 확인하세요.

    ```
    [rockstar ~]$ modinfo ntfs
    filename:       /lib/modules/5.16.9-custom/kernel/fs/ntfs/ntfs.ko
    license:        GPL
    version:        2.1.32
    description:    NTFS 1.2/3.x driver - Copyright …..
    ...<OUTPUT TRUNCATED>...
    ```

이게 끝입니다!
