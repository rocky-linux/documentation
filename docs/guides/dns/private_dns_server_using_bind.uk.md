---
title: Bind Private DNS Server
author: Steven Spencer
contributors: Ezequiel Bruni, k3ym0, Ganna Zhyrnova
tested_with: 8.5, 8.6, 9.0
tags:
  - dns
  - bind
---

# Приватний DNS-сервер із `bind`

## Передумови та припущення

* Сервер під керуванням Rocky Linux
* Кілька внутрішніх серверів, яким потрібен лише локальний доступ, а не через Інтернет
* Кілька робочих станцій, яким потрібен доступ до тих самих серверів, які існують в одній мережі
* Здоровий рівень комфорту при введенні команд із командного рядка
* Знайомство з редактором командного рядка (у цьому прикладі ми використовуємо _vi_)
* Можливість використовувати _firewalld_ для створення правил брандмауера

## Вступ

Зовнішні або загальнодоступні DNS-сервери відображають імена хостів на IP-адреси, а у випадку записів PTR (відомих як «вказівник» або «зворотний»), відображають IP-адреси в імені хоста. Це важлива частина Інтернету. Завдяки цьому ваш поштовий сервер, веб-сервер, FTP-сервер або багато інших серверів і служб працюють належним чином, незалежно від того, де ви знаходитесь.

У приватній мережі, зокрема для розробки багатьох систем, ви можете використовувати файл */etc/hosts* вашої робочої станції Rocky Linux, щоб зіставити ім’я з IP-адресою.

Це працюватиме для _вашої_ робочої станції, але не для будь-якої іншої машини у вашій мережі. Найкращий спосіб зробити речі універсальними — це взяти деякий час і створити локальний приватний DNS-сервер, який оброблятиме це для всіх ваших машин.

Припустімо, ви створюєте загальнодоступні DNS-сервери та резолвери робочого рівня. У такому випадку автор рекомендує надійніший авторитетний і рекурсивний DNS [PowerDNS](https://www.powerdns.com/), який можна встановити на серверах Rocky Linux. Однак цей документ призначений для локальної мережі, яка не відкриває свої DNS-сервери для зовнішнього світу. Ось чому автор вибрав для цього прикладу `bind`.

### Пояснення компонентів DNS-сервера

DNS поділяє служби на авторитетні та рекурсивні сервери. Тепер рекомендовано розміщувати ці служби окремо на окремому обладнанні чи контейнерах.

Авторитетний сервер є областю зберігання для всіх IP-адрес та імен хостів, а рекурсивний сервер шукає адреси та імена хостів. У випадку нашого приватного DNS-сервера служби авторитетного та рекурсивного серверів працюватимуть разом.

## Встановлення та ввімкнення `bind`

Першим кроком є встановлення пакетів:

```
dnf install bind bind-utils
```

Службовий демон _bind_ має `named`. Увімкніть це для запуску під час завантаження:

```
systemctl enable named
```

Запустіть `named`:

```
systemctl start named
```

## Конфігурація

Перш ніж вносити зміни до будь-якого файлу конфігурації, створіть резервну копію вихідного встановленого робочого файлу _named.conf_:

```
cp /etc/named.conf /etc/named.conf.orig
```

Це допоможе в майбутньому, якщо станеться введення помилок у файл конфігурації. *Завжди* є чудовою ідеєю зробити резервну копію перед внесенням змін.

Відредагуйте файл _named.conf_. Автор використовує _vi_, але ви можете замінити його улюбленим редактором командного рядка:

```
vi /etc/named.conf
```

Вимкніть прослуховування на локальному хості. Зробіть це, позначивши знаком «#» ці два рядки в розділі «параметри». Це вимикає будь-який зв’язок із зовнішнім світом.

Це корисно, особливо коли ви додаєте цей DNS на наші робочі станції, оскільки ви хочете, щоб DNS-сервер відповідав лише тоді, коли IP-адреса, яка запитує службу, є локальною, і не реагував, якщо сервер або служба знаходяться в Інтернеті.

Таким чином, інші налаштовані DNS-сервери майже негайно візьмуть на себе роботу для пошуку Інтернет-служб:

```
options {
#       listen-on port 53 { 127.0.0.1; };
#       listen-on-v6 port 53 { ::1; };
```

Нарешті, перейдіть до кінця файлу *named.conf* і додайте розділ для вашої мережі. Наш приклад — «ourdomain», тож підставте те, що ви хочете назвати хостами локальної мережі:

```
# primary forward and reverse zones
//forward zone
zone "ourdomain.lan" IN {
     type master;
     file "ourdomain.lan.db";
     allow-update { none; };
    allow-query {any; };
};
//reverse zone
zone "1.168.192.in-addr.arpa" IN {
     type master;
     file "ourdomain.lan.rev";
     allow-update { none; };
    allow-query { any; };
};
```

Збережіть зміни (для _vi_, `SHIFT:wq!`)

## Прямі та зворотні записи

Вам потрібно створити два файли в `/var/named`. Ви будете редагувати ці файли, якщо додасте машини до своєї мережі, щоб включити їх у DNS.

Перший — це файл пересилання, щоб зіставити нашу IP-адресу з іменем хоста. Знову ж таки, ми використовуємо "ourdomain" як приклад. Зверніть увагу, що IP-адреса нашого локального DNS тут 192.168.1.136. Хости додаються внизу цього файлу.

```
vi /var/named/ourdomain.lan.db
```

Після завершення файл виглядатиме приблизно так:

```
$TTL 86400
@ IN SOA dns-primary.ourdomain.lan. admin.ourdomain.lan. (
    2019061800 ;Serial
    3600 ;Refresh
    1800 ;Retry
    604800 ;Expire
    86400 ;Minimum TTL
)

;Name Server Information
@ IN NS dns-primary.ourdomain.lan.

;IP for Name Server
dns-primary IN A 192.168.1.136

;A Record for IP address to Hostname
wiki IN A 192.168.1.13
www IN A 192.168.1.14
devel IN A 192.168.1.15
```

Додайте всі потрібні хости та їхні IP-адреси та збережіть зміни.

Вам потрібен зворотний файл, щоб зіставити наше ім’я хоста з IP-адресою. У цьому випадку єдиною частиною IP-адреси, яка вам потрібна, є останній октет (в адресі IPv4 кожне число, розділене «.», є октетом) хоста, PTR та імені хоста.

```
vi /var/named/ourdomain.lan.rev
```

Після завершення файл виглядатиме приблизно так:

```
$TTL 86400
@ IN SOA dns-primary.ourdomain.lan. admin.ourdomain.lan. (
    2019061800 ;Serial
    3600 ;Refresh
    1800 ;Retry
    604800 ;Expire
    86400 ;Minimum TTL
)
;Name Server Information
@ IN NS dns-primary.ourdomain.lan.

;Reverse lookup for Name Server
136 IN PTR dns-primary.ourdomain.lan.

;PTR Record IP address to HostName
13 IN PTR wiki.ourdomain.lan.
14 IN PTR www.ourdomain.lan.
15 IN PTR devel.ourdomain.lan.
```

Додайте всі імена хостів у файлі пересилання та збережіть зміни.

### Що все це означає

Оскільки ви все це додали та готуєтеся перезапустити наш DNS-сервер _bind_, давайте розглянемо деякі терміни, які використовуються в цих двох файлах.

Просто змушувати все працювати недостатньо, якщо ви не знаєте, що означає кожен термін, чи не так?

* **TTL** означає "Time To Live". TTL повідомляє DNS-серверу, як довго зберігати його кеш, перш ніж запитувати нову копію. У цьому випадку TTL є налаштуванням за замовчуванням для всіх записів, якщо не встановлено певний TTL запису. За замовчуванням тут встановлено 86400 секунд або 24 години.
* **IN** означає Інтернет. У цьому випадку ми не використовуємо Інтернет. Подумайте про це як про інтранет.
* **SOA** означає "Start Of Authority" або те, що є основним сервером DNS для домену.
* **NS** означає "сервер імен"
* **Serial** – це значення, яке використовує сервер DNS для перевірки актуальності вмісту файлу зони.
* **Refresh** вказує, як часто підлеглий DNS-сервер має виконувати передачу зони від головного.
* **Retry** вказує тривалість очікування в секундах перед повторною спробою під час невдалої передачі зони.
* **Expire** визначає, як довго підлеглий сервер має чекати відповіді на запит, коли головний недоступний.
* **A** – це адреса хоста або запис пересилання, і він міститься лише у файлі пересилання (вище).
* **PTR** - це запис вказівника, більш відомий як "реверс" і міститься лише в нашому файлі реверсу (вище).

## Тестування конфігурацій

Коли ви створите всі свої файли, вам потрібно переконатися, що файли конфігурації та зони працюють у належному стані, перш ніж запускати службу _bind_ знову.

Перевірте основну конфігурацію:

```
named-checkconf
```

Це має повернути порожній результат, якщо все гаразд.

Потім перевірте передню зону:

```
named-checkzone ourdomain.lan /var/named/ourdomain.lan.db
```

Це повинно повернути щось на зразок цього, якщо все добре:

```
zone ourdomain.lan/IN: loaded serial 2019061800
OK
```

І нарешті перевірте реверсну зону:

```
named-checkzone 192.168.1.136 /var/named/ourdomain.lan.rev
```

Що має повернути щось подібне, якщо все добре:

```
zone 192.168.1.136/IN: loaded serial 2019061800
OK
```

Якщо припустити, що все виглядає добре, перезапустіть _bind_:

```
systemctl restart named
```

=== "9"

    ## 9 за допомогою IPv4 у вашій локальній мережі
    
    Щоб використовувати ТІЛЬКИ IPv4 у вашій локальній мережі, вам потрібно внести одну зміну в `/etc/sysconfig/named`:

    ```
    vi /etc/sysconfig/named
    ```


    а потім додайте це внизу файлу:

    ```
    OPTIONS="-4"
    ```


    Збережіть зміни.
    
    ## 9 Тестування машин
    
    Вам потрібно додати DNS-сервер (у нашому прикладі 192.168.1.136) до кожної машини, на якій ви хочете отримати доступ до серверів, які ви додали до свого локального DNS. Автор лише покаже вам приклад того, як це зробити на робочій станції Rocky Linux. Подібні методи існують для інших дистрибутивів Linux, машин Windows і Mac.
    
    Ви захочете додати DNS-сервери до списку, а не замінювати наявні, оскільки вам усе одно знадобиться доступ до Інтернету, для якого знадобляться ваші наразі призначені DNS-сервери. DHCP (протокол динамічної конфігурації хоста) зазвичай призначає або призначається статично.
    
    Ви додасте наш локальний DNS за допомогою `nmcli`, а потім перезапустите з’єднання. 
    
    ??? warning "Дурні імена профілів"
    
         У NetworkManager підключення змінюються не за назвою пристрою, а за назвою профілю. Це можуть бути такі речі, як "Wired connection 1" або "Wireless connection 1". Ви можете переглянути профіль, запустивши `nmcli` без будь-яких параметрів:

        ```
        nmcli
        ```


        Це покаже вам такі результати:

        ```bash
        enp0s3: connected to Wired Connection 1
        "Intel 82540EM"
        ethernet (e1000), 08:00:27:E4:2D:3D, hw, mtu 1500
        ip4 default
        inet4 192.168.1.140/24
        route4 192.168.1.0/24 metric 100
        route4 default via 192.168.1.1 metric 100
        inet6 fe80::f511:a91b:90b:d9b9/64
        route6 fe80::/64 metric 1024

        lo: unmanaged
            "lo"
            loopback (unknown), 00:00:00:00:00:00, sw, mtu 65536

        DNS configuration:
            servers: 192.168.1.1
            domains: localdomain
            interface: enp0s3

        Use "nmcli device show" to get complete information about known devices and
        "nmcli connection show" to get an overview on active connection profiles.
        ```


        Перш ніж ми навіть почнемо змінювати з’єднання, ви повинні назвати це як-небудь розумне, наприклад ім’я інтерфейсу (**зверніть увагу**, що «\» нижче пропускає пробіли в назві):

        ```
        nmcli connection modify Wired\ connection\ 1 con-name enp0s3
        ```


        Коли закінчите, знову запустіть `nmcli` самостійно, і ви побачите щось на зразок цього:

        ```bash
        enp0s3: connected to enp0s3
        "Intel 82540EM"
        ethernet (e1000), 08:00:27:E4:2D:3D, hw, mtu 1500
        ip4 default
        inet4 192.168.1.140/24
        route4 192.168.1.0/24 metric 100
        route4 default via 192.168.1.1 metric 100
        ...
        ```


        Це значно спростить решту конфігурації DNS!
    
    Якщо припустити, що ім’я вашого профілю з’єднання – «enp0s3», ми включимо вже налаштований DNS, але спочатку додамо наш локальний DNS-сервер:

    ```
    nmcli con mod enp0s3 ipv4.dns '192.168.1.138,192.168.1.1'
    ```


    Ви можете мати більше DNS-серверів. Для комп’ютера, налаштованого на загальнодоступні DNS-сервери, скажімо, відкритий DNS Google, ви можете мати це замість цього:

    ```
    nmcli con mod enp0s3 ipv4.dns '192.168.1.138,8.8.8.8,8.8.4.4'
    ```


    Після того, як ви додасте DNS-сервери, які хочете з’єднати, ви зможете розпізнавати хости в *ourdomain.lan*, а також хости Інтернету.

=== "8"

    ## 8 Використання IPv4 у вашій локальній мережі
    
    Вам потрібно внести дві зміни, якщо ви використовуєте лише IPv4 у своїй локальній мережі. Перший міститься в `/etc/named.conf`, а другий — у `/etc/sysconfig/named`
    
    Спочатку знову поверніться до файлу `named.conf` за допомогою `vi /etc/named.conf`. Нам потрібно додати наступний параметр у будь-якому місці розділу параметрів.

    ```
    filter-aaaa-on-v4 yes;
    ```


    Показано нижче:
    
    ![Додати фільтр IPv6](images/dns_filter.png)
    
    Щойно ви внесете цю зміну, збережіть її та вийдіть із `named.conf` (для _vi_, `SHIFT:wq!`)
    
    Вам потрібно внести аналогічні зміни до `/etc/sysconfig/named`:

    ```
    vi /etc/sysconfig/named
    ```


    Додайте це внизу файлу:

    ```
    OPTIONS="-4"
    ```


    Збережіть ці зміни (знову ж таки, для _vi_, `SHIFT:wq!`)
    
    
    ## 8 Тестування машин
    
    Вам потрібно додати DNS-сервер (у нашому прикладі 192.168.1.136) до кожної машини, на якій ви хочете отримати доступ до серверів, які ви додали до свого локального DNS. Автор показує лише приклад того, як це зробити на робочій станції Rocky Linux. Подібні методи існують для інших дистрибутивів Linux, машин Windows і Mac.
    
    Ви захочете додати DNS-сервер до списку, оскільки вам все одно знадобиться доступ до Інтернету, для якого знадобляться ваші наразі призначені DNS-сервери. DHCP (протокол динамічної конфігурації хоста) зазвичай призначає або призначається статично.
    
    На робочій станції Rocky Linux, де активним мережевим інтерфейсом є eth0, використовуйте:

    ```
    vi /etc/sysconfig/network-scripts/ifcfg-eth0
    ```


    Якщо ваш увімкнений мережевий інтерфейс відрізняється, ви повинні замінити це ім’я інтерфейсу. Файл конфігурації, який ви відкриваєте, виглядатиме так для статично призначеної IP-адреси (не DHCP, як згадувалося вище). У прикладі нижче IP-адреса нашої машини 192.168.1.151:

    ```
    DEVICE=eth0
    BOOTPROTO=none
    IPADDR=192.168.1.151
    PREFIX=24
    GATEWAY=192.168.1.1
    DNS1=8.8.8.8
    DNS2=8.8.4.4
    ONBOOT=yes
    HOSTNAME=tender-kiwi
    TYPE=Ethernet
    MTU=
    ```


    Ви хочете замінити наш новий DNS-сервер замість основного (DNS1) і перемістити кожен інший DNS-сервер на один нижче:

    ```
    DEVICE=eth0
    BOOTPROTO=none
    IPADDR=192.168.1.151
    PREFIX=24
    GATEWAY=192.168.1.1
    DNS1=192.168.1.136
    DNS2=8.8.8.8
    DNS3=8.8.4.4
    ONBOOT=yes
    HOSTNAME=tender-kiwi
    TYPE=Ethernet
    MTU=
    ```


    Після завершення змін перезапустіть машину або перезапустіть мережу за допомогою:

    ```
    systemctl restart network
    ```


    Тепер ви зможете отримувати будь-який доступ у домені *ourdomain.lan* зі своїх робочих станцій, а також матимете змогу розпізнавати та отримувати доступ до Інтернет-адрес.


## Правила брандмауера - `firewalld`

!!! note "`firewalld` за замовчуванням"

    У Rocky Linux 9.0 і вище використання правил `iptables` застаріло. Замість цього слід використовувати `firewalld`.

Автор не робить жодних припущень щодо мережі чи послуг, які вам можуть знадобитися, за винятком увімкнення доступу SSH і доступу DNS лише для нашої локальної мережі. Для цього ви будете використовувати вбудовану зону `firewalld`, "довірену". Щоб обмежити доступ SSH до локальної мережі, вам доведеться внести зміни в службу «публічної» зони.

Першим кроком буде додавання нашої локальної мережі до «довіреної» зони:

```
firewall-cmd --zone=trusted --add-source=192.168.1.0/24 --permanent
```

Додайте наші дві служби в «довірену» зону:

```
vi /etc/sysconfig/named
```

Видаліть службу SSH із нашої «публічної» зони, яка ввімкнена за замовчуванням:

```
firewall-cmd --zone=public --remove-service=ssh --permanent
```

Перезавантажте брандмауер і вкажіть зони, які ви змінили:

```
OPTIONS="-4"
```

Це покаже, що ви правильно додали служби та вихідну мережу:

```
trusted (active)
    target: ACCEPT
    icmp-block-inversion: no
    interfaces:
    sources: 192.168.1.0/24
    services: dns ssh
    ports:
    protocols:
    forward: no
    masquerade: no
    forward-ports:
    source-ports:
    icmp-blocks:
    rich rules:
```

Перелік «публічної» зони покаже, що доступ через SSH більше не дозволено:

```
firewall-cmd --zone=public --list-all
```

Показує:

```
public
    target: default
    icmp-block-inversion: no
    interfaces:
    sources:
    services: cockpit dhcpv6-client
    ports:
    protocols:
    forward: no
    masquerade: no
    forward-ports:
    source-ports:
    icmp-blocks:
    rich rules:
```

Ці правила забезпечать вам дозвіл DNS на вашому приватному сервері DNS від хостів у мережі 192.168.1.0/24. Крім того, ви зможете SSH з будь-якого з цих хостів до вашого приватного DNS-сервера.

## Висновки

Зміна */etc/hosts* на окремій робочій станції дасть вам доступ до машини у вашій внутрішній мережі, але ви можете використовувати її лише на цій машині. Приватний сервер DNS, який використовує _bind_, дозволить вам додавати хости до DNS; за умови, що робочі станції мають доступ до цього приватного сервера DNS, вони можуть отримати доступ до цих локальних серверів.

Якщо вам не потрібні комп’ютери для вирішення в Інтернеті, але вам потрібен локальний доступ кількох машин до локальних серверів, розгляньте натомість приватний DNS-сервер.
