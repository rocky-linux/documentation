- - -
Title: Лабораторна робота 9 - Криптографія author: Wale Soyinka contributors: Steven Spencer, Ganna Zhyrnova
- - -


# Lab 9: Криптографія

## Завдання

Після виконання цієї лабораторної роботи ви зможете:

- застосовувати криптографічні концепції для захисту даних і зв'язку

Приблизний час виконання цієї лабораторної роботи: 120 хвилин
> Троє можуть зберігати таємницю, якщо двоє з них мертві...
> 
> -- Benjamin Franklin

## Загальні терміни та визначення криптографії

### Криптографія

У загальному повсякденному вживанні криптографія — це дія або мистецтво написання таємними символами. На технічному жаргоні це можна визначити як науку про використання математики для шифрування та дешифрування даних.

### Криптоаналіз

Криптоаналіз — це дослідження того, як скомпрометувати (подолати) криптографічні механізми. Це наука про злом коду, декодування секретів, порушення схем автентифікації та загалом зламу криптографічних протоколів.

### Криптологія

Криптологія - це дисципліна, яка складається з криптографії та криптоаналізу. Криптологія — розділ математики, що вивчає математичні основи криптографічних методів.

### Шифрування

Шифрування перетворює дані у форму, яку майже неможливо прочитати без відповідних знань (наприклад, ключа). Його метою є забезпечення конфіденційності, зберігаючи інформацію прихованою від будь-кого, для кого вона не призначена.

### Розшифровка

Дешифрування є протилежністю шифруванню; він перетворює зашифровані дані в зрозумілу форму.

### Шифр

Метод шифрування і дешифрування називається шифром.

Хеш-функції (алгоритми дайджесту)

Криптографічні хеш-функції використовуються в різних контекстах, наприклад, для обчислення дайджесту повідомлення під час створення цифрового підпису. Хеш-функція стискає біти повідомлення до хеш-значення фіксованого розміру, щоб рівномірно розподілити можливі повідомлення між можливими хеш-значеннями. Криптографічна хеш-функція робить це таким чином, що надзвичайно ускладнює створення повідомлення, яке хешує до певного хеш-значення. Нижче наведено кілька прикладів найвідоміших і найпоширеніших хеш-функцій.

**a)** - **SHA-1 (Secure Hash Algorithm)** - це криптографічний хеш-алгоритм, опублікований урядом Сполучених Штатів. Він створює 160-бітне хеш-значення з рядка довільної довжини. Вважається, що це дуже добре.

**b)**- **MD5 (Message Digest Algorithm 5)** – це криптографічний геш-алгоритм, розроблений у RSA Laboratories. Його можна використовувати для хешування байтового рядка довільної довжини до 128-бітного значення.

### Алгоритм

Він описує покрокову процедуру розв’язування задачі, особливо усталену, рекурсивну обчислювальну процедуру для розв’язання задачі за кінцеву кількість кроків. Технічно алгоритм повинен досягти результату після кінцевої кількості кроків. Ефективність алгоритму можна виміряти як кількість елементарних кроків, необхідних для вирішення проблеми. Існує два класи алгоритмів на основі ключів. Це:

**a) **-- **Алгоритми симетричного шифрування (секретний ключ)**

Симетричні алгоритми використовують один і той самий ключ для шифрування та дешифрування (або ключ дешифрування легко отримати з ключа шифрування). Алгоритми із секретним ключем використовують один і той самий ключ для шифрування та дешифрування (або один легко вивести з іншого). Це більш простий підхід до шифрування даних, він математично менш складний, ніж криптографія з відкритим ключем. Симетричні алгоритми можна розділити на потокові шифри та блочні шифри. Потокові шифри можуть шифрувати один біт відкритого тексту за раз, тоді як блочні шифри беруть кілька бітів (зазвичай 64 біти в сучасних шифрах) і шифрують їх як єдине ціле. Симетричні алгоритми набагато швидше виконуються на комп’ютері, ніж асиметричні.

Прикладами симетричних алгоритмів є AES, 3DES, Blowfish, CAST5, IDEA та Twofish.

**b) -- Асиметричні алгоритми (алгоритми з відкритим ключем)**

Асиметричні алгоритми, з іншого боку, використовують різні ключі для шифрування та дешифрування, і ключ дешифрування не може бути отриманий з ключа шифрування. Асиметричні шифри дозволяють ключу шифрування бути відкритим, дозволяючи будь-кому шифрувати за допомогою ключа, тоді як лише відповідний одержувач (який знає ключ розшифровки) може розшифрувати повідомлення. Ключ шифрування також називається відкритим ключем, а ключ дешифрування – закритим або секретним ключем.

RSA, ймовірно, найвідоміший алгоритм асиметричного шифрування.

### Цифровий підпис

Цифровий підпис прив’язує документ до власника певного ключа.

Цифровий підпис документа — це частина інформації, яка базується як на документі, так і на закритому ключі підписувача. Зазвичай він створюється за допомогою хеш-функції та функції приватного підпису (шифрування за допомогою закритого ключа підписувача). Цифровий підпис — це невелика кількість даних, створена за допомогою певного секретного ключа, і відкритий ключ можна використовувати для перевірки того, що підпис було згенеровано за допомогою відповідного закритого ключа.

Кілька методів створення та перевірки цифрових підписів доступні у вільному доступі, але найвідомішим є алгоритм відкритого ключа RSA.

### Криптографічні протоколи

Криптографія працює на багатьох рівнях. На одному рівні у вас є алгоритми, такі як блокові шифри та криптосистеми з відкритим ключем. Спираючись на них, ви отримуєте протоколи, а на основі протоколів ви знаходите програми (або інші протоколи). Нижче наведено список типових щоденних програм, які використовують криптографічні протоколи. Ці протоколи побудовані на основі криптографічних алгоритмів нижчого рівня.

**i.)** Безпека сервера доменних імен (DNSSEC)

Це протокол для безпечних розподілених служб імен. Наразі він доступний як чернетка в Інтернеті.

**ii.)** Secure Socket Layer (SSL)

SSL — це один із двох протоколів, які використовуються для безпечних WWW-з’єднань (інший — SHTTP). Безпека WWW стала необхідною, оскільки все більша кількість конфіденційної інформації, такої як номери кредитних карток, передається через Інтернет.

**iii.)** Secure Hypertext Transfer Protocol (SHTTP)

Це ще один протокол для забезпечення більшої безпеки для транзакцій WWW.

**iv.)** Безпека електронної пошти та супутні послуги

**GnuPG** – GNU Privacy Guard – відповідає запропонованому Інтернет-стандарту OpenPGP, описаному в RFC2440.

**v.)** Протокол SSH2

Цей протокол є універсальним для потреб Інтернету та зараз використовується в програмному забезпеченні SSH2. Протокол використовується для захисту термінальних сеансів і TCP-з'єднань.

У наступних вправах розглядаються дві програми, які використовують криптографічні протоколи - GnuPG і OpenSSH.

## Завдання 1

### GnuPG

GnuPG (GNU Privacy Guard) — це набір програм для шифрування з відкритим ключем і цифрових підписів. Інструменти можна використовувати для шифрування даних і створення цифрових підписів. Він також включає розширений засіб керування ключами. GnuPG використовує криптографію з відкритим ключем, щоб дозволити користувачам безпечно спілкуватися.

Виконайте наступні вправи як звичайний користувач. напр. користувач ying

#### Щоб створити нову пару ключів

1. Увійдіть в систему як користувач «ying»

2. Переконайтеся, що пакет GnuPG встановлено у вашій системі. Впишіть:

    ```
    [ying@serverXY ying]$ rpm -q gnupg
    gnupg-*.*
    ```

    Якщо це не так, попросіть суперкористувача встановити його.

3. Перерахуйте та запишіть усі приховані каталоги у вашому домашньому каталозі.

4. Перелічіть ключі, які зараз є у вашому keyring. Впишіть:

    ```
    [ying@serverXY ying]$ gpg --list-keys
    ```

    !!! note "Примітка"

     У вашому key-ring ще не повинно бути ключів. Але наведена вище команда також допоможе створити середовище за замовчуванням, щоб ви могли успішно створити нову пару ключів з першого разу.

    Знову перерахуйте приховані каталоги у вашому домашньому каталозі. Як називається новий доданий каталог?

5. Використовуйте програму gpg для створення нових пар ключів. Впишіть:

    ```
    [ying@serverXY ying\]$ gpg --gen-key

    ......................................

    gpg: keyring `/home/ying/.gnupg/secring.gpg' created

    gpg: keyring `/home/ying/.gnupg/pubring.gpg' created

    Please select what kind of key you want:

    (1) DSA and ElGamal (default)

    (2) DSA (sign only)

    (5) RSA (sign only)

    Your selection? 1
    ```

    У запиті типу ключа, який ви хочете створити, прийміть значення за замовчуванням, тобто (DSA та ElGamal). Впишіть 1

    !!! warning "Важливо"

     Варіант (1) створить для вас дві пари ключів. Пара ключів DSA буде основною парою ключів - для створення цифрових підписів і підпорядкованою парою ключів ELGamel для шифрування даних.

6. Ви створите розмір ключа ELG-E 1024. Знову прийміть значення за замовчуванням у запиті нижче:

    ```
    DSA key pair will have 1024 bits.

    About to generate a new ELG-E key pair.

    minimum key size is 768 bits

    default key size is 1024 bits

    highest suggested key size is 2048 bits

    What key size do you want? (1024) 1024
    ```

7. Створіть ключі, термін дії яких закінчиться через рік. Введіть «1y» у рядку нижче:

    Please specify how long the key should be valid.

    <kbd>0</kbd> = key does not expire

    <kbd>n</kbd> = key expires in n days

    <kbd>n</kbd><kbd>w</kbd>  = key expires in n weeks

    <kbd>n</kbd><kbd>m</kbd> = key expires in n months

    <kbd>n</kbd><kbd>y</kbd> = key expires in n years

    Key is valid for? (0) 1y

8. Введіть «y», щоб прийняти термін придатності, показаний у запиті:

    ```
    Is this correct (y/n)? y
    ```

9. Створіть ідентифікатор користувача, щоб ідентифікувати свій ключ за допомогою:

    You need a User-ID to identify your key; the software constructs the user id

    from Real Name, Comment and Email Address in this form:

    "Firstname Lastname (any comment) <yourname@serverXY&>"

    Real name: Ying Yang <kbd>ENTER</kbd>

    Comment : my test <kbd>ENTER</kbd>

    Email address: ying@serverXY <kbd>ENTER</kbd>

    У запиті підтвердження введіть «o» (Добре), щоб прийняти правильні значення.

    You selected this USER-ID:

    "Ying Yang (my test) <ying@serverXY>"

    Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? O

10. Виберіть парольну фразу, яку ви НЕ забудете під час наступного запиту:

    ```
    Enter passphrase: **

    Repeat passphrase: **
    ```

## Завдання 2

### Адміністрування ключів

Програма gpg також використовується для адміністрування ключів.

#### Відобразити перелік ваших ключів

1. Увійдіть в систему як користувач ying. Покажіть ключі у вашому key-ring. Впишіть:

    ```
    [ying@serverXY ying\]$  gpg --list-keys

    gpg: WARNING: using insecure memory!

    /home/ying/.gnupg/pubring.gpg

    -----------------------------

    pub 1024D/1D12E484 2003-10-16 Ying Yang (my test) <ying@serverXY>

    sub 1024g/1EDB00AC 2003-10-16 [expires: 2004-10-15]
    ```

2. Щоб придушити дещо дратівливе «попередження» про «незахищену пам’ять», додайте наступний параметр до вашого особистого файлу конфігурації gpg. Впишіть:

    ```
    [ying@serverXY ying]$ echo "no-secmem-warning" >> ~/.gnupg/gpg.conf
    ```

3. Виконайте команду, щоб знову вивести ваші ключі. Переконайтеся, що ваші зміни діють.

4. Перерахуйте свої ключі разом із їхніми підписами. Впишіть:

    ```
    [ying@serverXY ying]$ gpg --list-sigs

    /home/ying/.gnupg/pubring.gpg
    ```

5. Перелічіть лише свої секретні ключі. Впишіть:

    ```
    [ying@serverXY ying]$ gpg --list-secret-keys

    /home/ying/.gnupg/secring.gpg

    -----------------------------

    sec 1024D/1D12E484 2003-10-16 Ying Yang (my test) <ying@serverXY>

    ssb 1024g/1EDB00AC 2003-10-16
    ```

6. Відобразити ключові відбитки пальців. Впишіть:

    ```
    [ying@serverXY ying]$ gpg --fingerprint

    /home/ying/.gnupg/pubring.gpg

    -----------------------------

    pub 1024D/1D12E484 2003-10-16 Ying Yang (my test) <ying@serverXY>

    Key fingerprint = D61E 1538 EA12 9049 4ED3 5590 3BC4 A3C1 1D12 E484

    sub 1024g/1EDB00AC 2003-10-16 [expires: 2004-10-15]

    <span id="anchor-2"></span>Revocation certificates

    Revocation certificates are used to revoke keys in case someone gets knowledge of your secret key or in case you forget your passphrase. They are also useful for other various functions.
    ```

#### Щоб створити сертифікат про відкликання

1. Увійшовши як користувач ying. Створіть свідоцтво про відкликання. Він буде відображатися на стандартному виводі. Впишіть:

    ```
    [ying@serverXY ying]$ gpg --gen-revoke ying@serverXY
    ```

    Дотримуйтесь підказок і введіть свою парольну фразу, коли буде запропоновано це зробити.

2. Тепер створіть сертифікат відкликання, який зберігатиметься у форматі ASCII у файлі під назвою -

    “revoke.asc”. Впишіть:

    ```
    [ying@serverXY ying]$ gpg --output revoke.asc --gen-revoke ying@serverXY
    ```

3. Ви повинні зберігати свідоцтво про відкликання в безпечному місці та навіть зробити роздруковану копію.

### Експорт відкритих ключів

Вся суть усього цього бізнесу шифрування, підписання та дешифрування полягає в тому, що люди хочуть спілкуватися один з одним, але вони також хочуть робити це якомога безпечнішим способом.

З огляду на це - можливо, не настільки очевидне слід сказати:

Ви повинні обмінюватися відкритими ключами, щоб спілкуватися з іншими людьми за допомогою криптосистеми на основі відкритого ключа.

Або принаймні зробіть свій відкритий ключ доступним у будь-якому загальнодоступному місці (рекламні щити, веб-сторінки, сервери ключів, радіо, ТБ, СПАМ через електронну пошту тощо)

#### Щоб експортувати ваші відкриті ключі

1. Експортуйте свій відкритий ключ у двійковому форматі у файл під назвою «ying-pub.gpg». Впишіть:

    ```
    [ying@serverXY ying]$ gpg --output ying-pub.gpg --export <your_key’s_user_ID>
    ```

    !!! note "Примітка"

     Замініть <your_key’s_user_ID> з будь-яким рядком, який правильно визначає ваші ключі. У нашій зразковій системі це значення може бути будь-яким із наведеного нижче:
    
     ying@serverXY, ying, yang
    
     АБО
    
     The actual key ID - 1D12E484

2. Експортуйте відкритий ключ у файл під назвою «ying-pub.asc». Але цього разу згенеруйте його

    ASCII-броньований формат. Впишіть:

    ```
    [ying@serverXY ying]$gpg --output ying-pub.asc --armor --export ying@serverXY 
    ```

3. Використовуйте команду cat, щоб переглянути двійкову версію відкритого ключа ying (ying-pub.gpg)

4. Щоб скинути термінал, введіть: `reset`

5. Використовуйте команду cat, щоб переглянути версію ASCII відкритого ключа ying (ying-pub.asc)

6. Ви помітите, що версія ASCII більше підходить для розміщення на веб-сторінках або спаму тощо.

## Завдання 3

### Цифрові підписи

Для створення та перевірки підписів використовується пара відкритий/приватний ключ, яка відрізняється від шифрування та дешифрування. Використання закритого ключа підписувача для створення підпису полегшує перевірку за допомогою відповідного відкритого ключа.

#### Щоб підписати файл цифровим підписом

1. Створіть файл із назвою «secret-file.txt» із текстом «Hello All». Впишіть:

    ```
    [ying@serverXY ying]$ echo "Hello All" > secret1.txt
    ```

2. Використовуйте cat для перегляду вмісту файлу. Використовуйте команду file, щоб побачити тип файлу.

3. Тепер підпишіть файл своїм цифровим підписом. Впишіть:

    ```
    [ying@serverXY ying]$ gpg -s secret1.txt
    ```
    Введіть свою парольну фразу, коли буде запропоновано.

    Наведена вище команда створить ще один файл «secret1.txt.gpg», який буде стиснутий і до якого додано підпис. Виконайте команду «file» для файлу, щоб перевірити це. Перегляньте файл із cat

4. Перевірте підпис у підписаному файлі “secret1.txt.gpg”. Впишіть:

    ```
    [ying@serverXY ying]$ gpg --verify secret1.txt.gpg

    gpg: Signature made Thu 16 Oct 2003 07:29:37 AM PDT using DSA key ID 1D12E484

    gpg: Good signature from "Ying Yang (my test) <ying@serverXY>"
    ```

5. Створіть інший файл secret2.txt із текстом «Hello All».

6. Підпишіть файл secret2.txt, але цього разу нехай файл буде захищений ASCII. Впишіть:

    ```
    [ying@serverXY ying]$ gpg -sa secret2.txt
    ```

    У вашому pwd буде створено броньований файл ASCII під назвою “secret2.txt.asc”.

7. Використовуйте команду cat, щоб переглянути вміст ASCII-файлу, створеного для вас вище.

8. Створіть ще один файл під назвою «secret3.txt» із текстом «hello dude». Впишіть:

    ```
    [ying@serverXY ying echo "hello dude" > secret3.txt
    ```

9. Додайте свій підпис до тіла файлу, який ви створили вище. Впишіть:

    ```
    [ying@serverXY ying]$ gpg --clearsign secret3.txt
    ```

    Це створить нестиснений файл (secret3.txt.asc), загорнутий у ваш ASCII-підпис.

    Запишіть команду для перевірки створеного для вас підпису файлу.

10. Відкрийте файл, щоб переглянути його вміст за допомогою будь-якого пейджера. Чи можете ви прочитати текст, який ви ввели у файл?

!!! warning "Прочитайте, перш ніж продовжити"

    Переконайтеся, що ваш партнер виконав усі «Вправи 1, 2 і 3» вище, перш ніж перейти до Вправи 4 нижче.
    
    Якщо у вас немає партнера, вийдіть з облікового запису користувача Ying і увійдіть у систему як користувач «me».
    
    Потім повторіть усі «Вправи 1, 2 і 3» як користувач «me».
    
    Потім ви можете виконати вправу 4 нижче. Замініть усі посилання на користувача Ying на "serverPR" на користувача "me" на ServerXY (тобто ваш локальний хост).
    
    У наступній вправі ви можете використовувати або користувача «me@serverXY», або користувача «ying@serverPR».

## Завдання 4

### Імпорт відкритих ключів

У цій вправі ви будете використовувати так звану «Мережу довіри» для спілкування з іншим користувачем.

1. Увійдіть в систему як користувач ying.

2. Зробіть свій ASCII-броньований файл відкритого ключа (ying-pub.asc) доступним для вашого партнера (використайте

    або - me@serverXY або ying@serverPR)

    !!! note "Примітка"
   
        Є кілька способів зробити це, напр. електронна пошта, копіювання та вставка, scp, ftp, збереження на дискеті тощо.
       
         Виберіть для себе найефективніший спосіб.

3. Попросіть свого партнера надати вам доступ до файлу відкритого ключа.

4. Припустимо, що відкритий ключ вашого партнера зберігається у файлі під назвою «me-pub.asc» у вашому pwd;

    Імпортуйте ключ у свій key-ring. Впишіть:

    ```
    [ying@serverXY ying]$ gpg --import me-pub.asc

    gpg: key 1D0D7654: public key "Me Mao (my test) <me@serverXY>" imported

    gpg: Total number processed: 1

    gpg: imported: 1
    ```

5. Тепер перелічіть ключі у вашому key-ring. Впишіть:

    ```
    [ying@serverXY ying]$ gpg --list-keys

    /home/ying/.gnupg/pubring.gpg

    -----------------------------

    pub 1024D/1D12E484 2003-10-16 Ying Yang (my test) <ying@serverXY>

    sub 1024g/1EDB00AC 2003-10-16 [expires: 2004-10-15]

    pub 1024D/1D0D7654 2003-10-16 Me Mao (my test) <me@serverXY>

    sub 1024g/FD20DBF1 2003-10-16 [expires: 2004-10-15]
    ```

6. Зокрема, перелічіть ключ, пов’язаний з ідентифікатором користувача me@serverXY. Впишіть:

    ```
    [ying@serverXY ying]$ gpg --list-keys me@serverXY
    ```

7. Переглянути відбиток ключа для me@serverXY. Впишіть:

    ```
    [ying@serverXY ying]$ gpg --fingerprint me@serverXY
    ```


    <span id="anchor-4"></span>Шифрування та дешифрування файлів

    Процедура шифрування та дешифрування файлів або документів проста.

    Якщо ви хочете зашифрувати повідомлення для користувача ying, ви зашифруєте його за допомогою відкритого ключа користувача ying.

    Після отримання ying потрібно буде розшифрувати повідомлення за допомогою закритого ключа ying.

    ТІЛЬКИ ying може розшифрувати повідомлення або файл, зашифрований відкритим ключем ying

#### Щоб зашифрувати файл

1. Увійшовши в систему як користувач ying, створіть файл під назвою encrypt-sec.txt. Впишіть:

    ```
    [ying@serverXY ying]$ echo "hello" > encrypt-sec.txt
    ```

    Переконайтеся, що ви можете прочитати вміст файлу за допомогою cat.

2. Зашифруйте файл encrypt-sec.txt, щоб лише користувач «me» міг переглядати файл. тобто ви зашифруєте його за допомогою відкритого ключа me@serverXY (який зараз є у вашому key-ring). Впишіть:

    ```
    [ying@serverXY ying]$ gpg --encrypt --recipient me@serverXY encrypt-sec.txt
    ```

    Наведена вище команда створить зашифрований файл під назвою «encrypt-sec.txt.gpg» у вашому pwd.

#### Щоб розшифрувати файл

1. Файл, який ви зашифрували вище, призначений для me@serverXY.

    Спробуйте розшифрувати файл. Впишіть:

    ```
    [ying@serverXY ying]$ gpg --decrypt encrypt-sec.txt.gpg

    gpg: encrypted with 1024-bit ELG-E key, ID FD20DBF1, created 2003-10-16

    "Me Mao (my test) <me@serverXY>"

    gpg: decryption failed: secret key not available
    ```

2. Чи отримали ми тут якийсь цінний урок?

3. Зробіть зашифрований файл, який ви створили, доступним для належного власника та попросіть його виконати наведену вище команду, щоб розшифрувати файл. Чи вдалося їм розшифрувати файл.

    !!! note "Примітка"
   
        Будьте дуже обережні, розшифровуючи двійкові файли (наприклад, програми), тому що після успішного розшифрування файлу gpg спробує надіслати вміст файлу на стандартний вивід.

    Візьміть звичку використовувати команду нижче під час розшифровки файлів:

    ```
    [ying@serverXY ying]$ gpg --output encrypt-sec --decrypt encrypt-sec.txt.gpg
    ```

    Це примусово надсилає вихідні дані у файл під назвою «encrypt-sec».

    Який потім можна переглянути (або запустити) за допомогою будь-якої програми, яка підходить для типу файлу (або вмісту).

    !!! Tip "Поради"

     Більшість команд і параметрів, які використовуються з програмою gpg, також мають короткі форми, що призводить до того, що користувач менше вводить текст у командному рядку. наприклад.

            ```
            gpg --encrypt --recipient me@serverXY encrypt-sec.txt
            ```


         Коротка форма наведеної вище команди:

            ```
            gpg -e -r me@serverXY encrypt-sec.txt
            ```

4. Щоб зашифрувати рядок "hello" і надіслати його як броньоване повідомлення ASCII користувачеві з адресою електронної пошти ying@serverXY, використовуйте команду нижче:

    ```
    echo "hello" | gpg -ea -r ying@serverXY | mail ying@serverXY
    ```

5. Щоб зашифрувати файл "your_file" відкритим ключем "me@serverXY" і записати його в "your_file.gpg"

    підписавши його своїм ідентифікатором користувача (використовуючи свій цифровий підпис), використовуйте команду нижче:

    ```
    gpg -se -r me@serverXY your_file
    ```

6. Існує загальнодоступний сервер ключів на wwwkeys.pgp.net. Ви можете використовувати gpg, щоб завантажити туди свій ключ за допомогою:

    gpg --send-keys <your_real_email_address> --keyserver wwwkeys.pgp.net

## OpenSSH (www.openssh.org)

OpenSSH — це реалізація протоколу SSH (Secure SHell) OpenBSD.

Це БЕЗКОШТОВНА версія набору інструментів для підключення до мережі протоколу SSH. OpenSSH шифрує весь трафік (включаючи паролі), щоб ефективно усунути підслуховування, викрадення з’єднання та інші атаки на рівні мережі. Крім того, OpenSSH надає безліч можливостей безпечного тунелювання, а також різноманітні методи автентифікації.

Це допомагає забезпечити безпечний зашифрований зв’язок між двома ненадійними хостами через незахищену мережу (наприклад, Інтернет).

Він включає як компоненти на стороні сервера, так і набір програм на стороні клієнта.

*sshd*

На стороні сервера є демон безпечної оболонки (`sshd`). `sshd` — це демон, який прослуховує підключення клієнтів.

Він створює новий демон для кожного вхідного з’єднання. Розгалужені демони обробляють обмін ключами, шифрування, автентифікацію, виконання команд і обмін даними. Згідно зі сторінкою довідки sshd, `sshd` працює наступним чином:

Демон OpenSSH SSH підтримує лише протокол SSH 2. Кожен хост має спеціальний ключ, який використовується для ідентифікації хоста. Щоразу, коли клієнт підключається, демон відповідає своїм публічним ключем хосту. Клієнт порівнює ключ хоста зі своєю базою даних, щоб переконатися, що він не змінився. Передня безпека забезпечується через ключову угоду Діффі-Хеллмана. Ця угода ключа призводить до спільного ключа сеансу. Решта сеансу шифрується за допомогою симетричного шифру.

Клієнт вибирає алгоритм шифрування із запропонованих сервером. Крім того, цілісність сеансу забезпечується за допомогою коду автентифікації криптографічного повідомлення (hmac-md5, hmac-sha1, umac-64, umac-128, hmac-sha2-256 або hmac-sha2-512).

Нарешті, сервер і клієнт відкривають діалогове вікно автентифікації. Клієнт намагається автентифікувати себе за допомогою автентифікації на основі хоста, автентифікації відкритого ключа, автентифікації GSSAPI, автентифікації виклик-відповідь або автентифікації пароля.

Протокол SSH2, реалізований у OpenSSH, стандартизовано робочою групою «IETF secsh».

*ssh*

Набір програм клієнта включає `ssh`. Це програма, яка використовується для входу у віддалені системи, а також може використовуватися для виконання команд у віддалених системах.

## Завдання 5

### `sshd`

Деякі вправи охоплюють демон сервера `sshd`.

```
Usage: sshd [options]

Options:

 -f file Configuration file (default /etc/ssh/sshd_config)
 -d Debugging mode (multiple -d means more debugging)
 -i Started from inetd
 -D Do not fork into daemon mode
 -t Only test configuration file and keys
 -q Quiet (no logging)
 -p port Listen on the specified port (default: 22)
 -k seconds Regenerate server key every this many seconds (default: 3600)
 -g seconds Grace period for authentication (default: 600)
 -b bits Size of server RSA key (default: 768 bits)
 -h file File from which to read host key (default: /etc/ssh/ssh_host_key)
 -u len Maximum hostname length for utmp recording
 -4 Use IPv4 only
 -6 Use IPv6 only
 -o option Process the option as if it was read from a configuration file.
```

Більшість систем Linux із коробки вже мають сервер OpenSSH, налаштований і запущений із деякими параметрами за замовчуванням. Конфігураційний файл для `sshd` зазвичай знаходиться в `/etc/ssh/` і має назву `sshd_config`.

### `sshd_config`

1. Відкрийте конфігураційний файл SSH-сервера будь-яким пейджером і вивчіть його. Впишіть:

    ```
    [root@serverXY root]# less /etc/ssh/sshd_config
    ```

    !!! note "Примітка" 

     `sshd_config` є досить дивним конфігураційним файлом. На відміну від інших конфігураційних файлів Linux, коментарі (#) у файлі `sshd_config` позначають значення параметрів за замовчуванням. (тобто коментарі представляють уже скомпільовані значення за замовчуванням.)

2. Перегляньте сторінку довідки для `sshd_config` і поясніть, що роблять наведені нижче параметри?

    - AuthorizedKeysFile
    - Ciphers
    - Port
    - Protocol
    - X11Forwarding
    - HostKey

3. Змініть свій pwd на каталог /etc/ssh/.

4. Перелічіть усі файли в `/etc/ssh/`

### Створення ключів хоста

Ваш сервер SSH уже має ключі хоста, які він використовує. Ці ключі були згенеровані під час першого встановлення вашої системи. У цій вправі ви дізнаєтеся, як створити ключі хост-типу для вашого сервера.

#### Для створення ключів хосту для вашого сервера

1. Створіть новий каталог під вашим pwd. Назвіть це запасними ключами. cd у новий каталог. Впишіть:

    ```
    [root@serverXY ssh]# mkdir spare-keys && cd spare-keys
    ```

2. Використовуйте програму `ssh-keygen`, щоб створити ключ хоста з такими характеристиками:

    - тип ключа має бути "rsa"
    - Ключ не повинен мати коментарів
    - Файл закритого ключа повинен мати назву - ssh_host_rsa_key
    - Ключ не повинен використовувати парольну фразу

    Впишіть:

    ```
    [root@serverXY spare-keys]# ssh-keygen -q -t rsa -f ssh_host_rsa_key -C '' -N ''
    ```

    !!! Question "Питання" 
  Що вам потрібно зробити, щоб змусити демон sshd використовувати ключ хоста, який ви щойно згенерували?

3. Перегляньте відбиток ключа, який ви створили вище. Впишіть:

    ```
    [root@serverXY spare-keys]# ssh-keygen -l -f ssh_host_rsa_key
    ```

4. Перегляньте відбиток ключа, який ви створили, але цього разу додайте візуальне зображення відбитка ключа в ASCII. Впишіть:

    ```
    [root@localhost spare-keys]# ssh-keygen -l -v -f ssh_host_rsa_key
    3072 SHA256:1kQS0Nz4NofWkgqU0y+DxmDoY6AmGsF40GwZkobD8DM ssh_host_rsa_key.pub (RSA)
    +---[RSA 3072]----+
    |X=.+  .*o+.      |
    |B*B o + =o.      |
    |oBE. + o o.+     |
    |+.+o  = ooX o    |
    |+o . . .S*.+     |
    |.      ..        |
    |                 |
    |                 |
    |                 |
    +----[SHA256]-----+
    ```

5. Запишіть команду для створення ключа типу dsa під назвою «ssh_host_dsa_key» без коментарів і фрази-паролю.

6. Перевірити стан служби `sshd`. Впишіть:

    ```bash
    [root@localhost ~]# systemctl -n 0 status sshd.service
    ● sshd.service - OpenSSH server daemon
    Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled; vendor preset: enabled)
    Active: active (running) since Thu 2023-10-05 23:56:34 EDT; 3 days ago
    ...<SNIP>...
    ```
7. Якщо ви вносите будь-які зміни у конфігураційний файл `sshd`, ви можете перезапустити службу `sshd`, виконавши:

    ```bash
    [root@localhost ~]# systemctl restart sshd.service
    ```
## Завдання 6

### `ssh`

Цей розділ охоплює вправи, що стосуються клієнтської програми `ssh`.

```
usage: ssh [-46AaCfGgKkMNnqsTtVvXxYy] [-B bind_interface]
           [-b bind_address] [-c cipher_spec] [-D [bind_address:]port]
           [-E log_file] [-e escape_char] [-F configfile] [-I pkcs11]
           [-i identity_file] [-J [user@]host[:port]] [-L address]
           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]
           [-Q query_option] [-R address] [-S ctl_path] [-W host:port]
           [-w local_tun[:remote_tun]] destination [command]
```

#### Щоб використовувати `ssh`

1. Увійдіть на serverXY як користувач me.

2. Використовуйте `ssh` для підключення до serverPR. Впишіть:

    ```
    [me@serverXY me]$ ssh serverPR
    ```
    Введіть пароль користувача me, коли буде запропоновано. Якщо ви отримаєте будь-які попередження, введіть «yes», щоб продовжити.

3. Після входу створіть каталог під назвою - myexport і створіть порожній файл під назвою foobar у новому каталозі. Впишіть:

    ```
    [me@serverPR me]$ mkdir ~/myexport && touch myexport/foobar
    ```

4. Вийти з serverPR. Впишіть:

    ```
    [me@serverPR me]$ exit
    ```
    Ви повернетеся до локальної оболонки на serverXY.

5. Використовуйте `ssh`, щоб віддалено виконати команду “ls” для рекурсивного перегляду списку файлів у моєму домашньому каталозі на serverPR. Впишіть:

    ```
    [root@localhost ~]# ssh me@serverPR 'ls -lR /home/me/myexport'
    me@localhost's password:
    ...<SNIP>...
    /home/me/myexport:
    total 0
    -rw-rw-r-- 1 me me 0 Oct  9 16:48 foobar
    ```

    Введіть мій пароль користувача me, коли буде запропоновано. Якщо ви отримаєте будь-які попередження, введіть «yes», щоб продовжити.

6. Перебуваючи на сервері serverXY, спробуйте віддалено перезавантажити serverPR як користувач `ying`. Впишіть:

    ```
    [me@localhost ~]# ssh -l ying localhost 'reboot'
    ying@localhost's password:
    ...<SNIP>...
    ```

    Коли буде запропоновано, введіть пароль користувача ying.

    !!! Question "Питання"

     Чи міг користувач віддалено перезавантажити serverPR? Чому ying не може віддалено перезавантажити serverPR?

7. На сервері XY спробуйте віддалено переглянути статус служби `sshd`, що працює на serverPR, як користувач `ying`. Впишіть:

    ```bash
    [root@localhost ~]# ssh -l ying localhost 'systemctl status sshd.service'
    ying@localhost's password:
    ● sshd.service - OpenSSH server daemon
    ```

8. З сервера XY спробуйте віддалено перезапустити службу `sshd`, яка працює на сервері PR від імені користувача `ying`. Впишіть:

    ```bash
    [root@localhost ~]# ssh -l ying localhost 'systemctl restart sshd.service'
    ying@localhost's password:
    Failed to restart sshd.service: Interactive authentication required.
    See system logs and 'systemctl status sshd.service' for details.
    ```

    !!! Questions "Питання"

     - Чи міг користувач віддалено переглянути статус служби sshd на serverPR? 
     - Чи зміг користувач віддалено перезапустити службу sshd на serverPR?
     - Напишіть коротке пояснення поведінки, яку ви спостерігаєте.

9. Введіть «exit», щоб вийти з serverPR і повернутися до serverXY.

### `scp` - безпечне копіювання (програма віддаленого копіювання файлів)

`scp` копіює файли між хостами в мережі. Він використовує SSH для передачі даних, використовує ту саму автентифікацію та забезпечує таку саму безпеку, що й `ssh`.

```
usage: scp [-346BCpqrTv] [-c cipher] [-F ssh_config] [-i identity_file]
            [-J destination] [-l limit] [-o ssh_option] [-P port]
            [-S program] source ... target
```

#### Щоб використовувати `scp`

1. Переконайтеся, що ви все ще ввійшли як користувач `я` на сервері XY.

2. Створіть каталог у своєму домашньому каталозі під назвою `myimport` і перейдіть до каталогу.

3. Використовуйте `scp`, щоб скопіювати всі файли в каталозі “/home/me/myexport/” на віддаленому сервері PR. (крапка «.» у кінці команди важлива). Впишіть:

    ```
    [me@localhost ~myimport]# scp serverPR:/home/me/myexport  .
    me@serverPR's password:
    scp: /home/me/myexport: not a regular file
    ```

    !!! Question "Питання"

     Напишіть коротке пояснення, чому попередня команда не вдалася?


4. Виконайте попередню команду знову, але цього разу додайте рекурсивний параметр до `scp`. Впишіть:

    ```bash
    [me@localhost ~myimport]# scp -r me@serverPR:/home/me/myexport  .
    me@localhost's password:
    foobar
    ```

    !!! Question "Питання"

     Яка різниця між варіаціями цих двох команд? І за яких обставин вони матимуть однаковий результат?:
    
     - scp me@serverPR:/home/me/myexport.
    
     та
    
     - scp serverPR:/home/me/myexport.

5. Яка команда скопіює всі файли в “/home/me/.gnugp/” на serverPR?

6. Тепер скопіюйте домашній каталог ying на serverPR.  Впишіть:

    ```
    [me@localhost ~myimport]# scp -r  ying@localhost:/home/ying/  ying_home_directory_on_serverPR
    ```

7. Знову виконайте невеликий варіант попередньої команди, щоб скопіювати домашній каталог ying на serverPR.  Впишіть:

    ```
    [me@localhost ~myimport]# scp -r  ying@localhost:/home/ying  ying_home_directory_on_serverPR
    ```

    !!! Questions "Питання"

     Яка невелика, але дуже важлива різниця між варіаціями двох попередніх команд? І який результат кожної команди?
    
     - `scp -r  ying@localhost:/home/ying/  ying_home_directory_on_serverPR`
    
     та
    
     -  `scp -r  ying@localhost:/home/ying  ying_home_directory_on_serverPR`

8. Використовуйте команду `ls -alR`, щоб переглянути перелік вмісту двох попередніх кроків. Впишіть:

    ```bash
    [me@localhost ~myimport]# ls -al ying_home_directory_on_serverPR/
    ```

    !!! Question "Питання"

     Надайте коротке пояснення виводу команди `ls -alR`? Поясніть, наприклад, чому у вас є дублікати цих файлів .bash_history, .bashrc ...

## Завдання 7

### Створення відкритих і закритих ключів користувача для SSH

Кожному користувачеві, який хоче використовувати SSH з автентифікацією RSA або DSA, потрібна пара відкритого та закритого ключів. Програму `ssh-keygen` можна використати для створення цих ключів (так само, як вона використовувалася раніше, коли ви створювали нові ключі хосту для вашої системи)

!!! TIP "Підказка"

    Основна відмінність між ключами хоста та користувача полягає в тому, що настійно рекомендується захищати їх за допомогою парольної фрази. Парольна фраза – це пароль, який використовується для шифрування закритого ключа [простого тексту].

Загальнодоступний ключ зберігається у файлі з тим же ім’ям, що й закритий ключ, але з розширенням «.pub». Немає простого способу відновити втрачену парольну фразу. Необхідно створити новий ключ, якщо парольну фразу втрачено або забуто.

#### Щоб створити відкритий/приватний ключ автентифікації користувача

1. Увійдіть на локальну машину як користувач ying.

2. Запустіть програму `ssh-keygen`, щоб створити ключ типу «dsa» із довжиною за замовчуванням. Впишіть:

    ```bash
    [ying@serverXY ying]$ ssh-keygen -t dsa

    Generating public/private dsa key pair.
    ```

    Натисніть <kbd>ENTER</kbd>, щоб прийняти розташування файлу за замовчуванням.

    ```bash
    Enter file in which to save the key (/home/ying/.ssh/id_dsa):
    Created directory '/home/ying/.ssh'.
    ```

    Вам двічі буде запропоновано ввести парольну фразу. Введіть хорошу парольну фразу, яку досить складно вгадати. Натисніть <kbd>ENTER</kbd> після кожного запиту.

    ```bash
    Enter passphrase (empty for no passphrase):     *****
    Enter same passphrase again:                    *****
    Your identification has been saved in /home/ying/.ssh/id_dsa.
    Your public key has been saved in /home/ying/.ssh/id_dsa.pub.
    The key fingerprint is:
    SHA256:ne7bHHb65e50HJPchhbiSvEZ0AZoQCEnnFdBPedGrDQ ying@localhost.localdomain
    The key's randomart image is:
    +---[DSA 1024]----+
    |   .oo==++o+     |
    |    o+. o E.*    |
    ...<SNIP>...
    ```

    Після успішного завершення ви побачите повідомлення про те, що вашу ідентифікацію та відкритий ключі збережено в каталозі `/home/ying/.ssh/`.

3. cd у ваш каталог `~/.ssh/`. Список файлів у каталозі.

4. Що таке команда “ssh-keygen” для перегляду відбитків ваших ключів?

5. Використовуйте команду cat, щоб переглянути вміст вашого файлу відкритого ключа (тобто `~/.ssh/id_dsa.pub`).

## Завдання 8

### Автентифікація за допомогою відкритого ключа

Досі ви використовували автентифікацію на основі пароля для входу в облікові записи користувачів на serverPR.

Це означає, що для успішного входу ви повинні знати пароль відповідного облікового запису на віддаленій стороні.

У цій вправі ви налаштуєте автентифікацію за допомогою відкритого ключа між вашим обліковим записом користувача на serverXY та обліковим записом користувача ying на serverPR.

#### Щоб налаштувати автентифікацію за допомогою відкритого ключа

1. Увійдіть на локальну машину як користувач *ying*.

2. cd у ваш каталог «~/.ssh».

3. Введіть наведені нижче команди точно так, як показано. Вам буде запропоновано ввести пароль ying на serverPR. Впишіть:

    ```
    [ying@serverXY .ssh]$ cat id_dsa.pub | ssh ying@serverPR \ 

    '(cd ~/.ssh && cat - >> authorized_keys && chmod 600 authorized_keys)'
    ```

    Якщо говорити простою мовою, наведена вище команда звучить так:

    a. cat вміст вашого файлу відкритого ключа DSA та передайте/надішліть ( | ) вихід до `ssh ying@serverPR`

    b. запустіть команду “cd ~/.ssh && cat - >> authorized_keys && chmod 600 authorized_keys” як користувач, який знаходиться на serverPR.

    !!! Note "Примітка" 

     Мета попередньої складної на вигляд команди полягає в тому, щоб скопіювати та додати вміст вашого файлу відкритого ключа до “/home/ying/.ssh/authorized_keys” на serverPR і надати йому правильні дозволи.

    !!! tip "Порада"

     Ви можете використовувати утиліту `ssh-copy-id`, щоб легко та більш витончено налаштувати автентифікацію відкритих/приватних ключів між системами. `ssh-copy-id` — це сценарій, який використовує `ssh` для входу на віддалену машину (імовірно, спочатку використовуючи пароль для входу. 
     Він складає список з одного або кількох відбитків пальців (як описано нижче) і намагається ввійти за допомогою кожної клавіші, щоб побачити, чи якийсь із них уже встановлено. Потім він збирає список тих, кому не вдалося ввійти, і за допомогою `ssh` дозволяє ввійти за допомогою цих ключів у віддалену систему. За замовчуванням він додає ключі, додаючи їх до ~/.ssh/authorized_keys віддаленого користувача (створюючи файл і каталог, якщо необхідно).

4. Після додавання відкритого ключа до файлу authorized_keys у віддаленій системі. Спробуйте увійти на serverPR як ying через ssh. Впишіть:

    ```
    [ying@serverXY .ssh]$ ssh serverPR
    Enter passphrase for key '/home/ying/.ssh/id_dsa': **
    ```

    Зверніть увагу, що цього разу вам буде запропоновано ввести парольну фразу замість пароля користувача. Введіть парольну фразу, яку ви створили раніше під час створення ключів.

5. Після успішного входу на serverPR - вийдіть.

## Завдання 9

### `ssh-agent`

Згідно зі сторінкою довідки, `ssh-agent` — це програма для зберігання закритих ключів, які використовуються для автентифікації відкритих ключів (RSA, DSA, ECDSA, Ed25519). Ідея полягає в тому, що `ssh-agent` запускається на початку сеансу користувача або сеансу входу, а всі інші вікна або програми запускаються як клієнти для `ssh-agent` програма. За допомогою змінних середовища можна знайти агента та автоматично використовувати його для автентифікації під час входу на інші машини за допомогою `ssh`.

```
СИНОПСИС
     ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash] [-P pkcs11_whitelist] [-t life] [command [arg ...]]
     ssh-agent [-c | -s] -k
```

У цій вправі ви дізнаєтеся, як налаштувати агента, щоб вам не доводилося вводити свою парольну фразу щоразу, коли ви хочете підключитися до іншої системи за допомогою автентифікації з відкритим ключем.

1. Увійдіть у свою локальну систему як користувач *ying*.

2. Введіть команду нижче:

    ```
    [ying@localhost ~]$ eval `ssh-agent`
    Agent pid 6354
    ```

    Зверніть увагу на значення ідентифікатора процесу агента (PID) у вихідних даних.

3. Запустіть програму `ssh-add`, щоб отримати список відбитків пальців усіх [публічних/приватних] ідентифікацій, які зараз представляє агент. Впишіть:

    ```bash
    [ying@localhost ~]$ ssh-add -l
    The agent has no identities.
    ```

    Ви ще не повинні мати жодних ідентифікаторів у списку.

4. Використовуйте програму `ssh-add` без будь-яких опцій, щоб додати свої ключі до агента, який ви запустили вище. Впишіть:

    ```bash
    [ying@localhost ~]$ ssh-add
    ```
    Введіть свою парольну фразу, коли буде запропоновано.

    ```bash
    Enter passphrase for /home/ying/.ssh/id_dsa:
    Identity added: /home/ying/.ssh/id_dsa (ying@localhost.localdomain)
    ```

5. Тепер знову запустіть команду `ssh-add`, щоб отримати список відомих ідентифікаторів відбитків пальців. Впишіть:

    ```bash
    [ying@localhost ~]$ ssh-add -l
    1024 SHA256:ne7bHHb65e50.......0AZoQCEnnFdBPedGrDQ ying@server (DSA)
    ```

6. Як користувач *ying*, спробуйте підключитися віддалено до serverPR і запустіть просту тестову команду.

    Якщо припустити, що ви зробили все правильно до цього моменту щодо налаштування та збереження відповідних ключів, ви зробили правильно до цього моменту, вам НЕ буде запропоновано ввести пароль або парольну фразу. Впишіть:

    ```
    [ying@serverXY .ssh]$ ssh serverPR 'ls /tmp'
    ```

7. Якщо ви закінчили і більше не потребуєте послуг `ssh-агента` або просто хочете повернутися до автентифікації на основі ключів, ви можете видалити всі [private/public] ідентифікаційні дані з агента. Впишіть:

    ```bash
    [ying@localhost ~]$ ssh-add -D
    All identities removed.
    ```

8. Все зроблено! 
