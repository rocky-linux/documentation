- - -
Title: Лабораторна робота 9 - Криптографія author: Wale Soyinka contributors: Steven Spencer, Ganna Zhyrnova
- - -


# Lab 9: Криптографія

## Завдання

Після виконання цієї лабораторної роботи ви зможете:

- застосовувати криптографічні концепції для захисту даних і зв'язку

Приблизний час виконання цієї лабораторної роботи: 120 хвилин
> Троє можуть зберігати таємницю, якщо двоє з них мертві...
> 
> -- Benjamin Franklin

## Загальні терміни та визначення криптографії

### Криптографія

У загальному повсякденному вживанні криптографія — це дія або мистецтво написання таємними символами. На технічному жаргоні це можна визначити як науку про використання математики для шифрування та дешифрування даних.

### Криптоаналіз

Криптоаналіз — це дослідження того, як скомпрометувати (подолати) криптографічні механізми. Це наука про злом коду, декодування секретів, порушення схем автентифікації та загалом зламу криптографічних протоколів.

### Криптологія

Криптологія - це дисципліна, яка складається з криптографії та криптоаналізу. Криптологія — розділ математики, що вивчає математичні основи криптографічних методів.

### Шифрування

Шифрування перетворює дані у форму, яку майже неможливо прочитати без відповідних знань (наприклад, ключа). Його метою є забезпечення конфіденційності, зберігаючи інформацію прихованою від будь-кого, для кого вона не призначена.

### Розшифровка

Дешифрування є протилежністю шифруванню; він перетворює зашифровані дані в зрозумілу форму.

### Шифр

Метод шифрування і дешифрування називається шифром.

Хеш-функції (алгоритми дайджесту)

Криптографічні хеш-функції використовуються в різних контекстах, наприклад, для обчислення дайджесту повідомлення під час створення цифрового підпису. Хеш-функція стискає біти повідомлення до хеш-значення фіксованого розміру, щоб рівномірно розподілити можливі повідомлення між можливими хеш-значеннями. Криптографічна хеш-функція робить це таким чином, що надзвичайно ускладнює створення повідомлення, яке хешує до певного хеш-значення. Нижче наведено кілька прикладів найвідоміших і найпоширеніших хеш-функцій.

**a)** - **SHA-1 (Secure Hash Algorithm)** - це криптографічний хеш-алгоритм, опублікований урядом Сполучених Штатів. Він створює 160-бітне хеш-значення з рядка довільної довжини. Вважається, що це дуже добре.

**b)**- **MD5 (Message Digest Algorithm 5)** – це криптографічний геш-алгоритм, розроблений у RSA Laboratories. Його можна використовувати для хешування байтового рядка довільної довжини до 128-бітного значення.

### Алгоритм

Він описує покрокову процедуру розв’язування задачі, особливо усталену, рекурсивну обчислювальну процедуру для розв’язання задачі за кінцеву кількість кроків. Технічно алгоритм повинен досягти результату після кінцевої кількості кроків. Ефективність алгоритму можна виміряти як кількість елементарних кроків, необхідних для вирішення проблеми. Існує два класи алгоритмів на основі ключів. Це:

**a) **-- **Алгоритми симетричного шифрування (секретний ключ)**

Симетричні алгоритми використовують один і той самий ключ для шифрування та дешифрування (або ключ дешифрування легко отримати з ключа шифрування). Алгоритми із секретним ключем використовують один і той самий ключ для шифрування та дешифрування (або один легко вивести з іншого). Це більш простий підхід до шифрування даних, він математично менш складний, ніж криптографія з відкритим ключем. Симетричні алгоритми можна розділити на потокові шифри та блочні шифри. Потокові шифри можуть шифрувати один біт відкритого тексту за раз, тоді як блочні шифри беруть кілька бітів (зазвичай 64 біти в сучасних шифрах) і шифрують їх як єдине ціле. Симетричні алгоритми набагато швидше виконуються на комп’ютері, ніж асиметричні.

Прикладами симетричних алгоритмів є AES, 3DES, Blowfish, CAST5, IDEA та Twofish.

**b) -- Асиметричні алгоритми (алгоритми з відкритим ключем)**

Асиметричні алгоритми, з іншого боку, використовують різні ключі для шифрування та дешифрування, і ключ дешифрування не може бути отриманий з ключа шифрування. Асиметричні шифри дозволяють ключу шифрування бути відкритим, дозволяючи будь-кому шифрувати за допомогою ключа, тоді як лише відповідний одержувач (який знає ключ розшифровки) може розшифрувати повідомлення. Ключ шифрування також називається відкритим ключем, а ключ дешифрування – закритим або секретним ключем.

RSA, ймовірно, найвідоміший алгоритм асиметричного шифрування.

### Цифровий підпис

Цифровий підпис прив’язує документ до власника певного ключа.

Цифровий підпис документа — це частина інформації, яка базується як на документі, так і на закритому ключі підписувача. Зазвичай він створюється за допомогою хеш-функції та функції приватного підпису (шифрування за допомогою закритого ключа підписувача). Цифровий підпис — це невелика кількість даних, створена за допомогою певного секретного ключа, і відкритий ключ можна використовувати для перевірки того, що підпис було згенеровано за допомогою відповідного закритого ключа.

Кілька методів створення та перевірки цифрових підписів доступні у вільному доступі, але найвідомішим є алгоритм відкритого ключа RSA.

### Криптографічні протоколи

Криптографія працює на багатьох рівнях. На одному рівні у вас є алгоритми, такі як блокові шифри та криптосистеми з відкритим ключем. Спираючись на них, ви отримуєте протоколи, а на основі протоколів ви знаходите програми (або інші протоколи). Нижче наведено список типових щоденних програм, які використовують криптографічні протоколи. Ці протоколи побудовані на основі криптографічних алгоритмів нижчого рівня.

**i.)** Безпека сервера доменних імен (DNSSEC)

Це протокол для безпечних розподілених служб імен. Наразі він доступний як чернетка в Інтернеті.

**ii.)** Secure Socket Layer (SSL)

SSL — це один із двох протоколів, які використовуються для безпечних WWW-з’єднань (інший — SHTTP). Безпека WWW стала необхідною, оскільки все більша кількість конфіденційної інформації, такої як номери кредитних карток, передається через Інтернет.

**iii.)** Secure Hypertext Transfer Protocol (SHTTP)

Це ще один протокол для забезпечення більшої безпеки для транзакцій WWW.

**iv.)** Безпека електронної пошти та супутні послуги

**GnuPG** – GNU Privacy Guard – відповідає запропонованому Інтернет-стандарту OpenPGP, описаному в RFC2440.

**v.)** Протокол SSH2

Цей протокол є універсальним для потреб Інтернету та зараз використовується в програмному забезпеченні SSH2. Протокол використовується для захисту термінальних сеансів і TCP-з'єднань.

У наступних вправах розглядаються дві програми, які використовують криптографічні протоколи - GnuPG і OpenSSH.

## Завдання 1

### GnuPG

GnuPG (GNU Privacy Guard) — це набір програм для шифрування з відкритим ключем і цифрових підписів. Інструменти можна використовувати для шифрування даних і створення цифрових підписів. Він також включає розширений засіб керування ключами. GnuPG використовує криптографію з відкритим ключем, щоб дозволити користувачам безпечно спілкуватися.

Виконайте наступні вправи як звичайний користувач. напр. користувач ying

Щоб створити нову пару ключів

1. Увійдіть в систему як користувач «ying»

2. Переконайтеся, що пакет GnuPG встановлено у вашій системі. Впишіть:

    ```
    [ying@serverXY ying]$ rpm -q gnupg
    gnupg-*.*
    ```

    Якщо це не так, попросіть суперкористувача встановити його.

3. Перерахуйте та запишіть усі приховані каталоги у вашому домашньому каталозі.

4. Перелічіть ключі, які зараз є у вашому keyring. Впишіть:

    ```
    [ying@serverXY ying]$ gpg --list-keys
    ```

    !!! note "Примітка"

     У вашому key-ring ще не повинно бути ключів. Але наведена вище команда також допоможе створити середовище за замовчуванням, щоб ви могли успішно створити нову пару ключів з першого разу.

    Знову перерахуйте приховані каталоги у вашому домашньому каталозі. Як називається новий доданий каталог?

5. Використовуйте програму gpg для створення нових пар ключів. Впишіть:

    ```
    [ying@serverXY ying\]$ gpg --gen-key

    ......................................

    gpg: keyring \`/home/ying/.gnupg/secring.gpg' created

    gpg: keyring \`/home/ying/.gnupg/pubring.gpg' created

    Please select what kind of key you want:

    (1) DSA and ElGamal (default)

    (2) DSA (sign only)

    (5) RSA (sign only)

    Your selection? 1
    ```

    У запиті типу ключа, який ви хочете створити, прийміть значення за замовчуванням, тобто (DSA та ElGamal). Впишіть 1

    !!! warning "Важливо"

     Варіант (1) створить для вас дві пари ключів. Пара ключів DSA буде основною парою ключів - для створення цифрових підписів і підпорядкованою парою ключів ELGamel для шифрування даних.

6. Ви створите розмір ключа ELG-E 1024. Знову прийміть значення за замовчуванням у запиті нижче:

    ```
    DSA key pair will have 1024 bits.

    About to generate a new ELG-E key pair.

    minimum key size is 768 bits

    default key size is 1024 bits

    highest suggested key size is 2048 bits

    What key size do you want? (1024) 1024
    ```

7. Створіть ключі, термін дії яких закінчиться через рік. Введіть «1y» у рядку нижче:

    Please specify how long the key should be valid.

    <kbd>0</kbd> = key does not expire

    <kbd>n</kbd> = key expires in n days

    <kbd>n</kbd><kbd>w</kbd>  = key expires in n weeks

    <kbd>n</kbd><kbd>m</kbd> = key expires in n months

    <kbd>n</kbd><kbd>y</kbd> = key expires in n years

    Key is valid for? (0) 1y

8. Введіть «y», щоб прийняти термін придатності, показаний у запиті:

    ```
    Is this correct (y/n)? y
    ```

9. Створіть ідентифікатор користувача, щоб ідентифікувати свій ключ за допомогою:

    You need a User-ID to identify your key; the software constructs the user id

    from Real Name, Comment and Email Address in this form:

    "Firstname Lastname (any comment) &lt;yourname@serverXY&gt;"

    Real name: Ying Yang <kbd>ENTER</kbd>

    Comment : my test <kbd>ENTER</kbd>

    Email address: ying@serverXY <kbd>ENTER</kbd>

    У запиті підтвердження введіть «o» (Добре), щоб прийняти правильні значення.

    You selected this USER-ID:

    "Ying Yang (my test) &lt;ying@serverXY&gt;"

    Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? O

10. Виберіть парольну фразу, яку ви НЕ забудете під час наступного запиту:

    ```
    Enter passphrase: \*\*\*\*\*\*\*\*

    Repeat passphrase: \*\*\*\*\*\*\*\*
    ```

## Завдання 2

### Адміністрування ключів

Програма gpg також використовується для адміністрування ключів.

Відобразити перелік ваших ключів

1. Увійдіть в систему як користувач ying. Покажіть ключі у вашому key-ring. Впишіть:

    ```
    [ying@serverXY ying\]$  gpg --list-keys

    gpg: WARNING: using insecure memory!

    /home/ying/.gnupg/pubring.gpg

    -----------------------------

    pub 1024D/1D12E484 2003-10-16 Ying Yang (my test) &lt;ying@serverXY&gt;

    sub 1024g/1EDB00AC 2003-10-16 \[expires: 2004-10-15\]
    ```

2. Щоб придушити дещо дратівливе «попередження» про «незахищену пам’ять», додайте наступний параметр до вашого особистого файлу конфігурації gpg. Впишіть:

    ```
    [ying@serverXY ying\]$ echo "no-secmem-warning" &gt;&gt; ~/.gnupg/gpg.conf
    ```

3. Виконайте команду, щоб знову вивести ваші ключі. Переконайтеся, що ваші зміни діють.

4. Перерахуйте свої ключі разом із їхніми підписами. Впишіть:

    ```
    [ying@serverXY ying\]$ gpg --list-sigs

    /home/ying/.gnupg/pubring.gpg
    ```

5. Перелічіть лише свої секретні ключі. Впишіть:

    ```
    [ying@serverXY ying\]$ gpg --list-secret-keys

    /home/ying/.gnupg/secring.gpg

    -----------------------------

    sec 1024D/1D12E484 2003-10-16 Ying Yang (my test) &lt;ying@serverXY&gt;

    ssb 1024g/1EDB00AC 2003-10-16
    ```

6. Відобразити ключові відбитки пальців. Впишіть:

    ```
    [ying@serverXY ying\]$ ***gpg --fingerprint***

    /home/ying/.gnupg/pubring.gpg

    -----------------------------

    pub 1024D/1D12E484 2003-10-16 Ying Yang (my test) &lt;ying@serverXY&gt;

    Key fingerprint = D61E 1538 EA12 9049 4ED3 5590 3BC4 A3C1 1D12 E484

    sub 1024g/1EDB00AC 2003-10-16 \[expires: 2004-10-15\]

    <span id="anchor-2"></span>Revocation certificates

    Revocation certificates are used to revoke keys in case someone gets knowledge of your secret key or in case you forget your passphrase. They are also useful for other various functions.
    ```

Щоб створити свідоцтво про відкликання

1. Увійшовши як користувач ying. Створіть свідоцтво про відкликання. Він буде відображатися на стандартному виводі. Впишіть:

    ```
    [ying@serverXY ying\]$ gpg --gen-revoke ying@serverXY
    ```

    Дотримуйтесь підказок і введіть свою парольну фразу, коли буде запропоновано це зробити.

2. Тепер створіть сертифікат відкликання, який зберігатиметься у форматі ASCII у файлі під назвою -

    “revoke.asc”. Впишіть:

    ```
    [ying@serverXY ying\]$ gpg --output revoke.asc --gen-revoke ying@serverXY
    ```

3. Ви повинні зберігати свідоцтво про відкликання в безпечному місці та навіть зробити роздруковану копію.

    Експорт відкритих ключів

Вся суть усього цього бізнесу шифрування, підписання та дешифрування полягає в тому, що люди хочуть спілкуватися один з одним, але вони також хочуть робити це якомога безпечнішим способом.

З огляду на це - можливо, не настільки очевидне слід сказати:

Ви повинні обмінюватися відкритими ключами, щоб спілкуватися з іншими людьми за допомогою криптосистеми на основі відкритого ключа.

Або принаймні зробіть свій відкритий ключ доступним у будь-якому загальнодоступному місці (рекламні щити, веб-сторінки, сервери ключів, радіо, ТБ, СПАМ через електронну пошту тощо)

Щоб експортувати ваші відкриті ключі

1. Експортуйте свій відкритий ключ у двійковому форматі у файл під назвою «ying-pub.gpg». Впишіть:

    ```
    [ying@serverXY ying\]$ ***gpg --output ying-pub.gpg --export &lt;your\_key’s\_user\_ID&gt;***
    ```

    !!! note "Примітка"

     Замініть &lt;ваш\_ключ\_user\_ID&gt; з будь-яким рядком, який правильно визначає ваші ключі. У нашій зразковій системі це значення може бути будь-яким із наведеного нижче:
    
     ying@serverXY, ying, yang
    
     АБО
    
     The actual key ID - 1D12E484

2. Експортуйте відкритий ключ у файл під назвою «ying-pub.asc». Але цього разу згенеруйте його

    ASCII-броньований формат. Впишіть:

    ```
    [ying@serverXY ying\]$***gpg --output ying-pub.asc --armor --export ying@serverXY ***
    ```

3. Використовуйте команду cat, щоб переглянути двійкову версію відкритого ключа ying (ying-pub.gpg)

4. Щоб скинути термінал, введіть: `reset`

5. Використовуйте команду cat, щоб переглянути версію ASCII відкритого ключа ying (ying-pub.asc)

6. Ви помітите, що версія ASCII більше підходить для розміщення на веб-сторінках або спаму тощо.

## Завдання 3

### Цифрові підписи

Для створення та перевірки підписів використовується пара відкритий/приватний ключ, яка відрізняється від шифрування та дешифрування. Підпис створюється за допомогою закритого ключа підписувача. Підпис можна перевірити за допомогою відповідного відкритого ключа.

Цифровий підпис файлу

1. Створіть файл із назвою «secret-file.txt» із текстом «Hello All». Впишіть:

    ```
    [ying@serverXY ying\]$ echo "Hello All" &gt; secret1.txt
    ```

2. Використовуйте cat для перегляду вмісту файлу. Використовуйте команду file, щоб побачити тип файлу.

3. Тепер підпишіть файл своїм цифровим підписом. Впишіть:

    ```
    [ying@serverXY ying\]$ gpg -s secret1.txt
    ```
    Введіть свою парольну фразу, коли буде запропоновано.

    Наведена вище команда створить ще один файл «secret1.txt.gpg», який буде стиснутий і до якого додано підпис. Виконайте команду «file» для файлу, щоб перевірити це. Перегляньте файл із cat

4. Перевірте підпис у підписаному файлі “secret1.txt.gpg”. Впишіть:

    ```
    [ying@serverXY ying\]$ gpg --verify secret1.txt.gpg

    gpg: Signature made Thu 16 Oct 2003 07:29:37 AM PDT using DSA key ID 1D12E484

    gpg: Good signature from "Ying Yang (my test) &lt;ying@serverXY&gt;"
    ```

5. Створіть інший файл secret2.txt із текстом «Hello All».

6. Підпишіть файл secret2.txt, але цього разу нехай файл буде захищений ASCII. Впишіть:

    ```
    [ying@serverXY ying\]$ gpg -sa secret2.txt
    ```

    У вашому pwd буде створено броньований файл ASCII під назвою “secret2.txt.asc”.

7. Використовуйте команду cat, щоб переглянути вміст ASCII-файлу, створеного для вас вище.

8. Створіть ще один файл під назвою «secret3.txt» із текстом «hello dude». Впишіть:

    ```
    [ying@serverXY ying echo "hello dude" &gt; secret3.txt
    ```

9. Додайте свій підпис до тіла файлу, який ви створили вище. Впишіть:

    ```
    [ying@serverXY ying\]$ gpg --clearsign secret3.txt
    ```

    Це створить нестиснений файл (secret3.txt.asc), загорнутий у ваш ASCII-підпис.

    Запишіть команду для перевірки створеного для вас підпису файлу.

10. Відкрийте файл, щоб переглянути його вміст за допомогою будь-якого пейджера. Чи можете ви прочитати текст, який ви ввели у файл?

!!! warning "Прочитайте, перш ніж продовжити"

    Переконайтеся, що ваш партнер виконав усі «Вправи 1, 2 і 3» вище, перш ніж перейти до Вправи 4 нижче.
    
    Якщо у вас немає партнера, вийдіть з облікового запису користувача Ying і увійдіть у систему як користувач «me».
    
    Потім повторіть усі «Вправи 1, 2 і 3» як користувач «me».
    
    Потім ви можете виконати вправу 4 нижче. Замініть усі посилання на користувача Ying на "serverPR" на користувача "me" на ServerXY (тобто ваш локальний хост).
    
    У наступній вправі ви можете використовувати або користувача «me@serverXY», або користувача «ying@serverPR».

## Завдання 4

У цій вправі ви будете використовувати так звану «Мережу довіри» для спілкування з іншим користувачем.

Імпорт відкритих ключів

1. Увійдіть в систему як користувач ying.

2. Зробіть свій ASCII-броньований файл відкритого ключа (ying-pub.asc) доступним для вашого партнера (використайте

    або - me@serverXY або ying@serverPR)

    !!! note "Примітка"
   
        Є кілька способів зробити це, напр. електронна пошта, копіювання та вставка, scp, ftp, збереження на дискеті тощо.
       
         Виберіть для себе найефективніший спосіб.

3. Попросіть свого партнера надати вам доступ до файлу відкритого ключа.

4. Припустимо, що відкритий ключ вашого партнера зберігається у файлі під назвою «me-pub.asc» у вашому pwd;

    Імпортуйте ключ у свій key-ring. Впишіть:

    ```
    [ying@serverXY ying\]$ gpg --import me-pub.asc

    gpg: key 1D0D7654: public key "Me Mao (my test) &lt;me@serverXY&gt;" imported

    gpg: Total number processed: 1

    gpg: imported: 1
    ```

5. Тепер перелічіть ключі у вашому key-ring. Впишіть:

    ```
    [ying@serverXY ying\]$ gpg --list-keys

    /home/ying/.gnupg/pubring.gpg

    -----------------------------

    pub 1024D/1D12E484 2003-10-16 Ying Yang (my test) &lt;ying@serverXY&gt;

    sub 1024g/1EDB00AC 2003-10-16 \[expires: 2004-10-15\]

    pub 1024D/1D0D7654 2003-10-16 Me Mao (my test) &lt;me@serverXY&gt;

    sub 1024g/FD20DBF1 2003-10-16 \[expires: 2004-10-15\]
    ```

6. Зокрема, перелічіть ключ, пов’язаний з ідентифікатором користувача me@serverXY. Впишіть:

    ```
    [ying@serverXY ying\]$ gpg --list-keys me@serverXY
    ```

7. Переглянути відбиток ключа для me@serverXY. Впишіть:

    ```
    [ying@serverXY ying\]$ gpg --fingerprint me@serverXY
    ```


    <span id="anchor-4"></span>Шифрування та дешифрування файлів

    Процедура шифрування та дешифрування файлів або документів проста.

    Якщо ви хочете зашифрувати повідомлення для користувача ying, ви зашифруєте його за допомогою відкритого ключа користувача ying.

    Після отримання ying потрібно буде розшифрувати повідомлення за допомогою закритого ключа ying.

    ТІЛЬКИ ying може розшифрувати повідомлення або файл, зашифрований відкритим ключем ying

Щоб зашифрувати файл

1. Увійшовши в систему як користувач ying, створіть файл під назвою encrypt-sec.txt. Впишіть:

    ```
    [ying@serverXY ying\]$ echo "hello" &gt; encrypt-sec.txt
    ```

    Переконайтеся, що ви можете прочитати вміст файлу за допомогою cat.

2. Зашифруйте файл encrypt-sec.txt, щоб лише користувач «me» міг переглядати файл. тобто ви зашифруєте його за допомогою відкритого ключа me@serverXY (який зараз є у вашому key-ring). Впишіть:

    ```
    [ying@serverXY ying\]$ gpg --encrypt --recipient me@serverXY encrypt-sec.txt
    ```

    Наведена вище команда створить зашифрований файл під назвою «encrypt-sec.txt.gpg» у вашому pwd.

Щоб розшифрувати файл

1. Файл, який ви зашифрували вище, призначений для me@serverXY.

    Спробуйте розшифрувати файл. Впишіть:

    ```
    [ying@serverXY ying\]$ gpg --decrypt encrypt-sec.txt.gpg

    gpg: encrypted with 1024-bit ELG-E key, ID FD20DBF1, created 2003-10-16

    "Me Mao (my test) &lt;me@serverXY&gt;"

    gpg: decryption failed: secret key not available
    ```

2. Чи отримали ми тут якийсь цінний урок?

3. Зробіть зашифрований файл, який ви створили, доступним для належного власника та попросіть його виконати наведену вище команду, щоб розшифрувати файл. Чи вдалося їм розшифрувати файл.

    !!! note "Примітка"
   
        Будьте дуже обережні, розшифровуючи двійкові файли (наприклад, програми), тому що після успішного розшифрування файлу gpg спробує надіслати вміст файлу на стандартний вивід.

    Візьміть звичку використовувати команду нижче під час розшифровки файлів:

    ```
    [ying@serverXY ying\]$ gpg --output encrypt-sec --decrypt encrypt-sec.txt.gpg
    ```

    Це примусово надсилає вихідні дані у файл під назвою «encrypt-sec».

    Який потім можна переглянути (або запустити) за допомогою будь-якої програми, яка підходить для типу файлу (або вмісту).

### Поради

1. Більшість команд і параметрів, які використовуються з програмою gpg, також мають короткі форми, що призводить до того, що користувач менше вводить текст у командному рядку. наприклад:

    ```
    gpg --encrypt --recipient me@serverXY encrypt-sec.txt
    ```
    Коротка форма наведеної вище команди:

    ```
    gpg -e -r me@serverXY encrypt-sec.txt
    ```
2. Щоб зашифрувати рядок "hello" і надіслати його як броньоване повідомлення ASCII користувачеві з адресою електронної пошти ying@serverXY; Використовуйте команду нижче:

    ```
    echo "hello" | gpg -ea -r ying@serverXY | mail ying@serverXY
    ```

3. Щоб зашифрувати файл "your_file" відкритим ключем "me@serverXY" і записати його в "your_file.gpg"

    після ***підпису*** його своїм ідентифікатором користувача (за допомогою цифрового підпису); Використовуйте команду нижче:

    ```
    gpg -se -r me@serverXY your\_file
    ```

4. Існує загальнодоступний сервер ключів на wwwkeys.pgp.net. Ви можете використовувати gpg, щоб завантажити туди свій ключ за допомогою:

    gpg --send-keys &lt;your\_real\_email\_address&gt; --keyserver wwwkeys.pgp.net

## OpenSSH (www.openssh.org)

OpenSSH — це реалізація протоколу SSH (Secure SHell) OpenBSD.

Це БЕЗКОШТОВНА версія набору інструментів для підключення до мережі протоколу SSH. OpenSSH шифрує весь трафік (включаючи паролі), щоб ефективно усунути підслуховування, викрадення з’єднання та інші атаки на рівні мережі. Крім того, OpenSSH надає безліч можливостей безпечного тунелювання, а також різноманітні методи автентифікації.

Це допомагає забезпечити безпечний зашифрований зв’язок між двома ненадійними хостами через незахищену мережу (наприклад, Інтернет).

Він включає як компоненти на стороні сервера, так і набір програм на стороні клієнта

### `sshd`

На стороні сервера є демон безпечної оболонки (`sshd`). `sshd` — це демон, який прослуховує підключення від клієнтів.

Він створює новий демон для кожного вхідного з’єднання. Розгалужені демони обробляють обмін ключами, шифрування, автентифікацію, виконання команд і обмін даними. Згідно зі сторінкою довідки sshd, `sshd` працює наступним чином:

Для протоколу SSH версії 2:

Кожен хост має спеціальний ключ (RSA або DSA), який використовується для ідентифікації хоста. Кожен хост має спеціальний ключ (RSA або DSA), який використовується для ідентифікації хоста. Передня безпека забезпечується через ключову угоду Діффі-Хеллмана. Ця угода ключа призводить до спільного ключа сеансу.

Решта сеансу шифрується за допомогою симетричного шифру, наразі 128-бітного AES, Blowfish, 3DES, CAST128, Arcfour, 192-бітного AES або 256-бітного AES. Клієнт вибирає алгоритм шифрування із запропонованих сервером. Крім того, цілісність сеансу забезпечується за допомогою коду автентифікації криптографічного повідомлення (hmac-sha1 або hmac-md5).

Протокол версії 2 надає метод автентифікації на основі відкритого ключа користувача (PubkeyAuthentication) або клієнтського хоста (HostbasedAuthentication), звичайну автентифікацію за паролем і методи на основі виклику.

Протокол SSH2, реалізований у OpenSSH, стандартизовано робочою групою «IETF secsh».

### `ssh`

Набір програм клієнта включає `ssh`. Це програма, яка використовується для входу у віддалені системи, а також може використовуватися для виконання команд у віддалених системах.

## Завдання 5

### `sshd`

```
Usage: sshd [options]

Options:

 -f file Configuration file (default /etc/ssh/sshd\_config)

 -d Debugging mode (multiple -d means more debugging)

 -i Started from inetd

 -D Do not fork into daemon mode

 -t Only test configuration file and keys

 -q Quiet (no logging)

 -p port Listen on the specified port (default: 22)

 -k seconds Regenerate server key every this many seconds (default: 3600)

 -g seconds Grace period for authentication (default: 600)

 -b bits Size of server RSA key (default: 768 bits)

 -h file File from which to read host key (default: /etc/ssh/ssh\_host\_key)

 -u len Maximum hostname length for utmp recording

 -4 Use IPv4 only

 -6 Use IPv6 only

 -o option Process the option as if it was read from a configuration file.
```

Більшість систем Linux із коробки вже мають сервер OpenSSH, налаштований і запущений із деякими параметрами за замовчуванням. Конфігураційний файл для `sshd` зазвичай знаходиться в - /etc/ssh/ - і називається `sshd_config`.

### `sshd_config`

1. Відкрийте конфігураційний файл ssh-сервера будь-яким пейджером і вивчіть його. Впишіть:

    ```
    [root@serverXY root\]\# less /etc/ssh/sshd_config
    ```

    !!! note "Примітка" 

     `sshd_config` є досить дивним конфігураційним файлом. На відміну від інших конфігураційних файлів Linux, коментарі (\#) у файлі `sshd_config` позначають значення параметрів за замовчуванням. (тобто коментарі представляють уже скомпільовані значення за замовчуванням.)

2. Перегляньте сторінку довідки для `sshd_config` і поясніть, що роблять наведені нижче параметри?

    AuthorizedKeysFile

    Ciphers

    Port

    Protocol

    X11Forwarding

    HostKey

3. Змініть свій pwd на каталог /etc/ssh/.

4. Перерахуйте всі файли в цьому каталозі.

### Створення ключів хоста

Ваш сервер SSH уже має ключі хостів, які він використовує. Ці ключі були згенеровані під час першого встановлення вашої системи. У цій вправі ви дізнаєтеся, як створити ключі типу хоста для вашого сервера. Але насправді ви не будете використовувати ключі.

Для створення ключів хосту для вашого сервера

1. Створіть новий каталог під вашим pwd. Назвіть це запасними ключами. cd у новий каталог. Впишіть:

    ```
    [root@serverXY ssh\]# mkdir spare-keys && cd spare-keys
    ```

2. Використовуйте програму `ssh-keygen`, щоб створити ключ хоста з такими характеристиками:

    a. тип ключа має бути "rsa"

    b. Ключ не повинен мати зауважень

    c. Файл закритого ключа повинен мати назву - ssh\_host\_rsa\_key

    d. Ключ не повинен використовувати парольну фразу

    Впишіть:

    ```
    [root@serverXY spare-keys]# ssh-keygen -q -t rsa -f ssh\_host\_rsa\_key -C '' -N ''
    ```

3. Перегляньте відбиток ключа, який ви створили вище. Впишіть:

    ```
    [root@serverXY spare-keys]# ssh-keygen -l -f ssh_host_rsa_key
    ```

4. Запишіть команду для створення ключа типу ***dsa*** під назвою “ssh_host_dsa_key” без коментарів і парольної фрази.

## Завдання 6

### `ssh`

```
usage: ssh [-46AaCfGgKkMNnqsTtVvXxYy] [-B bind_interface]
           [-b bind_address] [-c cipher_spec] [-D [bind_address:]port]
           [-E log_file] [-e escape_char] [-F configfile] [-I pkcs11]
           [-i identity_file] [-J [user@]host[:port]] [-L address]
           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]
           [-Q query_option] [-R address] [-S ctl_path] [-W host:port]
           [-w local_tun[:remote_tun]] destination [command]
```

Для використання `ssh`

1. Увійдіть на serverXY як користувач me.

2. Використовуйте `ssh` для підключення до serverPR. Впишіть:

    ```
    [me@serverXY me\]$ ***ssh serverPR***
    ```

    Введіть пароль користувача me, коли буде запропоновано. Якщо ви отримаєте будь-які попередження, введіть «yes», щоб продовжити.

3. Після входу створіть каталог під назвою myexport і створіть порожній файл. Впишіть:

    ```
    [me@serverPR me\]$ mkdir ~/myexport && touch myexport
    ```

    Зверніть увагу на випадковий файл, який було створено для вас, у розділі ~/myexport ?

4. Вийти з serverPR. Впишіть:

    ```
    [me@serverPR me]$ exit
    ```

    Ви повернетеся до локальної оболонки на serverXY.

5. Використовуйте `ssh`, щоб віддалено виконати команду «ls», щоб переглянути список файлів у домашньому каталозі ying за адресою

    serverPR. Впишіть:

    ```
    [me@serverXY me]$ssh ying@serverPR “ls /home/ying”
    ```

    Коли буде запропоновано, введіть пароль ying. Якщо ви отримаєте будь-які попередження, введіть «yes», щоб продовжити.

6. Увійшовши як я на serverXY, увійдіть у serverPR як користувач ying. Впишіть:

    ```
    [me@serverXY me\]$ ***ssh -l ying serverPR ***
    ```

    **Коли буде запропоновано, введіть пароль ying.**

7. Введіть «exit», щоб вийти з serverPR і повернутися до serverXY.

### `scp` - безпечне копіювання (програма віддаленого копіювання файлів)

`scp` копіює файли між хостами в мережі. Він використовує SSH для передачі даних, використовує ту саму автентифікацію та забезпечує таку саму безпеку, що й `ssh`.

```
usage: scp [-346ABCOpqRrTv] [-c cipher] [-D sftp_server_path] [-F ssh_config]
           [-i identity_file] [-J destination] [-l limit]
           [-o ssh_option] [-P port] [-S program] source ... target
```

Для використання `scp`

1. Переконайтеся, що ви все ще ввійшли як користувач me на serverXY.

2. Створіть каталог у вашому домашньому каталозі під назвою myimport і перейдіть до каталогу.

3. Скопіюйте всі файли в каталозі «/home/me/myexport/» на serverPR. Впишіть:

    ```
    [me@serverXY myimports\]$ scp serverPR:/home/me/myexport  .
    ```

4. Перелічіть вміст вашої pwd?

    Це було круто чи що?

5. Яка команда скопіювати весь вміст у розділі “/home/me/.gnupg/” на serverPR?

6. Тепер скопіюйте всі файли в домашній каталог ying на serverPR. Впишіть:

    ```
    [me@serverXY myimports\]$ scp -r ying@serverPR:/home/ying/*  .
    ```

## Завдання 7

### Створення відкритих і закритих ключів користувача для SSH

Кожен користувач, який хоче використовувати SSH з автентифікацією RSA або DSA, потребує набору відкритих і закритих ключів. Програму `ssh-keygen` можна використати для створення цих ключів (так само, як вона використовувалася раніше, коли ви створювали запасні ключі для вашої системи)

Єдиною «рекомендованою» відмінністю під час створення ключів користувача є створення парольної фрази.

Парольна фраза — це пароль для шифрування закритого ключа перед його збереженням у файловій системі.

Загальнодоступний зберігається у файлі з таким же ім’ям, що й закритий ключ, але з доданим до нього розширенням «.pub». Немає способу відновити втрачену парольну фразу. Необхідно створити новий ключ, якщо парольну фразу втрачено або забуто.

Щоб створити ключі автентифікації ying

1. Увійдіть на локальну машину як користувач ying.

2. Запустіть програму `ssh-keygen`, щоб створити ключ типу «***dsa***» із довжиною за умовчанням. Впишіть:

    ```
    [ying@serverXY ying]$ ssh-keygen -t dsa

    Generating public/private dsa key pair.

    Press <kbd>ENTER</kbd> to accept the default file location.

    Enter file in which to save the key (/home/ying/.ssh/id\_dsa): <kbd>ENTER</kbd>

    Enter a very good passphrase when prompted - i.e. one that is difficult to guess.

    Created directory '/home/ying/.ssh'.

    Enter passphrase (empty for no passphrase): ********

    Enter same passphrase again: *******

    Your identification has been saved in /home/ying/.ssh/id\_dsa.

    Your public key has been saved in /home/ying/.ssh/id\_dsa.pub.

    The key fingerprint is:

    61:68:aa:c2:0c:af:9b:49:4a:11:b8:aa:b5:84:18:10 ying@serverXY.example.org
    ```

3. cd у ваш каталог “**~/.ssh/**”. Перерахувати файли в каталозі?

4. Що таке команда “ssh-keygen” для перегляду відбитків ваших ключів?

5. Використовуйте команду cat, щоб переглянути вміст вашого файлу відкритого ключа (тобто “**~/.ssh/id\_rsa.pub**”).

## Завдання 8

### Автентифікація за допомогою відкритого ключа

Досі ви використовували схему автентифікації на основі пароля для входу в облікові записи користувачів на serverPR.

Це означає, що ви повинні були знати пароль відповідного облікового запису на віддаленій стороні, щоб мати змогу успішно ввійти.

У цій вправі ви налаштуєте автентифікацію за допомогою відкритого ключа між вашим обліковим записом користувача на serverXY та обліковим записом користувача ying на serverPR.

Щоб налаштувати автентифікацію за допомогою відкритого ключа

1. Увійдіть у свою локальну систему як користувач ying.

2. cd у ваш каталог «~/.ssh».

3. Введіть жахливу команду нижче:

    ```
    [ying@serverXY .ssh\]$ cat id\_dsa.pub | ssh ying@serverPR \

    '(cd ~/.ssh && cat - &gt;&gt; authorized\_keys && chmod 600 authorized\_keys)'
    ```

    Команда вище читається як:

    a. cat вміст вашого файлу відкритого ключа DSA, але надішліть вихід у канал ( | ) замість звичайного стандартного вихідного.

    b. запустіть команду “***cd ~/.ssh && кіт - &gt;&gt; авторизовані\_keys && chmod 600 authorized\_keys”*** як користувач, який знаходиться на serverPR.

    c. Суть команди полягає в тому, щоб просто скопіювати та додати вміст вашого файлу відкритого ключа до “/home/ying/.ssh/authorized\_keys” на serverPR і надати йому правильні дозволи.

    Якщо ви знаєте будь-який інший ручний спосіб досягнення такого ж результату, зробіть це.

4. Після додавання відкритого ключа до файлу authorized_keys у віддаленій системі. Спроба увійти на serverPR як ying через ssh. Впишіть:

    ```
    [ying@serverXY .ssh]$ ssh serverPR

    Enter passphrase for key '/home/ying/.ssh/id\_dsa': ********
    ```

    Дуже уважно зверніть увагу, що цього разу вам буде запропоновано ввести парольну фразу замість пароля. Введіть парольну фразу, яку ви створили раніше під час створення ключів.

5. Після успішного входу на serverPR; Вийти знову.

## Завдання 9

### `ssh-agent`

Згідно зі сторінкою довідки, ssh-agent — це програма для зберігання приватних ключів, які використовуються для автентифікації відкритих ключів (RSA, DSA). Ідея полягає в тому, що ssh-agent запускається на початку X-сеансу або сеансу входу, а всі інші вікна чи програми запускаються як клієнти програми `ssh-agent`. За допомогою змінних середовища можна знайти агента та автоматично використовувати його для автентифікації під час входу на інші машини за допомогою `ssh`.

```
usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]
                 [-P allowed_providers] [-t life]
       ssh-agent [-a bind_address] [-E fingerprint_hash] [-P allowed_providers]
                 [-t life] command [arg ...]
       ssh-agent [-c | -s] -k
```

У цій вправі ви дізнаєтеся, як налаштувати агента таким чином, щоб вам не доводилося вводити свою парольну фразу кожного разу, коли ви хочете підключитися до іншої системи за допомогою автентифікації з відкритим ключем.

1. Переконайтеся, що ви ввійшли в локальну систему як користувач ying.

2. Введіть команду нижче:

    ```
    [ying@serverXY .ssh\]$ eval `ssh-agent`

    Agent pid 5623
    ```

    Зверніть увагу на PID агента:

3. Використовуйте програму `ssh-add`, щоб додати свої ключі до агента, який ви запустили вище. Впишіть:

    ```
    [ying@serverXY .ssh\]$ ***ssh-add***

    Enter your passphrase when prompted.

    Enter passphrase for /home/ying/.ssh/id\_dsa:

    Identity added: /home/ying/.ssh/id\_dsa (/home/ying/.ssh/id\_dsa)
    ```

4. Тепер підключіться до serverPR як користувач ying. Вам НЕ буде запропоновано ввести пароль або парольну фразу (тобто якщо все зроблено правильно). Впишіть:

    ```
    [ying@serverXY .ssh\]$ ssh serverPR
    ```

5. Насолоджуйтесь.
