- - -
Title: Лабораторна робота 8 - iptables author: Wale Soyinka contributors:
- - -


# Лабораторна робота 8: `iptables`

## Завдання

Виконавши цю лабораторну роботу, ви зможете

- налаштовувати основні правила IP-фільтра
- налаштовувати IP-переадресацію

Приблизний час виконання цієї лабораторної роботи: 60 хвилин

> Я завжди використовую iptables на своїх пристроях Linux. Подивіться – навіть якщо ви не хочете, щоб хакери потрапили на вулицю, ви можете блокувати такі рекламні сайти, як* doubleclick.com та інші злі виродки. Або, можливо, ви хочете зробити трохи більше журналу? …Iptables вас врятує!

-- George W.Bush

## `iptables`

`iptables` — це інструмент, який використовується для керування фільтрацією пакетів IPv4 і підсистемою NAT ядра Linux. Підсистема відома як netfilter.

Утиліта командного рядка `iptables` надає інтерфейсні (пользовательські) інструменти для керування цією підсистемою. Вона використовується для налаштування, підтримки та перевірки таблиць правил фільтрації IP-пакетів у ядрі. Можна визначити кілька різних таблиць.

Деякі загальні терміни, які використовуються в обговореннях `iptables`, описані нижче:

### TABLES (ТАБЛИЦІ)

У більшості ядер Linux визначено три незалежні таблиці. Таблиці в будь-який час залежать від параметрів конфігурації ядра та наявних модулів. Існують наступні таблиці:

- filter:      Це основна таблиця та таблиця за замовчуванням (якщо параметр -t не передано). Він містить вбудовані ланцюжки:

    - **INPUT** (для пакетів, що надходять у саму коробку)
    - **FORWARD** (для пакетів, що направляються через ящик)
    - **OUTPUT** (для локально згенерованих пакетів).

- nat:       До цієї таблиці звертаються, коли зустрічається пакет, який створює нове з’єднання. Він складається з наступних трьох вбудованих ланцюжків:

    - **PREROUTING** (для зміни пакетів, щойно вони надходять)
    - **OUTPUT** (для зміни локально згенерованих пакетів перед маршрутизацією)
    - **POSTROUTING** (для зміни пакетів, коли вони збираються вийти)

- mangle:    Ця таблиця використовується для спеціалізованої зміни пакетів. Вона має наступні 5 вбудованих ланцюгів:

    - **PREROUTING** (для зміни вхідних пакетів перед маршрутизацією)
    - **OUTPUT** (для зміни локально згенерованих пакетів перед маршрутизацією)
    - **INPUT** (для пакетів, що надходять у саму коробку)
    - **FORWARD** (для зміни пакетів, що направляються через ящик)
    - **POSTROUTING**  (для зміни пакетів, коли вони збираються вийти)

### CHAINS (ЛАНЦЮГИ)

Ланцюжок — це список правил, які можуть відповідати набору пакетів. Кожне правило визначає, що робити з пакетом, який співпадає. Кожна таблиця містить ряд вбудованих ланцюжків, а також може містити визначені користувачем ланцюжки.

### TARGETS (ЦІЛІ)

Правило брандмауера визначає критерії для пакета та цілі. Якщо пакет не збігається, перевіряється наступне правило в ланцюжку; якщо воно збігається, то наступне правило вказується значенням цілі, яке може бути назвою визначеного користувачем ланцюжка або одним із спеціальних значень ACCEPT, DROP, QUEUE або RETURN.

```bash

Використання: iptables -[ACD] chain rule-specification [options]
       iptables -I chain [rulenum] rule-specification [options]
       iptables -R chain rulenum rule-specification [options]
       iptables -D chain rulenum [options]
       iptables -[LS] [chain [rulenum]] [options]
       iptables -[FZ] [chain] [options]
       iptables -[NX] chain
       iptables -E old-chain-name new-chain-name
       iptables -P chain target [options]
       iptables -h (print this help information)

Команди:
Допускаються як довгі, так і короткі варіанти.
  --append  -A chain Append to chain
  --check   -C chain Check for the existence of a rule
  --delete  -D chain Delete matching rule from chain
  --delete  -D chain rulenum
    Delete rule rulenum (1 = first) from chain
  --insert  -I chain [rulenum]
    Insert in chain as rulenum (default 1=first)
  --replace -R chain rulenum
    Replace rule rulenum (1 = first) in chain
  --list    -L [chain [rulenum]]
    List the rules in a chain or all chains
  --list-rules -S [chain [rulenum]]
    Print the rules in a chain or all chains
  --flush   -F [chain] Delete all rules in  chain or all chains
  --zero    -Z [chain [rulenum]]
    Zero counters in chain or all chains
  --new     -N chain Create a new user-defined chain
  --delete-chain
    -X [chain] Delete a user-defined chain
  --policy  -P chain target
    Change policy on chain to target
  --rename-chain
            -E old-chain new-chain
                Change chain name, (moving any references)

Опції:
    --ipv4 -4 Nothing (line is ignored by ip6tables-restore)
    --ipv6 -6 Error (line is ignored by iptables-restore)
[!] --protocol -p proto protocol: by number or name, eg. `tcp'
[!] --source -s address[/mask][...]
        source specification
[!] --destination -d address[/mask][...]
        destination specification
[!] --in-interface -i input name[+]
        network interface name ([+] for wildcard)
 --jump -j target
    target for rule (may load target extension)
  --goto      -g chain
    jump to chain with no return
  --match -m match
    extended match (may load extension)
  --numeric -n numeric output of addresses and ports
[!] --out-interface -o output name[+]
    network interface name ([+] for wildcard)
  --table -t table table to manipulate (default: `filter')
  --verbose -v verbose mode
  --wait -w [seconds] maximum wait to acquire xtables lock before give up
  --line-numbers print line numbers when listing
  --exact -x expand numbers (display exact values)
[!] --fragment -f match second or further fragments only
  --modprobe=<command> try to insert modules using this command
  --set-counters -c PKTS BYTES set the counter during insert/append
[!] --version -V print package version.

```

### Завдання 1

Основи `iptables`

У цій вправі ви навчитеся деяким основам `iptables`. Зокрема, ви дізнаєтеся, як переглядати або перераховувати правила `iptables`, створювати основні правила фільтрації, видаляти правила, створювати/видаляти спеціальні ланцюжки тощо.

Без зайвих слів, давайте зануримося безпосередньо у використання `iptables`.

#### Щоб переглянути діючі правила

1. Увійшовши як суперкористувач, перегляньте всі правила в таблиці фільтрів. Впишіть:

    ```bash
    [root@serverXY root]# iptables -L
    ```

2. Щоб переглянути більш докладний вихід, введіть:

    ```bash
    [root@serverXY root]# iptables -L -v
    ```

3. Відобразити лише правила в ланцюжку INPUT. Впишіть:

    ```bash
    [root@serverXY root]# iptables -v  -L INPUT
    ```

4. Покажіть усі правила під таблицею. Впишіть:

    ```bash
    [root@serverXY root]#  iptables  -L  -t   mangle
    ```

5. Відобразіть усі правила під таблицею nat. Впишіть:

    ```bash
    [root@serverXY root]# iptables -L -t nat
    ```

#### Щоб очистити всі поточні правила

1. Очистіть (або видаліть) усі правила, які «можливо» зараз завантажено. Впишіть:

    ```bash
    [root@serverXY root]# iptables --flush
    ```

#### Для створення власних ланцюжків

1. Створіть свій власний ланцюжок і назвіть його «mychain». Впишіть:

    ```bash
    [root@serverXY root]# iptables  -N  mychain
    ```

2. Перелічіть правила під створеним вище ланцюжком. Впишіть:

    ```bash
    [root@serverXY root]# iptables  -L mychain

    Chain mychain (0 references)

    target     prot opt source               destination
    ```

#### Щоб видалити ланцюжки

1. Спочатку спробуйте видалити вбудований ланцюжок INPUT. Впишіть:

    ```bash
    [root@serverXY root]# iptables -X INPUT
    ```

    !!! question "Питання"

     Яким був ваш результат?

2. Далі спробуйте видалити ланцюжок, який ви створили вище. Впишіть:

    ```bash
    [root@serverXY root]# iptables -X mychain
    ```

3. Спробуйте знову перерахувати правила в ланцюжку, який ви щойно видалили. Впишіть:

    ```bash
    [root@serverXY root]# iptables -L  mychain
    ```

### Завдання 2

Основна фільтрація пакетів

Ця вправа навчить вас створювати дещо складніші правила фільтрації пакетів. Зокрема, ви заблокуєте всі типи пакетів ICMP у своїй партнерській системі.

#### Щоб фільтрувати типи пакетів icmp

1. Перш ніж почати, переконайтеся, що ви можете пінгувати вашу партнерську систему і що ваша партнерська система може надто успішно пінгувати вас. Впишіть:

    ```bash
    [root@serverXY root]# ping -c 2 serverPR

    <SNIP>

    --- serverPR ping statistics ---

    2 packets transmitted, 2 received, 0% packet loss, time 1005ms

    ...............................................
    ```

2. Очистіть усі існуючі правила. Впишіть:

    ```bash
    [root@serverXY root]# iptables -F
    ```

3. Створіть правило, щоб заборонити всі вихідні пакети типу icmp до будь-якого пункту призначення. Впишіть:

    ```bash
    [root@serverXY root]# iptables  -A  OUTPUT  -o  eth0 -p  icmp  -j  DROP
    ```

    Зрозуміло, попередню команду можна інтерпретувати так: «*Додати правило до ланцюжка OUTPUT у таблиці фільтрів. Нехай це правило видаляє кожен пакет типу ICMP, який виходить через інтерфейс eth0*”

4. Перевірте дію свого правила, спробувавши перевірити serverPR. Впишіть:

    ```bash
    [root@serverXY root]# ping -c 2 serverPR

    PING serverPR (10.0.5.8) 56(84) bytes of data.

    ping: sendmsg: Operation not permitted

    ping: sendmsg: Operation not permitted
    ```

5. Перегляньте щойно створене правило. Впишіть:

    ```bash
    [root@serverXY root]# iptables  -vL OUTPUT

    Chain OUTPUT (policy ACCEPT 21221 packets, 2742K bytes)

    pkts bytes target     prot   opt    in         out         source             destination

    93  7812 DROP     icmp    --  any         eth0    anywhere          anywhere
    ```

6. Очистіть усі правила та повторіть команду ping з обох систем.

    !!! question "Питання"
   
        Успіх чи невдача?

7. Тепер створіть ще одне правило, яке видалятиме пакети icmp, які надходять із певної небажаної IP-адреси (наприклад, 172.16.0.44). Впишіть:

    ```bash
    [root@serverXY root]# iptables -A INPUT -i eth0 -p icmp --source 172.16.0.44 -j DROP
    ```

    Наведену вище команду можна прочитати просто так: *«Додайте правило в ланцюжок INPUT у таблиці фільтрів. Нехай це правило видаляє всі пакети типу ICMP і має адресу джерела 172.16.0.44”*

8. Щоб перевірити дію цього правила, ви можете попросити когось іншого у вашій лабораторії [кому не було призначено IP-адресу 172.16.0.44] спробувати перевірити вас. Успіх чи невдача?

9. Замість того, щоб скидати всі правила у ваших таблицях. Видаліть лише правило, яке ви створили вище. Для цього потрібно знати номер правила. Щоб дізнатися тип номера правила:

    ```bash
    [root@serverXY root]# iptables -vL  INPUT --line-numbers

    Chain INPUT (policy ACCEPT 31287 packets, 9103K bytes)

    num   pkts  bytes   target        prot opt     in     out       source               destination

    1        486   40824  DROP       icmp --    eth0   any     serverPR             anywhere

    ```

    Стовпець, що містить номер правила, було виділено у зразку вихідних даних вище.

10. Використовуючи номер рядка, який відповідає правилу, яке потрібно видалити, ви можете видалити певне правило (рядок номер 1) у ланцюжку INPUT, виконавши:

    ```bash
    [root@serverXY root]# iptables -D INPUT 1
    ```

#### Для фільтрації інших видів трафіку

У цій вправі ви дізнаєтесь, як фільтрувати трафік типу tcp.

Популярний протокол ftp є службою на основі TCP. Це означає, що він транспортується через пакети типу TCP.

У наступних кроках ми досліджуємо націлювання та фільтрування трафіку типу FTP, що надходить із заданої IP-адреси.

1. Запустіть ftp-сервер, який ви налаштували та ввімкнули в одній із попередніх лабораторних робіт. Впишіть:

    ```bash
    [root@serverXY root]# *service vsftpd restart*

    Shutting down vsftpd: [  OK  ]

    Starting vsftpd for vsftpd: [  OK  ]
    ```

2. Попросіть свого партнера спробувати увійти на ваш ftp-сервер як анонімний користувач. Переконайтеся, що ваш партнер може успішно ввійти в систему з serverPR - зробіть це *перед* переходом до наступного кроку.

3. Поки ваш партнер ще ввійшов у систему, створіть правило, щоб вимкнути весь трафік типу ftp, що надходить із serverPR. Впишіть:

    ```bash
    [root@serverXY root]# iptables -A INPUT -i  eth0 -s 172.16.0.z  -p tcp  --dport 21 -j DROP*
    ```

    Якщо говорити простою мовою, наведене вище правило/команда означає: *Додати правило до ланцюжка INPUT у таблиці фільтрів. Нехай це правило ВИДАЛИТЬ усі пакети з адресою джерела 172.16.0.z, призначені для порту 21 у нашій локальній системі.*

4. Щойно ви виконаєте наведену вище команду, стек netfilter негайно введе її в дію. Щоб побачити це, попросіть свого партнера спробувати будь-які ftp-команди, залишаючись на вашому ftp-сервері - напр. `ls`. Успіх чи невдача?

    !!! Успіх чи невдача?
   
        Успіх чи невдача?
       
        Якщо це не вдасться, попросіть свого партнера спробувати від’єднатися та увійти з нуля, а потім знову перевірте, чи вдалося.

5. Попросіть іншу особу, яка НЕ є вашим партнером, спробувати анонімно увійти на ваш ftp-сервер. Ви також можете попросити когось із hq.example.org спробувати підключитися до вашого ftp-сайту.

    !!! question "Питання"
   
        Успіх чи невдача?

6. Увімкніть і запустіть веб-сервер на serverXY.

7. Переконайтеся, що інші люди можуть відвідувати ваш веб-сайт за допомогою браузера. Створіть правило для блокування трафіку http від hq.example.org до вашої локальної машини.

### Завдання 3

Базове пересилання пакетів

У цій вправі ви дізнаєтеся, як налаштувати базове правило пересилання пакетів.

Правило, яке ви налаштували, дозволить вашій системі слугувати маршрутизатором для вашої партнерської системи.

Ваша система направлятиме весь трафік, що надходить із системи вашого партнера, до Інтернету або до вашого власного шлюзу за замовчуванням. Це те, що відомо як IP-маскарадування або NAT (трансляція мережевих адрес).

Якщо бути педантичним, то маскування IP-адреси та NAT-інг насправді є дещо різними звірами і зазвичай використовуються для досягнення різних цілей. Ми не будемо надто зупинятися на конкретних відмінностях у наступних вправах.

Ця вправа передбачає наступне, тому, будь ласка, внесіть зміни відповідно до ваших конкретних налаштувань:

ServerXY

i. У вашій системі є дві мережеві карти - eth0 і eth1.

ii. Перший інтерфейс eth0 буде розглядатися як зовнішній інтерфейс (або вихід в Інтернет)

iii. Другий інтерфейс eth1 буде розглядатися як внутрішній інтерфейс (або звернений до локальної мережі)

iv. Інтерфейс eth0 має IP-адресу 172.16.0.z

v. Інтерфейс eth1 має IP-адресу 10.0.0.z з маскою мережі 255.0.0.0

vi. Що ви успішно пройшли «Лабораторну роботу 2» і зрозуміли основні концепції в ній.

ServerPR

Про систему вашого партнера зроблено наступні припущення.

i. Він має лише одну мережеву карту - eth0

ii. eth0 має IP-адресу - 10.0.0.y з маскою мережі 255.0.0.0

iii. Маршрутизатор або шлюз за замовчуванням для serverPR — 10.0.0.z (тобто IP-адреса для eth1 serverXY)

iv. Що ви успішно пройшли «Лабораторну роботу 2» і зрозуміли основні концепції в ній.

Підключіть мережу так, щоб вона виглядала так, як показано нижче:

Наші звичайні піктограми для serverXY та serverPR було замінено вище на піктограми маршрутизатора.

#### Щоб створити правило переадресації

1. Переконайтеся, що ваша мережа фізично підключена так само, як показано на малюнку вище.

2. Призначте всім інтерфейсам відповідні параметри IP-адреси, маски мережі та шлюзу.

3. Очистіть усі правила iptables, які ви зараз завантажили.

    !!! note "Примітка"
   
        Очищення таблиць не завжди є необхідним або обов'язковим. Можливо, ви помітили, що на початку деяких виконаних вправ ми вказали, що ви очищаєте існуючі таблиці. Це гарантує, що ви починаєте з чистого аркуша і що у вас немає помилкових правил, які ховаються десь у ваших таблицях, які можуть спричинити неправильну роботу. Зазвичай у вас можуть бути завантажені сотні правил одночасно, які виконують різні функції.

4. Попросіть свого партнера в serverPR спробувати перевірити ping 172.16.0.100 (hq.example.org), це має завершитися невдачею, тому що ви зараз працюєте як шлюз за замовчуванням serverPR і ви ще *не* ще ввімкнули маршрутизацію у своїй системі.

5. Як root на serverXY тип:

    ```bash
    [root@serverXY root]# *iptables --table  nat  -A  POSTROUTING -o eth0  -j  MASQUERADE*
    ```

6. Тепер знову повторіть крок 4.

    !!! question "Питання"
   
        Все вийшло?

7. Вищезазначене повинно було вийти з ладу. Вам також потрібно ввімкнути пересилання пакетів у запущеному ядрі. Впишіть:

    ```bash
    [root@serverXY root]#  *echo 1   >   /proc/sys/net/ipv4/ip_forward*
    ```

8. Щоб зробити вказані вище зміни в ядрі постійними між перезавантаженнями, створіть запис нижче у вашому файлі “/etc/sysctl.conf”:

    ```bash
    net.ipv4.ip_forward = 0
    ```

#### Щоб зберегти правила `iptables`

До цього часу всі правила та ланцюжки `iptables`, які ви створювали, були тимчасовими або непостійними. Це означає, що якщо вам доведеться перезавантажити систему в будь-який момент, усі внесені вами правила та зміни буде втрачено.

Щоб запобігти цьому, вам потрібен механізм для запису або збереження тимчасових правил `iptables` у системі, щоб вони завжди були доступними під час перезавантаження системи.

1. Використовуйте команду `iptables-save`, щоб зберегти всі зміни у файлі /etc/sysconfig/iptables. Впишіть:

    ```bash
    [root@serverXY root]# *iptables-save   >   /etc/sysconfig/iptables*
    ```

    !!! tip "Підказка"

     Ви обмежені тим, що ви можете з `iptables` тільки вашою уявою. Ми ледь подряпали поверхню в цій роботі. Сподіваємось, ми достатньо подряпали поверхню, щоб дозволити вашій уяві розквітнути.

## Додаткові питання

Ось кілька додаткових способів вивчення `iptables`:

!!! question "Запитання і завдання:"

    1. Який параметр потрібен, щоб отримати більш докладну версію цієї команди *iptables -L -t nat*?

    2. Яка команда для відображення правил у ланцюжку OUTPUT?

    3. Який порт «звичайно» прослуховує служба ftp?

    4. Яка команда для створення ланцюжка під назвою “mynat-chain” у таблиці nat?

    5. Дослідіть в Інтернеті та перелічіть назви деяких простіших у використанні інструментів або програм, які можна використовувати для керування підсистемою брандмауера в системах на базі Linux.

    6. Створіть правило `iptables`, щоб заблокувати http-трафік від hq.example.org до вашої локальної машини. Який добре відомий порт прослуховують веб-сервери? Запишіть повну команду для досягнення цього? Перетворіть або перекладіть команду, яку ви записали вище, на її звичайний еквівалент.
