---
author: Wale Soyinka
contributors: Steven Spencer, Ganna Zhyrnova
tested on: Всі версії
tags:
  - лабораторна вправа
  - файлова система
  - cli
  - Менеджер логічних томів
  - lvm
---


# Лабораторна робота 6: Файлова система

## Завдання

Виконавши цю лабораторну роботу, ви зможете

- Розбити диск
- Використовувати систему керування логічними томами (LVM)
- Створювати нові файлові системи
- Монтувати та використовувати файлові системи

Приблизний час виконання цієї лабораторної роботи: 90 хвилин

## Огляд корисних програм файлової системи

Нижче наведено зведення поширених програм, які використовуються для керування файловими системами.

### `sfdisk`

Використовується для відображення або керування таблицями розділів диска

Синопсис:

    ```
    Використання:
    sfdisk [options] <dev> [[-N] <part>]
    sfdisk [options] <command>

    Commands:
    -A, --активує <dev> [<частина> ...] список або встановлення завантажувальних розділів (P)MBR
    -d, --dump <dev>                  дамп таблиці розділів (можна використовувати для подальшого введення)
    -J, --json <dev>                 дамп таблиці розділів у форматі JSON
    -g, --show-geometry [<dev> ...]   список геометрії всіх або вказаних пристроїв
    -l, --list [<dev> ...]            список розділів кожного пристрою
    -F, --list-free [<dev> ...]      список нерозподілених вільних областей кожного пристрою
    -r, --reorder <dev>              виправляє порядок розділів (за початковим зсувом)
    -s, --show-size [<dev> ...]      розміри списку всіх або вказаних пристроїв
    -T, --list-types                  друкує розпізнані типи (див. -X)
    -V, --verify [<dev> ...]          перевіряє правильність розділів
        --delete <dev> [<part> ...]   видаляє всі або вказані розділи

    --part-label <dev> <part> [<str>] друкує або змінює мітку розділу
    --part-type <dev> <part> [<type>] друкує або змінює тип розділу
    --part-uuid <dev> <part> [<uuid>] друкує або змінює uuid розділу
    --part-attrs <dev> <part> [<str>] друкує або змінює атрибути розділу

    --disk-id <dev> [<str>]          друкує або змінює ID мітки диска (UUID)
    --relocate <oper> <dev>           переміщує заголовок розділу
    ```

### `debugfs`

ext2/ext3/ext4 налагоджувач файлової системи

Синопсис:

    ```
     debugfs [-b blocksize] [-s superblock] [-f cmd_file] [-R request] [-d data_source_device] [-i] [-n] [-D] [-V] [[-w] [-z undo_file] [-c]] [device]
    ```

### `badblocks`

Пошук пошкоджених блоків на пристрої

Синопсис:

    ```
     badblocks  [ -svwnfBX ] [ -b block_size ] [ -c blocks_at_once ] [ -d read_delay_factor ] [ -e max_bad_blocks ] [ -i input_file ] [ -o output_file ] [ -p num_passes ] [
       -t test_pattern ] device [ last_block ] [ first_block ]
    ```

### `dosfsck`

Перевіряє файлову систему FAT на DEVICE на наявність помилок.

Синопсис:

    ```
    Використання: dosfsck [OPTIONS] DEVICE
    Options:
    -a              автоматично відновлює файлову систему
    -A             перемикає варіант файлової системи FAT Atari
    -b              виконує перевірку завантажувального сектора лише для читання
    -c N            використовує кодову сторінку DOS N для декодування коротких імен файлів (за замовчуванням: 850)
    -d PATH         скидає файл з іменем PATH (можна вказати декілька разів)
    -f              зберігає невикористані ланцюжки до файлів
    -F NUM          визначає таблицю FAT NUM, яка використовується для доступу до файлової системи
    -l             перераховує назви шляхів
    -n              no-op, перевіряє неінтерактивно без змін
    -p             те саме, що -a, для сумісності з іншими *fsck
    -r              інтерактивно відновлює файлову систему (за замовчуванням)
    -S              забороняє пропуски в середині коротких імен файлів
    -t             тест на погані кластери
    -u PATH         намагається відновити файл (не з каталогу) з назвою PATH (можна
                      вказати кілька разів)
    -U              допускає лише великі символи в томі та мітці завантаження
    -v             багатослівний режим
    -V              виконує проходження перевірки
    --variant=TYPE  обробляє варіант TYPE файлової системи
    -w              негайно записує зміни на диск
    -y             те саме, що -a, для сумісності з іншими *fsck
    --help         друкує це повідомлення
    ```

### `mkdosfs` або `mkfs.fat`

Використовується для створення файлової системи MS-DOS (FAT12, FAT16 і FAT32) в Linux

Синопсис:

    ```
      Використання: mkdosfs [OPTIONS] TARGET [BLOCKS]

      Options:
        -a              Вимикає вирівнювання структур даних
        -A              Перемикає варіант файлової системи Atari
        -b SECTOR       Вибирає СЕКТОР як розташування резервного завантажувального сектора FAT32
        -c              Перевіряє пристрій на наявність пошкоджених блоків перед створенням файлової системи
        -C              Створює файл TARGET, а потім створює в ньому файлову систему
        -D NUMBER       Записує диск BIOS номер НОМЕР у завантажувальний сектор
        -f COUNT        Створює COUNT таблиць розміщення файлів
        -F SIZE         Вибір розміру FAT SIZE (12, 16 або 32)
        -g GEOM         Вибирає геометрію диска: heads/sectors_per_track
        -h NUMBER       Записує приховані сектори NUMBER у завантажувальний сектор
        -i VOLID        Встановлює ID тома на VOLID (32-розрядне шістнадцяткове число)
        -I             Ігнорує та вимикає перевірки безпеки
        -l FILENAME     Читає список пошкоджених блоків з FILENAME
        -m FILENAME     Замінює повідомлення про помилку за замовчуванням у блоці завантаження вмістом FILENAME
        -M TYPE         Встановлює тип носія у завантажувальному секторі на TYPE
        .........
    ```

### `dumpe2fs`

Перераховує інформацію про суперблок і групу блоків на зазначеному пристрої.

Синопсис:

    ```
    Використання: dumpe2fs [-bfghimxV] [-o superblock=<num>] [-o blocksize=<num>] device
    ```

### `fdisk`

Перегляд і керування (додавання, видалення та зміна) таблиць розділів диска

Синопсис:

    ```
    Використання:
    fdisk [options] <disk>         змінити таблицю розділів
    fdisk [options] -l [<disk>...] список таблиць розділів
    Відображення або керування таблицею розділів диска.

    Options:
    -b, --sector-size <size>      фізичний і логічний розмір сектора
    -B, --protect-boot            не стирає завантажувальні біти під час створення нової мітки
    -c, --compatibility[=<mode>]  режим «dos» або «nondos» (за замовчуванням)
    -L, --color[=<when>]          розфарбовує вихід (автоматично, завжди або ніколи) кольори ввімкнено за замовчуванням
    -l, --list                   відображає розділи та вихід
    -x, --list-details            як --list, але з більш детальною інформацією
    -n, --noauto-pt               не створює таблицю розділів за замовчуванням на порожніх пристроях
    -o, --output <list>           вихідні колонки
    -t, --type <type>            розпізнає лише вказаний тип таблиці розділів
    -u, --units[=<unit>]          одиниці відображення: «циліндри» або «сектори» (за замовчуванням)
    -s, --getsz                  відображає розмір пристрою в 512-байтних секторах [ЗАСТАРІЛЕ]
     --bytes                   друкує SIZE у байтах, а не у форматі, зрозумілому людині
     --lock[=<mode>]           використовує ексклюзивне блокування пристрою (так, ні або неблокувати)
    -w, --wipe <mode>             стирає підписи (авто, завжди або ніколи)
    -W, --wipe-partitions <mode>  стирає підписи з нових розділів (авто, завжди або ніколи)
    -C, --cylinders <number>      вказує кількість циліндрів
    -H, --heads <number>         вказує кількість голів
    -S, --sectors <number>        визначає кількість секторів на трек
    ```

### `fsck`

Використовується для перевірки та відновлення файлових систем Linux. Насправді обгортка для кількох інших утиліт для файлової системи (наприклад, fsck.ext3, fsck.ext2 тощо).

Синопсис:

    ```
    Використання:
        fsck [options] -- [fs-options] [<filesystem> ...]

        Перевірка та відновлення файлової системи Linux.

    Options:
        -A         перевіряє всі файлові системи
        -C [<fd>]  відображає індикатор прогресу; дескриптор файлу призначений для GUI
        -l         блокує пристрій, щоб гарантувати ексклюзивний доступ
        -M         не перевіряє змонтовані файлові системи
        -N         не виконує, просто показує, що буде зроблено
        -P         паралельно перевіряє файлові системи, включаючи кореневу
        -R        пропускає кореневу файлову систему; корисно лише з '-A'
        -r [<fd>]  звітує статистику для кожного перевіреного пристрою;
                   дескриптор файлу призначений для GUI
        -s         серіалізує операції перевірки
        -T         не показує назву під час запуску
        -t <type>  визначає типи файлових систем, які потрібно перевірити;
                    <type> може бути списком, розділеним комами
        -V         пояснює, що робиться
    ```

### `hdparm`

Використовується для отримання або встановлення параметрів жорсткого диска

Синопсис:

    ```
    hdparm [options] [device]
    ```

### `tune2fs`

Використовується для налаштування настроюваних параметрів файлової системи у файлових системах ext2/ext3/ext4. Під час виконання цієї операції файлова система не повинна бути змонтованою на запис.

Синопсис:

    ```
    Використання: tune2fs [-c max_mounts_count] [-e errors_behavior] [-f] [-g group]
        [-i interval[d|m|w]] [-j] [-J journal_options] [-l]
        [-m reserved_blocks_percent] [-o [^]mount_options[,...]]
        [-r reserved_blocks_count] [-u user] [-C mount_count]
        [-L volume_label] [-M last_mounted_dir]
        [-O [^]feature[,...]] [-Q quota_options]
        [-E extended-option[,...]] [-T last_check_time] [-U UUID]
        [-I new_inode_size] [-z undo_file] device
    ```

### `mkswap`

Створює область підкачки Linux на пристрої

Синопсис:

    ```
    mkswap [-c] [-vN] [-f] [-p PSZ] device [size]
    ```

### `mkfs`

Створення файлових систем Linux

Синопсис:

    ```
    mkfs [ -V ] [ -t fstype ] [ fs-options ] filesys [ blocks ]
    ```

### `parted`

Програма для розділення диска та зміни його розміру.

Синопсис:

    ```
    Parted [options] [device [command [options]]]
    ```

### `swapon` та `swapoff`

Увімкнути/вимкнути пристрої та файли для підкачки та обміну

Синопсис:

    ```
    swapon [-v] [-p priority] specialfile
    ```

### `mount`

Використовується для монтування файлової системи.

Синопсис:

    ```
    Mount [-fnrsvw] [-o options [,...]] device | dir
    ```

## Завдання 1

ВИКОНАЙТЕ ЦЮ ВПРАВУ У СВОЇЙ ЛОКАЛЬНІЙ СИСТЕМІ

Створення перегородок (`fdisk`, `mke2fs`, `fsck`, `tune2fs`)

У цій вправі ви створите додаткові розділи на жорсткому диску. Під час початкового встановлення ви залишили трохи вільного місця. Ви будете створювати перегородки в цьому просторі.

Розбиття диска на розділи дозволяє розглядати диск як групу незалежних областей зберігання.

Розділи також спрощують резервне копіювання та допомагають обмежити потенційні проблемні області.

Місце на жорсткому диску не безмежне, і одним із ваших обов’язків як адміністратора є керування доступним обмеженим простором. Наприклад, простим способом обмежити загальну область зберігання на диску, де користувачі можуть зберігати свої файли, є створення окремого розділу для домашнього каталогу користувачів (звичайно, також можна використовувати квоти).

### Для вивчення блокових пристроїв зберігання

Ви будете використовувати утиліту `fdisk`

1. Увійшовши в систему як root, відобразіть поточну структуру вашого диска. Впишіть:

    ```bash
    [root@serverXY root]# fdisk -l

        Disk /dev/vda: 25 GiB, 26843545600 bytes, 52428800 sectors
        Units: sectors of 1 * 512 = 512 bytes
        Sector size (logical/physical): 512 bytes / 512 bytes
        I/O size (minimum/optimal): 512 bytes / 512 bytes
        Disklabel type: dos
        Disk identifier: 0xb3053db5

        Device     Boot Start      End  Sectors Size Id Type
        /dev/vda1  *     2048 52428766 52426719  25G 83 Linux
    ```

2. Показати поточну статистику використання диска. Впишіть:

    ```bash
      [root@serverXY root]#  df -h
      Filesystem      Size  Used Avail Use% Mounted on
      devtmpfs        4.0M     0  4.0M   0% /dev
      tmpfs           479M   84K  479M   1% /dev/shm
      /dev/vda1        24G  8.5G   14G  39% /
      ...<SNIPPED>...
    ```

    З наведеного вище зразка вихідних даних у стовпці «Використано» ви можете побачити, що основний розділ ( /dev/vda1), до якого змонтовано наш кореневий (/) каталог, повністю (100%) заповнений.

    Звичайно, результат може бути іншим, якщо у вас диск іншого розміру або якщо ви не дотримувалися схеми розділення, яка використовувалася під час встановлення ОС.

#### Щоб створити [фальшивий] блоковий пристрій

Ми не хочемо, щоб ви випадково змінили локальний жорсткий диск у вашій системі та зробили його непрацездатним, тому ми виконаємо наступні вправи на псевдопристрої, який веде себе та імітує справжній блоковий пристрій. Для цього буде створено [sparse] файл розумного розміру та пов’язано його з псевдопристроєм. У системах Linux ці псевдопристрої називаються пристроями циклу. Пристрій циклу — це псевдопристрій, який дає змогу розглядати [і отримувати доступ] до звичайного файлу даних як до блокового пристрою.

(Цей крок приблизно дорівнює рішенням, які ви повинні прийняти щодо придбання фактичних дисків/сховища для сервера. Такі рішення, як тип, марка, розмір, інтерфейс, форм-фактор тощо)

1. Увійшовши в систему як користувач root, скористайтеся утилітою losetup, щоб створити розріджений файл розміром 10 ГБ. Впишіть:

    ```bash
    [root@serverPR root]# truncate --size 10GiB /tmp/10G-fake-disk.img
    ```

2. Виконайте команду `losetup` без будь-яких параметрів, щоб показати активні пристрої петлі. Впишіть:

    ```bash
    [root@serverPR root]# losetup
    ```

3. Виконайте команду `losetup` знову, щоб переглянути/знайти перший невикористаний пристрій петлі. Впишіть:

    ```bash
    [root@serverPR root]# losetup -f --nooverlap
    /dev/loop0
    ```

    Перший придатний або невикористаний пристрій циклу у виводі нашої зразкової системи — `/dev/loop0`.

4. Використовуючи 10G-fake-disk.img як резервний файл, пов’яжіть файл із доступним пристроєм циклу, виконавши:

    ```bash
    losetup -f --nooverlap --partscan /tmp/10G-fake-disk.img
    ```

5. Виконайте команду `losetup` ще раз, щоб показати використовувані пристрої петлі. Впишіть:

    ```bash
    [root@serverPR root]# losetup
    NAME       SIZELIMIT OFFSET AUTOCLEAR RO BACK-FILE              DIO LOG-SEC
    /dev/loop0         0      0         0  0 /tmp/10G-fake-disk.img   0     512
    ```

6. Використовуйте утиліту `sfdisk`, щоб отримати список будь-яких розділів на новому псевдоблоковому пристрої. Впишіть:

    ```bash
    [root@localhost ~]# sfdisk -l /dev/loop0
    Disk /dev/loop0: 10 GiB, 10737418240 bytes, 20971520 sectors
    Units: sectors of 1 * 512 = 512 bytes
    Sector size (logical/physical): 512 bytes / 512 bytes
    I/O size (minimum/optimal): 512 bytes / 512 bytes
    ```

7. Тепер скористайтеся `fdisk`, щоб отримати список будь-яких розділів на тому самому пристрої. Впишіть:

    ```bash
    [root@localhost ~]# fdisk -l /dev/loop0
    Disk /dev/loop0: 10 GiB, 10737418240 bytes, 20971520 sectors
    Units: sectors of 1 * 512 = 512 bytes
    Sector size (logical/physical): 512 bytes / 512 bytes
    I/O size (minimum/optimal): 512 bytes / 512 bytes
    ```

#### Для створення перегородок

1. Ви створите новий розділ за допомогою програми `fdisk`. `fdisk` працює в інтерактивному режимі, тому ви матимете багато підказок у стилі запитань і відповідей для виконання конкретних завдань.

    Почніть із передачі назви блокового пристрою циклу як аргументу `fdisk`. Впишіть:

    ```bash
    [root@localhost ~]# fdisk /dev/loop0

    Welcome to fdisk (util-linux 2.*).
    Changes will remain in memory only, until you decide to write them.
    Be careful before using the write command.

    Device does not contain a recognized partition table.
    Created a new DOS disklabel with disk identifier 0xe3aa91a1.

    Command (m for help):
    ```

2. Відкрийте вбудовану довідкову систему для `fdisk`, ввівши `m` у рядку `fdisk`.

    ```bash
    Command (m for help): m
    Help:

    DOS (MBR)
    a   вимикає завантажувальний прапор
    b   редагує вкладену мітку диска BSD
    c   вимикає прапор сумісності з DOS

    Generic
    d   видаляє розділ
    F   перераховує вільний нерозподілений простір
    l   містить список відомих типів розділів
    n   додає новий розділ
    p   друкує таблицю розділів
    t   змінює тип розділу
    v   перевіряє таблицю розділів
    i   друкує інформацію про розділ
    ...<SNIP>...
    ```

3. Показаний список довідки показує, що `n` використовується для додавання нового розділу. Введіть `n` у запиті:

    ```bash
    Command (m for help): n
    Partition type
    p   primary (0 primary, 0 extended, 4 free)
    e   extended (container for logical partitions)
    ```

4. Створіть основний тип розділу, ввівши `p`:

    ```bash
    Command (m for help): n
    Partition type
    p   primary (0 primary, 0 extended, 4 free)
    e   extended (container for logical partitions)
    Select (default p): p
    ```

5. Це перший первинний розділ на блочному пристрої. Встановіть номер розділу на 1:

    ```bash
    Partition number (1-4, default 1): 1
    ```

6. Прийміть стандартне значення для першого сектора блокового пристрою, натиснувши ++enter++:

    ```bash
    First sector (2048-20971519, default 2048):
    ```

7. Прийміть значення за замовчуванням для останнього сектора блокового пристрою, натиснувши ++enter++:

    ```bash
    Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-20971519, default 20971519):
    ```

8. Повернувшись у головну підказку `fdisk`, введіть `p`, щоб надрукувати поточну таблицю розділів блокового пристрою:

    ```bash
    Command (m for help): p
    Disk /dev/loop0: 10 GiB, 10737418240 bytes, 20971520 sectors
    Units: sectors of 1 * 512 = 512 bytes
    Sector size (logical/physical): 512 bytes / 512 bytes
    I/O size (minimum/optimal): 512 bytes / 512 bytes
    Disklabel type: dos
    Disk identifier: 0xe3aa91a1

    Device       Boot Start      End  Sectors Size Id Type
    /dev/loop0p1       2048 20971519 20969472  10G 83 Linux
    ```

    Новий розділ, який ви створили, знаходиться на `/dev/loop0p1` вище. Ви помітите, що тип розділу «83».

9. Все виглядає добре. Запишіть усі зміни до таблиці розділів, ввівши підкоманду `w` `fdisk`:

    ```bash
    Command (m for help): w
    ```

    Ймовірно, ви побачите попередження про невдачу повторного читання таблиці розділів.

    Команда `w` `fdisk` також закриває програму `fdisk` і повертає підказку оболонки.

10. Відповідно до попередження, яке ви могли отримати після запису таблиці розділів на диск у попередньому кроці, іноді вам може знадобитися вжити додаткових заходів, щоб спонукати ядро підтвердити нові зміни жорсткого диска. Для цього використовуйте команду `partprobe`:

    ```bash
    [root@localhost ~]# partprobe
    ```

    !!! tip "Підказка"

     Під час використання `fdisk` типовим типом розділу для новостворених розділів є Linux (0x83). Ви можете змінити тип за допомогою команди `fdisk` `t`. Наприклад, щоб змінити тип розділу на тип LVM (0x8e), ви повинні зробити наступне:
    
      Введіть `t`, щоб змінити тип розділу:

        ```bash
        Command (m for help): t
        ```


     Потім у запиті введіть шістнадцятковий код (0x8e) для розділів типу LVM:

        ```bash
        Hex code or alias (type L to list all): 8e
        ```


     Запишіть усі зміни до таблиці розділів, ввівши команду `w` `fdisk`:

        ```bash
        Command (m for help): w
        ```

#### Щоб створити фізичний том

Щоб допомогти продемонструвати деякі тонкі відмінності між традиційним методом керування блоковими пристроями та більш сучасними підходами, такими як підхід диспетчера томів, ми створимо новий псевдоблоковий пристрій і спробуємо підготувати його (подібно до розділення) для використання з файлова система.

У наступних кроках ми створимо новий пристрій циклу, який підтримується іншим звичайним файлом. А потім ми перейдемо до налаштування пристрою для системи диспетчера логічних томів (LVM).

1. Увійшовши як користувач із правами адміністратора, створіть розріджений файл розміром 10 ГБ під назвою `10G-fake-lvm-disk.img`. Впишіть:

    ```bash
    [root@server root]# truncate --size 10GiB /tmp/10G-fake-lvm-disk.img
    ```

2. Виконайте команду `losetup`, щоб переглянути/знайти перший невикористаний пристрій петлі. Впишіть:

    ```bash
    [root@serverPR root]# losetup -f --nooverlap
    ```

    Перший придатний або невикористаний пристрій циклу нашої зразкової системи було збільшено, і тепер це /dev/loop1.

3. Використовуючи 10G-fake-lvm-disk.img як резервний файл, пов’яжіть файл із доступним пристроєм циклу, виконавши:

    ```bash
    [root@server root]# losetup -f --nooverlap --partscan /tmp/10G-fake-lvm-disk.img
    ```

4. Виконайте команду `losetup`, щоб показати використовувані пристрої петлі. Впишіть:

    ```bash
    [root@localhost ~]# losetup
    ```

    **Вихід**

    ```bash
    NAME       SIZELIMIT OFFSET AUTOCLEAR RO BACK-FILE                  DIO LOG-SEC
    /dev/loop1         0      0         0  0 /tmp/10G-fake-lvm-disk.img   0     512
    /dev/loop0         0      0         0  0 /tmp/10G-fake-disk.img       0     512
    ```

    Ми бачимо зіставлення /dev/loop1 із резервним файлом /tmp/10G-fake-lvm-disk.img у наших результатах. Чудово.

5. Використовуйте команду `pvdisplay`, щоб переглянути фізичні томи, визначені наразі в системі. Впишіть:

    ```bash
    [root@localhost ~]# pvdisplay
    --- Physical volume ---
    PV Name               /dev/vda3
    VG Name               rl
    PV Size               98.41 GiB / not usable 2.00 MiB
    ...<SNIP>...
    ```

6. Ініціалізуйте новий блоковий пристрій /dev/loop1 (10G-fake-lvm-disk.img) як фізичний том. Використовуйте утиліту `pvcreate`. Впишіть:

    ```bash
    [root@localhost ~]# pvcreate /dev/loop1
    Physical volume "/dev/loop1" successfully created.
    ```

7. Виконайте команду `pvdisplay`, щоб переглянути будь-які зміни.

#### Щоб призначити фізичний том групі томів

У цьому розділі ви дізнаєтесь, як призначити фотоелектричний пристрій до наявної групи томів. Це має чистий ефект збільшення ємності наявної групи томів.

Ви додасте фізичний том (PV) `/dev/loop1`, який було підготовлено та створено вище, до наявної групи томів (VG) `rl`.

1. Використовуйте команду `vgdisplay`, щоб переглянути поточні налаштовані групи томів. Впишіть:

    ```bash
    [root@localhost ~]# vgdisplay
    ```

    **Вихід**

    ```bash
    --- Volume group ---
    VG Name               rl
    System ID
    Format                lvm2
    ..........
    VG Size               98.41 GiB
    PE Size               4.00 MiB
    Total PE              25193
    Alloc PE / Size       25193 / 98.41 GiB
    Free  PE / Size       0 / 0
    ...<SNIP>...
    ```

    !!! note "Примітка"

     З результату вище: 
    
     - Назва групи томів – rl 
     - Розмір VG становить 98,41 ГіБ
     - У VG є 0 (нуль) вільних фізичних екстентів (PE), що еквівалентно 0 МБ простору.

2. Призначте новий PV (/dev/loop1) до наявної групи томів `rl`. Скористайтеся командою `vgextend`, введіть:

    ```bash
    [root@localhost ~]# vgextend rl /dev/loop1
    ```

    **Вихід**

    ```bash
    Volume group "rl" successfully extended
    ```

3. Виконайте команду `vgdisplay` ще раз, щоб переглянути зміни. Впишіть:

    ```bash
    [root@localhost ~]# vgdisplay
    ```

    **Вихід**

    ```bash
    --- Volume group ---
    VG Name               rl
    System ID
    Format                lvm2
    Metadata Areas        2
    Metadata Sequence No  5
    .......
    VG Size               <108.41 GiB
    PE Size               4.00 MiB
    Total PE              27752
    Alloc PE / Size       25193 / 98.41 GiB
    Free  PE / Size       2559 / <10.00 GiB
    ...<SNIP>...
    ```

    !!! Question "Питання"

     Використовуючи вихідні дані `vgdisplay`, запишіть зміни у вашій системі. Які нові значення для «Free PE / Size»?

#### Для видалення LV, VG і PV

У цьому розділі описано, як видалити `/dev/loop1`` PV, який ви призначили існуючому`rl` VG у попередньому розділі.

1. Видаліть логічний том під назвою scratch2. Впишіть:

    ```bash
    [root@localhost ~]# lvremove -f  /dev/rl/scratch2
    Logical volume "scratch2" successfully removed.
    ```

2. Видаліть логічний том scratch3, виконавши:

    ```bash
    [root@localhost ~]# lvremove -f  /dev/rl/scratch3
    ```

3. Вилучивши відповідні томи, тепер ви можете зменшити розмір VG `rl`, щоб зробити його узгодженим. Впишіть:

    ```bash
    [root@localhost ~]# vgreduce --removemissing  rl
    ```

4. Видаліть усі мітки LVM із PV `/dev/loop1`. Впишіть:

    ```bash
    [root@localhost ~]# pvremove /dev/loop1
    Labels on physical volume "/dev/loop1" successfully wiped.
    ```

#### Щоб створити нову групу томів

У цьому розділі ви створите нову окрему групу томів під назвою "scratch".  Скретч VG отримає свій простір повністю з псевдоблокового пристрою `/dev/loop1`.

1. Створіть новий простір `scratch`. Впишіть:

    ```bash
    [root@localhost ~]# vgcreate scratch /dev/loop1
    Physical volume "/dev/loop1" successfully created.
    Volume group "scratch" successfully created
    ```

2. Виконайте команду `vgdisplay`, щоб переглянути свої зміни. Впишіть:

    ```bash
    [root@localhost ~]# vgdisplay scratch
    --- Volume group ---
    VG Name               scratch
    System ID
    Format                lvm2
    Metadata Areas        1
    Metadata Sequence No  1
    .......
    VG Size               <10.00 GiB
    PE Size               4.00 MiB
    Total PE              2559
    Alloc PE / Size       0 / 0
    Free  PE / Size       2559 / <10.00 GiB
    VG UUID               nQZPfK-bo7E-vOSR***
    ...<SNIP>...
    ```

    !!! question "Питання"

     Перегляньте вихідні дані `vgdisplay`. Які значення для «Free PE / Size»? І чим ці значення відрізняються від попередніх розділів, коли ви додали PV `/dev/loop1` до існуючої групи томів `rl`?

#### Щоб створити логічний том

Завдяки додатковому вільному простору, який ми додали до групи томів `rl` (VG), тепер можна додати логічний том, який можна використовувати для зберігання даних після форматування.

1. Використовуйте команду `lvdisplay`, щоб переглянути поточні налаштовані логічні томи. Впишіть:

    ```bash
    [root@localhost ~]# lvdisplay
    ```

    !!! question "Питання"

     Виходячи з результатів, дайте відповідь на наступні запитання: 
    
     1. Скільки логічних томів (LV) визначено?
    
     2. Як називаються LVs?
    
     3. Для чого використовуються різні LV у вашій системі?

2. Використовуйте команду `lvs`, щоб аналогічно відобразити логічні томи, але відфільтрувати вихідні дані, щоб показати певні поля. Фільтр для перегляду полів lv_name (ім’я логічного тому), lv_size (розмір логічного тому), lv_path, vg_name (ім’я групи томів). Впишіть:

    ```bash
    [root@localhost ~]# lvs  -o lv_name,lv_size,lv_path,vg_name
    LV   LSize   Path         VG
    home <29.68g /dev/rl/home rl
    root <60.79g /dev/rl/root rl
    swap  <7.95g /dev/rl/swap rl
    ```

    !!! note "Примітка"

     lv_name = ім'я логічного тому, lv_size = розмір логічного тому, lv_path = шлях логічного тому, vg_name = група обсягів.

3. У новому VG `scratch` створіть новий логічний том під назвою «scratch2» за допомогою команди `lvcreate`. Встановіть для `scratch2` розмір 2 ГБ. Впишіть:

    ```bash
    [root@localhost ~]# lvcreate -L 2G --name scratch2 scratch
    Logical volume "scratch2" created.
    ```

4. Створіть другий логічний том під назвою «scratch3». Цього разу використайте вільний простір у групі томів `scratch`. Впишіть:

    ```bash
    [root@localhost ~]# lvcreate -l 100%FREE --wipesignatures y --yes --zero y --name scratch3 scratch
    Logical volume "scratch3" created.
    ```

5. Скористайтеся командою `lvdisplay` знову, щоб переглянути новий LV.

## Завдання 2

Щоб традиційні розділи та томи у стилі LVM, створені раніше, могли використовуватися операційною системою, вам потрібно створити на них файлові системи. Запис файлової системи на пристрій також відомий як форматування диска.

Ця вправа охоплює створення файлової системи, а також використання деяких поширених інструментів обслуговування файлової системи.

### Щоб створити файлову систему VFAT

Тут ви використаєте програму `mke2fs` для створення файлової системи vFAT у новому розділі /dev/loop0p1.

1. Використовуйте утиліту `mkfs.vfat`, щоб створити файлову систему типу vfat на томі `/dev/loop0p1`. Впишіть:

    ```bash
    [root@localhost ~]# mkfs.vfat /dev/loop0p1
    ```

    **Вихід**

    ```bash
    mkfs.fat 4.*
    ```

2. Використовуйте `lsblk`, щоб запитати систему щодо цікавої інформації про блоковий пристрій. Впишіть:

    ```bash
    [root@localhost ~]# lsblk -f /dev/loop0
    ```

    **Вихід**

    ```bash
    NAME      FSTYPE LABEL UUID                 MOUNTPOINT
    loop0
    └─loop0p1 vfat         658D-4A90
    ```

#### Щоб створити файлову систему EXT4

Щоб логічні томи, створені раніше, могли використовуватися операційною системою, потрібно створити на них файлові системи. Запис файлової системи на пристрій також відомий як форматування диска.

Тут ви використаєте програму `mke2fs` для створення файлової системи EXT4 на новому тому scrtach1.

1. Використовуйте утиліту `mkfs.ext4`, щоб створити файлову систему типу EXT4 на томі `/dev/scratch/scratch2`. Впишіть:

    ```bash
    [root@localhost ~]# mkfs.ext4 /dev/scratch/scratch2
    ...<SNIP>...
    Writing superblocks and filesystem accounting information: done
    ```

2. Використовуйте `lsblk`, щоб запитати систему щодо цікавої інформації про том scratch2. Впишіть:

    ```bash
    [root@localhost ~]# lsblk -f /dev/scratch/scratch2
    NAME        FSTYPE LABEL UUID          MOUNTPOINT
    scratch-scratch2 ext4         6689b6aa****
    ```

#### Щоб створити файлову систему XFS

Тут ви використаєте програму `mke2fs` для створення файлової системи XFS на новому томі scratch2.

1. Використовуйте утиліту `mkfs.xfs`, щоб створити файлову систему типу XFS на томі `/dev/rl/scratch3`. Впишіть:

    ```bash
    [root@localhost ~]# mkfs.xfs /dev/scratch/scratch3
    meta-data=/dev/scratch/scratch3  isize=512    agcount=4, agsize=524032 blks
    ...<SNIP>...
    Discarding blocks...Done.
    ```

2. Використовуйте `lsblk`, щоб запитати систему щодо цікавої інформації про том scratch2. Впишіть:

    ```bash
    [root@localhost ~]# lsblk -f /dev/scratch/scratch3
    ```

    **Вихід**

    ```bash
    NAME        FSTYPE LABEL UUID         MOUNTPOINT
    scratch-scratch3 xfs          1d1ac306***
    ```

#### Щоб використовувати `dumpe2fs`, `tune2fs`, `lsblk` та `fsck`

Тут ми розглянемо деякі поширені утиліти файлової системи, які можна використовувати для підтримки файлової системи, виправлення проблем файлової системи, налагодження проблем файлової системи тощо.

1. Дізнайтеся значення поточної «максимальної кількості монтувань» на томі scratch2. Впишіть:

    ```bash
    [root@localhost ~]# dumpe2fs /dev/scratch/scratch2 | grep -i  "maximum mount count"
    dumpe2fs 1.4***
    Maximum mount count:      -1
    ```

    !!! question "Питання"

     1. Якій меті служить «максимальна кількість монтувань»?
     2. Яке значення максимальної кількості монтувань вашого кореневого тому (/dev/rl/root)?

2. Налаштуйте/встановіть максимальне значення підрахунку монтувань на нуль між перевірками файлової системи на тому `/dev/scratch/scratch2`. Використовуйте команду `tune2fs`. Впишіть:

    ```bash
    [root@localhost ~]# tune2fs -c 0 /dev/scratch/scratch2
    tune2fs 1.*.*
    Setting maximal mount count to -1
    ```

3. Використовуйте команду `fsck`, щоб перевірити файлову систему scratch1. Впишіть:

    ```bash
    [root@localhost ~]# fsck -Cfp /dev/scratch/scratch2
    fsck from util-linux 2.*
    /dev/mapper/scratch-scratch2: 11/131072 files (0.0% non-contiguous), 26156/524288 blocks
    ```

4. Створіть мітку тому для нового тому EXT4 за допомогою програми `tune2fs`. Впишіть:

    ```bash
    [root@localhost root]# tune2fs -L scratch2 /dev/scratch/scratch2
    ```

5. Використовуйте `lsblk`, щоб переглянути інформацію про `/dev/scratch/scratch2`. Впишіть:

    ```bash
    [root@localhost ~]# lsblk -o name,size,label /dev/scratch/scratch2
    NAME        SIZE LABEL    
    scratch-scratch2   2G scratch2
    ```

6. Перевірте файлову систему XFS на томі scratch3. Впишіть:

    ```bash
    [root@localhost ~]# fsck -Cfp /dev/scratch/scratch3
    fsck from util-linux 2.*
    /usr/sbin/fsck.xfs: XFS file system.  
    ```

## Вправи

У попередніх вправах було описано підготовку блоку/пристрою зберігання для використання в системі. Після виконання всіх етапів розділення, форматування тощо останній крок у доступності файлової системи користувачам для зберігання даних називається монтуванням.

У цій вправі буде описано, як `монтувати` та `демонтувати` файлові системи, які ми створили у попередній вправі.

### `mount`

Команда `mount` використовується для приєднання файлової системи, створеної на пристрої, до ієрархії файлів.

#### Для монтування файлової системи VFAT

1. Увійдіть в систему як користувач з правами адміністратора.

2. Створіть папку з назвою `/mnt/10gb-scratch1-partition`. Ця папка використовуватиметься в точці монтування для файлової системи scratch1. Впишіть:

    ```bash
    [root@localhost ~]# mkdir /mnt/10gb-scratch1-partition
    ```

3. Монтуємо перегородку. Впишіть:

    ```bash
    [root@localhost ~]# mount /dev/loop0p1  /mnt/10gb-scratch1-partition
    ```

4. Використовуйте команду `mount`, щоб відобразити всі файлові системи VFAT у системі. Використовуйте grep, щоб відфільтрувати вихід для слова `scratch`. Впишіть:

    ```bash
    [root@localhost ~]# mount -t vfat | grep scratch
    ```

5. Використовуйте команду `df`, щоб переглянути звіт про використання дискового простору файлової системи на сервері. Впишіть:

    ```bash
    [root@localhost ~]# df -ht vfat | grep scratch
    ```

6. Використовуйте опцію `--bind` із командою `mount`, щоб файлова система `/mnt/10gb-scratch1-partition` також відображалася під простішою назвою або більш зручне ім’я/шлях, наприклад `/mnt/scratch1`. Впишіть:

    ```bash
    [root@localhost ~]# mount --bind /mnt/10gb-scratch1-partition /mnt/scratch1
    ```

7. Скористайтеся командою `df` ще раз, щоб переглянути ефект монтування прив’язки.

#### Для монтування файлової системи EXT4

1. Створіть папку з назвою `/mnt/2gb-scratch2-volume`. Ця папка використовуватиметься в точці монтування для тому scratch2. Впишіть:

    ```bash
    [root@localhost ~]# mkdir /mnt/2gb-scratch2-volume
    ```

2. Монтуємо перегородку. Впишіть:

    ```bash
    [root@localhost ~]# mount /dev/scratch/scratch2  /mnt/2gb-scratch2-volume
    ```

3. Використовуйте команду `mount`, щоб відобразити всі файлові системи EXT4. Впишіть:

    ```bash
    [root@localhost ~]# mount -t ext4
    ```

4. Переконайтеся, що точка монтування має відповідні дозволи, щоб дозволити всім системним користувачам писати на підключений том, виконавши:

    ```bash
    [root@localhost ~]# chmod 777 /mnt/2gb-scratch2-volume
    ```

5. Використовуйте команду `df`, щоб переглянути звіт про використання дискового простору файлової системи на сервері.

#### Для монтування файлової системи XFS

1. Створіть папку під назвою `/mnt/8gb-scratch3-volume`. Це буде точка монтування для файлової системи scratch3. Впишіть:

    ```bash
    [root@localhost ~]# mkdir /mnt/8gb-scratch3-volume
    ```

2. Монтуємо перегородку. Впишіть:

    ```bash
    [root@localhost ~]# mount /dev/scratch/scratch3  /mnt/8gb-scratch3-volume
    ```

3. Використовуйте команду `mount`, щоб відобразити всі файлові системи XFS у системі. Впишіть:

    ```bash
    [root@localhost ~]# mount -t xfs | grep scratch
    ```

4. Використовуйте команду `df`, щоб переглянути звіт про використання дискового простору файлової системи на сервері.

#### Щоб зробити монтування файлової системи постійними

1. Використовуйте команду `cat`, щоб переглянути поточний вміст файлу `/etc/fstab`.

2. Перш ніж вносити будь-які зміни, створіть резервну копію файлу `/etc/fstab`. Впишіть:

    ```bash
    [root@localhost ~]# cp /etc/fstab  /etc/fstab.copy
    ```

3. Використовуючи текстовий редактор, обережно додайте такі нові записи у файл `/etc/fstab` для 3 файлових систем, які ми створили раніше.

    Нові записи:

    ```bash
    /dev/loop0p1           /mnt/10gb-scratch1-partition   auto   defaults,nofail  0  0
    /dev/scratch/scratch2  /mnt/2gb-scratch2-volume       ext4   defaults,nofail  0  0
    /dev/scratch/scratch3  /mnt/2gb-scratch3-volume        xfs   defaults,nofail  0  0
    ```

    Для створення записів ми використаємо наведений нижче метод BASH heredoc. Обережно введіть:

    ```bash
    [root@localhost ~]# cat >> /etc/fstab << EOF
    /dev/loop0p1           /mnt/10gb-scratch1-partition   auto   defaults,nofail  0  0
    /dev/scratch/scratch2  /mnt/2gb-scratch2-volume       ext4   defaults,nofail  0  0
    /dev/scratch/scratch3  /mnt/8gb-scratch3-volume        xfs   defaults,nofail  0  0 
    EOF
    ```

4. Для реальних дисків або пристроїв зберігання даних попередніх кроків буде достатньо, щоб система автоматично та правильно монтувала всі нові файлові системи та застосувала будь-які спеціальні параметри монтування.

    АЛЕ, оскільки ми використовували спеціальні псевдоблокові пристрої (пристрої циклу) у цій лабораторії, ми повинні виконати додаткове важливе завдання, щоб забезпечити автоматичне відтворення правильних пристроїв циклу після перезавантаження системи.

    Щоб допомогти з цим, ми створимо спеціальний сервісний блок systemd.

    Щоб створити файл `/etc/systemd/system/loopdevices.service`, скористайтеся будь-яким текстовим редактором, який вам зручний.

    Введіть наступний текст у файл.

    ```bash
    [Unit]
    Description=Activate loop devices
    DefaultDependencies=no
    After=systemd-udev-settle.service
    Before=lvm2-activation.service
    Wants=systemd-udev-settle.service

    [Service]
    ExecStart=losetup -P /dev/loop0 /tmp/10G-fake-disk.img
    ExecStart=losetup -P /dev/loop1 /tmp/10G-fake-lvm-disk.img
    Type=oneshot

    [Install]
    WantedBy=local-fs.target
    ```

    Переконайтеся, що ви зберегли зміни у файлі.

5. Використовуйте команду `systemctl`, щоб увімкнути новий пристрій циклу. Впишіть:

    ```bash
    [root@localhost ~]# systemctl enable loopdevices.service
    ```

6. Спробуйте запустити службу, щоб переконатися, що вона запускається успішно. Впишіть:

    ```bash
    [root@localhost ~]# systemctl start loopdevices.service
    ```

    Якщо він запускається без будь-яких помилок, тепер ви можете переходити до наступного кроку, де ви проведете справжній тест перезавантаження системи.

7. Перезавантажте систему та переконайтеся, що все працює нормально та що нові файлові системи підключено автоматично.

## Завдання 4

**Преамбула:**

Без вагомої причини користувач під назвою «нерозумний» вирішив створити надзвичайно ВЕЛИКИЙ файл у системі, яка використовується для інших користувачів!!

Файл зайняв багато місця на локальному жорсткому диску.

Як адміністратор ви можете знайти та видалити файл-порушник і продовжувати свій день, сподіваючись, що це одноразовий випадок, АБО ви можете знайти та видалити файл, щоб звільнити місце на диску, і розробити план запобігання цьому повторенню. Ми спробуємо скористатися останнім рішенням у наступній вправі.

Тимчасово -
> Нерозумний користувач знову завдає удару!

### Щоб створити великий файл

(**Виконайте цю вправу зі своєї партнерської системи**)

Нерозсудливий користувач випадково помічає, що нові файлові системи ***scratch*** стали доступними на сервері протягом ночі. "Це чудово!" — каже він собі.

Потім він заповнює том довільно великим файлом.

1. Увійдіть у систему як `unreasonable` користувач.

2. Перевірте систему, щоб побачити, чи є нові файлові системи, якими ви можете зловживати. Впишіть:

    ```bash
    [unreasonable@localhost ~]$ df  -h
    ```

3. Негайно приступайте до заповнення доступної спільної файлової системи сміттям. Впишіть

    ```bash
    [unreasonable@localhost ~]$ dd if=/dev/zero \
       of=/mnt/2gb-scratch2-volume/LARGE-USELESS-FILE.tar bs=10240
    ```

    **Вихід**

    ```bash
    dd: error writing '/mnt/2gb-scratch2-volume/LARGE-USELESS-FILE.tar': No space left on device
    187129+0 records in
    187128+0 records out
    1916194816 bytes (1.9 GB, 1.8 GiB) copied, 4.99021 s, 384 MB/s
    ```

4. Запустивши процес `dd`, вийдіть на прогулянку та поверніться, коли команда завершиться або виникне помилка, тому що вона не може йти далі. Або піти і знайти адміністратора та поскаржитися на те, що дисковий простір у системі переповнений.

5. Ознайомтеся з іншими нерозумними/безглуздими/дратівливими речами, які можна робити в системі. Ви ***нерозумний користувач***.

## Завдання 5

### Квоти

Впровадження та примусове використання дискових квот забезпечує спосіб переконатися, що в системі достатньо місця на диску та що користувачі залишаються в межах виділеного дискового простору. Перед впровадженням квот вам необхідно:

- Вирішіть, на яких розділах або томах ви хочете застосувати дискові квоти.
- Вирішіть, на якому рівні застосовувати квоти – наприклад, для кожного користувача, для групи чи для обох.
- Вирішіть, якими будуть ваші м’які та жорсткі обмеження.
- Визначте пільгові періоди (тобто чи будуть вони взагалі).

*Жорсткий ліміт*

Жорстке обмеження визначає абсолютний максимальний обсяг дискового простору, який може використовувати користувач або група. Після досягнення цього ліміту дисковий простір використовувати не можна.

*М'який ліміт*

М'яке обмеження визначає максимальний обсяг дискового простору, який можна використовувати. Однак, на відміну від жорсткого обмеження, м’яке обмеження можна перевищувати на деякий час. Цей час відомий як пільговий період.

*Пільговий період*

Пільговий період – це час, протягом якого може бути перевищено м’який ліміт. Період відстрочки може бути виражений у секундах, хвилинах, годинах, днях, тижнях або місяцях, таким чином надаючи системному адміністратору велику свободу у визначенні часу, який надати користувачам, щоб використання диска було нижче встановленого ліміту.

Це кроки високого рівня, пов’язані з впровадженням квот.

- Встановлення програмного забезпечення квот
- Змінення файлу “/etc/fstab”
- Повторне монтування файлової системи (систем)
- Виконання перевірки квот
- Призначення квот

Ви будете використовувати такі команди:

`quotacheck`:

Утиліта для перевірки та відновлення файлів квот.

```bash
quotacheck [-gucbfinvdmMR] [-F <quota-format>] filesystem|-a

  -u, --user                перевіряє файли користувача
  -g, --group               перевіряє файли групи
  -c, --create-files        створює нові файли квот
  -b, --backup              створює резервні копії старих файлів квот
  -f, --force               примусово перевіряє, навіть якщо квоти ввімкнено
  -i, --interactive         інтерактивний режим
  -n, --use-first-dquot     використовує першу копію дубльованої структури
  -v, --verbose             друкує більше інформації
  -d, --debug               друкує ще більше повідомлень
  -m, --no-remount          не перемонтує файлову систему лише для читання
  -M, --try-remount         намагається перемонтувати файлову систему лише для читання,
                            продовжується, навіть якщо не вдається
  -R, --exclude-root        виключає root під час перевірки всіх файлових систем
  -F, --format=formatname   перевіряє файли квот певного формату
  -a, --all                 перевіряє всі файлові системи
```

`edquota`:

Інструмент для редагування квот користувачів

```bash
  СИНОПСИС
       edquota [ -p protoname ] [ -u | -g | -P ] [ -rm ] [ -F format-name ] [ -f filesystem ] username | groupname | projectname...

       edquota [ -u | -g | -P ] [ -F format-name ] [ -f filesystem ] -t

       edquota [ -u | -g | -P ] [ -F format-name ] [ -f filesystem ] -T username | groupname | projectname...
```

`repquota`:

Утиліта для звітності про квоти.

```bash
  Використання:
  repquota [-vugsi] [-c|C] [-t|n] [-F quotaformat] [-O (default | xml | csv)] (-a | mntpoint)

  -v, --verbose               також відображає користувачів/групи без будь-якого використання
  -u, --user                  відображає інформацію про користувачів
  -g, --group                 відображає інформацію про групи
  -P, --project               відображає інформацію про проекти
  -s, --human-readable        показує числа в зручних для людини одиницях (MB, GB, ...)
  -t, --truncate-names        скорочує імена до 9 символів
  -p, --raw-grace             друкує час відстрочки в секундах від епохи
  -n, --no-names              не перекладає uid/gid на ім'я
  -i, --no-autofs             уникає точок монтування autofs
  -c, --cache                перекладає велику кількість ідентифікаторів одночасно
  -C, --no-cache              перекладає ідентифікатори один за одним
  -F, --format=formatname     повідомляє інформацію для певного формату
  -O, --output=format        формат виводу як xml або csv
  -a, --all                   повідомляє інформацію для всіх точок монтування з квотами
```

`quotaon` та `quotaoff`:

Інструменти, які використовуються для ввімкнення та вимкнення квот файлової системи

```bash
  СИНОПСИС
       quotaon [ -vugfp ] [ -F format-name ] filesystem...
       quotaon [ -avugPfp ] [ -F format-name ]

       quotaoff [ -vugPp ] [ -x state ] filesystem...
       quotaoff [ -avugp ]
```

#### Щоб встановити програмне забезпечення квот

1. Увійшовши в систему як root, спочатку перевірте, чи встановлено пакет `quota-*.rpm` у вашій системі. Впишіть:

    ```bash
    [root@localhost ~]# rpm -q quota
    quota-*
    ```

    !!! question "Питання"

     Яким був ваш результат?

2. ЯКЩО у вашій системі не встановлений пакет квот, скористайтеся `dnf`, щоб встановити його.

#### Щоб налаштувати квоту

1. Ви вирішили застосувати квоти стилю EXT4 на томі «/dev/rl/scratch2». Ви також вирішили запровадити квоти на рівні користувача та групи.

2. Перегляньте файл `/etc/fstab` за допомогою обраного редактора. Нижче наведено відповідний запис у файлі, перш ніж ми внесемо будь-які зміни у файл.

    ```bash
    [root@localhost ~]# grep scratch2 /etc/fstab
    ```

    **Вихід**

    ```bash
    /dev/scratch/scratch2  /mnt/2gb-scratch2-volume    ext4     defaults  0  0
    ```

3. Зробіть резервну копію `/etc/fstab`.

4. У рамках впровадження квот до запису тому scratch2 потрібно додати деякі нові параметри монтування, пов’язані з квотами. Запис обсягу scratch2 потрібно оновити до нового рядка тут:

    ```bash
    /dev/scratch/scratch2  /mnt/2gb-scratch2-volume   ext4   defaults,usrquota,grpquota  0  0
    ```

    Ви можете використати свій улюблений текстовий редактор, щоб внести зміни, або скористатися утилітою `sed`, як показано на наступному кроці.

5. Використовуйте утиліту `sed`, щоб знайти рядок, який ми хочемо змінити, і зробити оновлення на місці. Впишіть:

    ```bash
    [root@localhost ~]# sudo sed -i \
    '/^\/dev\/scratch\/scratch2/ s|.*|/dev/scratch/scratch2  /mnt/2gb-scratch2-volume   ext4   defaults,usrquota,grpquota  0  0|'\
    /etc/fstab
    ```

6. Знову скористайтеся `grep`, щоб швидко переглянути файл і переконатися, що в `/etc/fstab` внесено правильні зміни.

7. Щоб зміни в `/etc/fstab` набули чинності, вам потрібно буде зробити ще кілька речей. Спочатку перезавантажте systemd-daemon, виконавши:

    ```bash
    [root@localhost ~]# systemctl daemon-reload
    ```

8. Потім перемонтуйте відповідну файлову систему. Впишіть:

    ```bash
    [root@localhost ~]# mount -o remount /mnt/2gb-scratch2-volume
    ```

9. Перевірте, чи застосовано нові параметри монтування, перевіривши файл `/proc/mounts`. Впишіть:

    ```bash
    [root@localhost ~]# cat /proc/mounts  | grep scratch2
    ```

    **Вихід**

    ```bash
    /dev/mapper/rl-scratch2 /mnt/2gb-scratch2-volume ext4 rw,relatime,quota,usrquota,grpquota 0 0
    ```

    !!! tip "Підказка"

     Ви також можете перевірити параметри монтування для будь-якої файлової системи за допомогою команди `mount`. У попередньому прикладі ви можете переглянути параметри монтування для тома scratch2 у форматі ext4, виконавши:

        ```bash
        [root@localhost ~]# mount -t ext4 | grep scratch2
        ```


     **ВИХІД**
        ```
        /dev/mapper/scratch-scratch2 on /mnt/2gb-scratch2-volume type ext4   (rw,relatime,quota,usrquota,grpquota)
        ```

    !!! question "Питання"

     Записати команди для окремого `відмонтування` даної файлової системи, а потім `монтування` її назад?

10. Тепер вам потрібно підготувати файлову систему для підтримки квот. Створіть файли квот і згенеруйте таблицю поточного використання диска для кожної файлової системи. Впишіть:

    ```bash
    [root@localhost ~]# quotacheck -avcug
    ```

    **Вихід**

    ```bash
    ....
    quotacheck: Scanning /dev/mapper/scratch-scratch2 [/mnt/2gb-scratch2-volume] done
    ...<SNIP>...
    quotacheck: Old file not found.
    quotacheck: Old file not found.  
    ```

    !!! question "Питання"

     Після виконання наведеної вище команди ви помітите два нових файли, створені в каталозі «/mnt/2gb-scratch2-volume». Перелічіть файли тут?

    !!! tip "Підказка"

     Щоб отримати оновлений статус файлової системи квот, вам слід періодично запускати команду `quotacheck -avcug`, коли квоти вимкнено у файловій системі.

11. Щоб увімкнути квоти користувачів і груп на всіх файлових системах, указаних у «/etc/fstab», введіть:

    ```bash
    [root@localhost ~]# quotaon -av
    ```

#### Для призначення квот користувачам

Ви вирішили призначити м’який ліміт у 90 МБ і жорсткий ліміт у 100 МБ для кожного користувача системи з пільговим періодом у 5 хвилин.

Це означає, що всі користувачі, яким ми застосовуємо квоту, не можуть перевищувати жорсткий ліміт у 100 МБ, але вони мають приблизно 5 хвилин, щоб перевищити свій м’який ліміт у 90 МБ, але залишаються за жорстким лімітом.

1. Ви створите обмеження за допомогою прототипу користувача. Користувач під назвою «me» буде вашим прототипом користувача. Створіть обмеження за допомогою команди `edquota`. Впишіть:

    ```bash
    [root@serverXY  root]# edquota -u me
    ```

    Наведена вище команда відкриє ваш типовий редактор із наведеним нижче вмістом:

    ```bash
    Disk quotas for user me (uid 1001):
    Filesystem                   blocks       soft       hard     inodes     soft     hard
    /dev/mapper/scratch-scratch2           0          0          0          0        0        0
    ```

    Змініть/відредагуйте наведений вище файл (3-й рядок), щоб відобразити потрібні обмеження. Змініть файл на читання:

    ```bash
    Disk quotas for user me (uid 1001):
    Filesystem                   blocks       soft       hard     inodes     soft     hard
    /dev/mapper/scratch-scratch2        0         90000      100000       0        0        0
    ```

    Збережіть зміни у файлі та закрийте його.

2. Ви створите пільговий період за допомогою параметра `-t` з командою `edquota`. Впишіть:

    ```bash
    [root@serverXY  root]# edquota -t 
    ```

    Ця команда відкриє типовий редактор із вмістом, схожим на показаний нижче:

    ```bash
    Grace period before enforcing soft limits for users:
    Time units may be: days, hours, minutes, or seconds
    Filesystem             Block grace period     Inode grace period
    /dev/mapper/scratch-scratch2                  7days                  7days
    ```

    Відредагуйте наведений вище файл (4-й рядок), щоб відобразити бажаний пільговий період.

    Змініть файл на читання:

    ```bash
    Grace period before enforcing soft limits for users:
    Time units may be: days, hours, minutes, or seconds
    Filesystem             Block grace period     Inode grace period
    /dev/mapper/scratch-scratch1       5minutes                  7days
    ```

3. Далі застосуйте параметри, які ви налаштували для прототипу користувача «me», до користувачів — «ying» і «unreasonable».  Впишіть:

    ```bash
    [root@localhost ~]# edquota -p me -u ying unreasonable
    ```

4. Щоб отримати звіт про стан усіх увімкнених квот, введіть:

    ```bash
    [root@localhost ~]# repquota /mnt/2gb-scratch2-volume
    ```

    **Вихід**

    ```bash
    *** Report for user quotas on device /dev/mapper/scratch-scratch2
    Block grace time: 00:05; Inode grace time: 7days
                          Block limits                File limits
    User            used    soft    hard  grace    used  soft  hard  grace
    ----------------------------------------------------------------------
    root      --      20       0       0              2     0     0
    unreasonable +- 1871288   90000  100000  00:04       1     0     0
    ```

    !!! Question "Питання"

     Скільки пільгового періоду залишилося у користувача, виходячи з наведених вище стовпців пільгових платежів для користувача `unreasonable`?

5. Зі звіту ви помітили, що unreasonable користувач перевищів ліміти своїх серверних квот. Ви шукаєте образливий файл і допомагаєте unreasonable користувачеві «очистити його» та повернути його у відповідність. Впишіть:

    ```bash
    [root@localhost ~]# rm -rf /mnt/2gb-scratch2-volume/LARGE-USELESS-FILE.tar
    ```

6. Використовуйте команду `su`, щоб тимчасово прийняти особу користувача `unreasonable` і спробувати створити додаткові файли або каталоги від імені цього користувача. Впишіть:

    ```bash
    [root@localhost ~]# su - unreasonable
    ```

7. Увійшовши в систему як необґрунтований користувач, ви перевіряєте та помічаєте, що файл `/mnt/2gb-scratch2-volume/LARGE-USELESS-FILE.tar`, створений у попередній вправі, відсутній! Роздратований, ви вирішуєте створити його знову. Впишіть:

    ```bash
    [unreasonable@localhost ~]$ dd if=/dev/zero  of=/mnt/2gb-scratch2-volume/LARGE-USELESS-FILE.tar bs=10240
    ```

    **Вихід**

    ```bash
    ...<SNIP>...
    dd: error writing '/mnt/2gb-scratch2-volume/LARGE-USELESS-FILE.tar': Disk quota exceeded
    10001+0 records in
    10000+0 records out
    102400000 bytes (102 MB, 98 MiB) copied, 0.19433 s, 527 MB/s
    ```

    Хммм...цікаво, бурчиш ти.

8. Спробуйте створити папку під назвою test у /mnt/2gb-scratch2-volume/. Порожня папка не повинна займати або використовувати багато місця на диску, тому ви вводите:

    ```bash
    [unreasonable@localhost ~]$ mkdir /mnt/2gb-scratch2-volume/test
    mkdir: cannot create directory ‘/mnt/2gb-scratch2-volume/test’: Disk quota exceeded
    ```

9. Перевірте розмір файлу LARGE-USELESS-FILE.tar. Впишіть:

    ```bash
    [unreasonable@localhost ~]$ ls -l /mnt/2gb-scratch2-volume/LARGE-USELESS-FILE.tar
    -rw-rw-r-- 1 unreasonable unreasonable 102400000 Oct  5 19:37 /mnt/2gb-scratch2-volume/LARGE-USELESS-FILE.tar
    ```

    !!! Question "Питання"

     Що сталося?

10. Розчаровані невіглаством, нерозумні користувачі типи:

    ```bash
    [unreasonable@localhost ~]$ man quota
    ```

    !!! Note "Примітка"

     «unreasonable» користувач буде змушений щось зробити з створеним ним «LARGE-USELESS-FILE.tar».  Поки цей користувач не зменшить загальний розмір файлу до свого ліміту, він не зможе зробити багато іншого.

11. Усе виконано за допомогою цієї лабораторної роботи щодо файлових систем Linux.
