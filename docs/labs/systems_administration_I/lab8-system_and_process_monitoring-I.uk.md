---
author: Wale Soyinka
contributors: Steven Spencer, Ganna Zhyrnova
tested on: Всі версії
tags:
  - моніторинг системи
  - моніторинг процесу
  - ps
  - pgrep
  - pidof
  - cgroups
  - pstree
  - top
  - kill
  - lsof
  - pkill
  - exec
---

# Лабораторна робота 8: Моніторинг системи та процесів

## Завдання

Після виконання цієї лабораторної роботи ви зможете:

- переглядати та керувати процесами
- вбити помилкові процеси
- змінити пріоритет процесу

Приблизний час виконання цієї лабораторної роботи: 60 хвилин

## Вступ

Ці вправи охоплюють різні теми, пов’язані з моніторингом та керуванням процесами в системах Linux. Розглянуті теми включають ідентифікацію та контроль процесів, керування пріоритетами процесів, обробку сигналів, моніторинг ресурсів та керування «cgroups».

## Завдання 1

### `ps` і /proc дослідження

#### Щоб дослідити та ідентифікувати перший системний процес

1. Увійдіть в систему під будь-яким користувачем.

2. Знайдіть назву процесу з ідентифікатором процесу 1 за допомогою /proc.

   ```bash
   cat /proc/1/comm
   ```

   !!! question "Питання"

   ```
    Як називається процес з PID 1?
   ```

3. Перегляньте ім’я та шлях до виконуваного файлу процесу з PID 1.

   ```bash
   ls -l /proc/1/exe
   ```

   !!! question "Питання"

   ```
    Який шлях до виконуваного файлу за PID 1?
   ```

4. Використовуйте команду `ps`, щоб дізнатися назву процесу або програми, що стоїть за PID 1.

   ```bash
   ps -p 1 -o comm=
   ```

   !!! question "Питання"

   ```
    Чи підтверджує команда `ps` назву процесу?
   ```

5. Використовуйте команду `ps`, щоб переглянути повний шлях і будь-які аргументи командного рядка процесу або програми за PID 1.

   ```bash
   ps -p 1 -o args=
   ```

   !!! question "Питання"

   ```
    Який повний шлях і аргументи командного рядка для процесу з PID 1?
   ```

   !!! question "Питання"

   ```
    Чому процес із PID 1 важливий у системі Linux?
   ```

#### Щоб відобразити детальну інформацію про процес за допомогою `ps`

Наступні кроки показують, як використовувати `ps` для відображення основної інформації про процес.

1. Використовуйте команду `ps`, щоб відобразити список усіх процесів у структурі дерева.

   ```bash
   ps auxf
   ```

   !!! question "Питання"

   ```
    Яка структура списку процесів і яка інформація відображається?
   ```

2. Відфільтруйте список лише для відображення процесів, пов’язаних із певним користувачем, наприклад, користувачем «root».

   ```bash
   ps -U root
   ```

   Переконайтеся, що відображаються лише процеси для користувача root.

3. Показуйте процеси в детальному форматі, включаючи дерево процесів і потоки. Впишіть:

   ```bash
   ps -eH
   ```

   !!! question "Питання"

   ```
    Які додаткові деталі відображаються в цьому форматі?
   ```

4. Відображати процеси, відсортовані за використанням ЦП у порядку спадання.

   ```bash
   ps aux --sort=-%cpu
   ```

   !!! question "Питання"

   ```
    Який процес споживає найбільше ЦП?
   ```

## Завдання 2

### Керування процесами за допомогою `kill`

#### Щоб завершити процес за допомогою `kill`

1. Запустіть тривалий процес сну у фоновому режимі та відобразіть PID на своєму терміналі. Впишіть:

   ```bash
   (sleep 3600 & MYPROC1=$! && echo PID is: $MYPROC1) 2>/dev/null
   ```

   Вихід

   ```bash
   PID is: 1331933
   ```

   Занотуйте PID для нового процесу у вашій системі. PID також зберігається в змінній $MYPROC1.

2. Надішліть сигнал завершення (SIGTERM) процесу «сплячого режиму».

   ```bash
   kill $MYPROC1
   ```

   Замініть $MYPROC1 фактичним PID з кроку 1.

3. Перевірте, чи було завершено процес за допомогою `ps` і `ps aux`.

   ```bash
   ps aux | grep -v grep | grep sleep
   ```

#### Для завершення процесів за допомогою сигналів `kill`

1. Почніть новий процес сну та запишіть його PID. Впишіть:

   ```bash
   (sleep 3600 & MYPROC2=$! && echo PID is: $MYPROC2) 2>/dev/null
   ```

   Вихід

   ```bash
   PID is: 1333258
   ```

2. Надішліть інший сигнал (наприклад, SIGHUP) до нового процесу сну. Впишіть:

   ```bash
   kill -1 $MYPROC2
   ```

   Переконайтеся, що $MYPROC2 більше не міститься в таблиці процесів.

3. Почніть новий процес ping і запишіть його PID. Впишіть:

   ```bash
   { ping localhost > /dev/null 2>&1 & MYPROC3=$!; } \
       2>/dev/null; echo "PID is: $MYPROC3"
   ```

4. Використовуйте команду `kill`, щоб надіслати сигнал `SIGTERM` процесу ping. Впишіть:

   ```bash
   kill -15 $MYPROC3
   ```

   Замініть MYPROC3 фактичним PID процесу у вашій системі.

5. Запустіть тривалий процес за допомогою команди `cat`. Впишіть:

   ```bash
   { cat /dev/random > /dev/null 2>&1 & MYPROC4=$!; } \
    2>/dev/null; echo PID is: $MYPROC4
   ```

   Занотуйте PID для процесу у вашій системі.

6. Використовуйте `kill`, щоб примусово завершити процес, надіславши сигнал SIGKILL.

   ```bash
   kill -9 $MYPROC4
   ```

   Підтвердьте, що процес завершено.

   !!! question "Питання"

   ```
    Поясніть мету надсилання сигналів процесам за допомогою команди `kill` і значення різних типів сигналів.
   ```

## Завдання 3

### Моніторинг системних ресурсів за допомогою `top`

#### Для моніторингу використання системних ресурсів за допомогою `top`

1. Запустіть верхню команду, щоб переглянути системну статистику в реальному часі.

   ```bash
   top
   ```

   !!! question "Питання"

   ```
    Яка інформація відображається у верхньому інтерфейсі?
   ```

2. Спостерігайте за використанням процесора та пам’яті процесами у верхньому інтерфейсі.

   !!! question "Питання"

   ```
    Які процеси споживають найбільше процесора та пам’яті?
   ```

3. Відсортуйте процеси вгорі за використанням ЦП (натисніть P) і використанням пам’яті (натисніть M).

   !!! question "Питання"

   ```
    Які процеси найбільше споживають процесор і пам’ять після сортування?
   ```

#### Щоб контролювати використання процесора та пам’яті певними процесами, використовуючи `top`

1. Створіть довільно великий файл розміром 512 МБ, який містить випадкові дані.

   ```bash
   sudo fallocate -l 512M  ~/large-file.data
   ```

2. Почніть ресурсомісткий процес, наприклад значне стиснення файлу.

   ```bash
    tar -czf archive.tar.gz /path/to/large/directory
   ```

3. Відкрийте команду `top`, щоб контролювати використання ЦП і пам'яті.

   ```bash
    top
   ```

4. У верхньому інтерфейсі знайдіть і виберіть ресурсомісткий процес.

   !!! question "Питання"

   ```
    Який ідентифікатор процесу та використання ресурсів інтенсивного процесу?
   ```

5. Змініть порядок сортування вгорі, щоб відобразити процеси, які використовують найбільше ЦП або пам’яті (натисніть P або M).

   !!! question "Питання"

   ```
    Який процес знаходиться у верхній частині списку після сортування?
   ```

6. Вийдіть із верхньої частини, натиснувши `q`.

#### Для моніторингу процесів і використання ресурсів за допомогою `top`

1. Запустіть команду `top` в інтерактивному режимі.

   ```bash
   top
   ```

   !!! question "Питання"

   ```
    Яка інформація відображається на верхньому екрані?
   ```

2. Використовуйте одну клавішу, щоб відобразити підсумок використання окремого ядра ЦП.

   !!! question "Питання"

   ```
    Яка розбивка використання ядра ЦП для кожного ядра?
   ```

3. Натисніть u, щоб відобразити процеси для певного користувача. Введіть своє ім'я користувача.

   !!! question "Питання"

   ```
    Які процеси зараз запущені для вашого користувача?
   ```

4. Відсортуйте процеси за використанням пам’яті (натисніть M) і спостерігайте за процесами, які споживають найбільше пам’яті.

   !!! question "Питання"

   ```
    Які процеси використовують найбільше пам’яті?
   ```

5. Вийдіть із верхньої частини, натиснувши q.

   !!! question "Питання"

   ```
    Поясніть значення моніторингу системних ресурсів за допомогою команди top і як це може допомогти у вирішенні проблем продуктивності.
   ```

## Завдання 4

### Зміна пріоритету процесу за допомогою `nice` і `renice`

#### Щоб налаштувати пріоритет процесу за допомогою `nice`

1. Запустіть процес із інтенсивним використанням процесора, який виконується з пріоритетом за замовчуванням/звичайним. Впишіть:

   ```bash
   bash -c  'while true; do echo "Default priority: The PID is $$"; done'
   ```

   Вихід

   ```bash
   Default priority: The PID is 2185209
   Default priority: The PID is 2185209
   Default priority: The PID is 2185209
   ....<SNIP>...
   ```

   З виведених даних значення PID у нашій системі зразка становить «2185209».

   Значення PID у вашій системі буде іншим.

   Зверніть увагу на те, що значення PID постійно відображається на екрані вашої системи.

2. В іншому терміналі, використовуючи значення PID, перевірте пріоритет процесу за замовчуванням за допомогою `ps`. Впишіть:

   ```bash
   ps -p <PID> -o ni
   ```

   !!! question "Питання"

   ```
    Який пріоритет процесу за замовчуванням (значення `nice`) запущеного процесу?
   ```

3. Використовуючи надрукований PID процесу, завершіть процес за допомогою команди `kill`.

4. Використовуючи команду `nice`, перезапустіть подібний процес із нижчим значенням якості (тобто більш сприятливим для процесу АБО вищим пріоритетом). Використовуйте `nice` значення «-20». Впишіть:

   ```bash
   nice -n -20 bash -c  'while true; do echo "High priority: The PID is $$"; done'
   ```

5. Використовуючи ваше значення PID, перевірте пріоритет процесу за допомогою `ps.` Впишіть:

   ```bash
   ps -p <PID> -o ni
   ```

   !!! question "Питання"

   ```
    Чи успішно встановлено пріоритет процесу?
   ```

6. Одночасно натисніть клавіші ++ctrl+c++ на клавіатурі, щоб «закрити» новий процес з високим пріоритетом.

7. Знову використовуючи команду `nice`, перезапустіть інший процес, але цього разу з вищим значенням акуратності (тобто найменш сприятливим для процесу АБО нижчим пріоритетом). Використовуйте `nice` значення `19`, впишіть:

   ```bash
    nice -n 19 bash -c  'while true; do echo "Low priority: The PID is $$"; done'
   ```

   Вихід

   ```bash
   Low priority: The PID is 2180254
   Low priority: The PID is 2180254
   ...<SNIP>...
   ```

8. Перевірте настроюваний пріоритет процесу за допомогою `ps`. Впишіть:

   ```bash
   ps -p <PID> -o ni
   ```

9. Одночасно натисніть клавіші ++ctrl+c++ на клавіатурі, щоб припинити новий процес із низьким пріоритетом.

10. Поекспериментуйте зі зміною пріоритету різних процесів на вищі та нижчі значення та спостерігайте за впливом на використання ресурсів процесу.

#### Щоб налаштувати пріоритет запущеного процесу за допомогою `renice`

1. Розпочніть інтенсивний процес, наприклад тривалий математичний розрахунок за допомогою утиліти md5sum. Впишіть:

   ```bash
   find / -path '/proc/*' -prune -o -type f -exec md5sum {} \; > /dev/null
   ```

2. Використовуйте команду `ps`, щоб визначити PID попереднього процесу `find/md5sum`. Впишіть:

   ```bash
   ps -C find -o pid=
   ```

   Вихід

   ```bash
   2577072
   ```

   Вихідні дані показують, що значення PID у нашій системі зразка становить «2577072».

   Значення PID у вашій системі буде іншим.

   Занотуйте значення PID у вашій системі.

3. Використовуйте команду `renice`, щоб змінити пріоритет запущеного процесу `find/md5sum` на нижче значення точності (наприклад, -10, вищий пріоритет). Впишіть:

   ```bash
   renice  -n -10 -p $(ps -C find -o pid=)
   ```

   Вихід

   ```bash
   <PID> (process ID) old priority 0, new priority -10
   ```

   Замініть "<PID>" (вище) фактичним PID запущеного процесу.

4. Контролюйте використання ресурсів для процесу `find/md5sum` за допомогою `top` (або `htop`).  Впишіть:

   ```bash
   top -cp $(ps -C find -o pid=)
   ```

   !!! question "Питання"

   ```
    Чи отримує процес тепер більшу частку ресурсів ЦП?
   ```

5. Змініть пріоритет процесу `find/md5sum` на вище значення `nice` (наприклад, 10, нижчий пріоритет). Впишіть:

   ```bash
   renice  -n 10 -p <PID>
   ```

   Вихід

   ```bash
   2338530 (process ID) old priority -10, new priority 10
   ```

   Замініть "<PID>" (вище) фактичним PID запущеного процесу.

   !!! question "Питання"

   ```
    Поясніть, як команда `nice` використовується для налаштування пріоритетів процесів і як вона впливає на розподіл системних ресурсів.
   ```

6. Одночасно натисніть клавіші ++ctrl+c++ на клавіатурі, щоб зупинити процес `find/md5sum`. Ви також можете використати команду `kill`, щоб виконати те ж саме.

## Завдання 5

### Ідентифікація процесів за допомогою `pgrep`

#### Ідентифікація процесів за допомогою `pgrep`

1. Використовуйте команду `pgrep`, щоб визначити всі процеси, пов’язані з певною програмою чи службою, наприклад `sshd`.

   ```bash
   pgrep sshd
   ```

   !!! question "Питання"

   ```
    Які ідентифікатори процесів `sshd`?
   ```

2. Перевірте існування ідентифікованих процесів за допомогою команди `ps`.

   ```bash
    ps -p <PID1,PID2,...>
   ```

   Замініть "<PID1,PID2,...>" ідентифікаторами процесу, отриманими на кроці 1.

3. Використовуйте команду `pgrep`, щоб ідентифікувати процеси з певною назвою, наприклад, "cron".

   ```bash
   pgrep cron
   ```

   !!! question "Питання"

   ```
    Чи існують процеси з назвою "cron"?
   ```

   !!! question "Питання"

   ```
    Поясніть різницю між використанням `ps` і `pgrep` для ідентифікації та керування процесами.
   ```

## Завдання 6

### Основні та фонові процеси

Ця вправа охоплює керування процесами за допомогою `fg` і `bg`

#### Для керування фоновими та активними процесами за допомогою `bg` і `fg`

1. Почніть довготривалий процес на передньому плані. Наприклад, ви можете використати просту команду на зразок `sleep`. Впишіть:

   ```bash
   sleep 300
   ```

2. Призупиніть процес переднього плану, натиснувши ++ctrl+z++ на клавіатурі. Це повинно повернути вас до командної оболонки.

3. Виведіть список призупинених завдань за допомогою команди `jobs`. Впишіть:

   ```bash
   jobs
   ```

   !!! question "Питання"

   ```
    Який статус призупиненої роботи?
   ```

4. Поверніть призупинене завдання на передній план за допомогою команди `fg`.

   ```bash
   fg
   ```

   !!! question "Питання"

   ```
    Що відбувається, коли ви повертаєте роботу на перший план?
   ```

5. Знову призупиніть роботу за допомогою ++ctrl+z++, а потім перемістіть її у фоновий режим за допомогою команди `bg`.

   ```bash
   bg
   ```

   !!! question "Питання"

   ```
    Який зараз статус роботи?
   ```

   !!! question "Питання"

   ```
    Поясніть призначення активних і фонових процесів і як ними керують за допомогою команд `fg` і `bg`.
   ```

#### Щоб розпочати процес у фоновому режимі

1. Символ `&` може запускати процес, який негайно виконується у фоновому режимі. Наприклад, щоб запустити команду `sleep` у фоновому режимі, введіть:

   ```bash
   sleep 300 &
   ```

   Призупиніть запущений процес за допомогою ++ctrl+z++.

2. Список статусів усіх активних завдань. Впишіть:

   ```bash
   jobs -l
   ```

   !!! question "Питання"

   ```
    Який статус процесу `sleep 300`?
   ```

3. Поверніть фоновий процес на передній план за допомогою команди `fg`.

   ```bash
   fg
   ```

4. Передчасно завершити процес «сплячого режиму», надіславши йому сигнал SIGSTOP, натиснувши ++ctrl+c++.

#### Для керування інтерактивними процесами за допомогою `bg` і `fg`

1. Запустіть інтерактивний процес, наприклад текстовий редактор `vi`, щоб створити та відредагувати зразок текстового файлу під назвою "foobar.txt". Впишіть:

   ```bash
   vi foobar1.txt
   ```

   Призупиніть запущений процес за допомогою `Ctrl` + `Z`.

   Використовуйте команду `bg`, щоб перевести призупинений процес у фоновий режим.

   ```bash
   bg
   ```

   !!! question "Питання"

   ```
    Процес зараз працює у фоновому режимі?
   ```

2. Введіть «Hello» у `foobar1.txt` у вашому редакторі `vi`.

3. Призупиніть запущений сеанс редагування тексту `vi`, натиснувши ++ctrl+z++.

4. Запустіть ще один окремий сеанс редактора `vi`, щоб створити інший текстовий файл під назвою "foobar2.txt". Впишіть:

   ```bash
   vi foobar2.txt
   ```

5. Введіть зразок тексту «Hi inside foobar2.txt» під час 2-го сеансу vi.

6. Призупиніть 2-й сеанс vi за допомогою ++ctrl+z++.

7. Покажіть статус усіх «задач» на поточному терміналі. Впишіть:

   ```bash
   jobs -l
   ```

   Вихід

   ```bash
   [1]- 2977364 Stopped       vi foobar1.txt
   [2]+ 2977612 Stopped       vi foobar2.txt
   ```

   Ви повинні мати принаймні дві роботи, перелічені у вашому виході. Число в 1-му стовпчику вихідних даних показує номери робіт - [1] і [2].

8. Відновіть ==та виведіть на передній план== 1-й сеанс `vi`, ввівши:

   ```bash
   fg %1
   ```

9. Знову призупиніть перший сеанс `vi` за допомогою ++ctrl+z++.

10. Відновіть ==та виведіть на передній план== 2-й сеанс `vi`, ввівши:

    ```bash
    fg %2
    ```

11. Припиніть обидва сеанси редагування `vi`, надіславши сигнал KILL до обох завдань. Слідкуйте за командою `kill` з командою jobs. Впишіть:

    ```bash
     kill -SIGKILL  %1 %2 && jobs
    ```

    Вихід

    ```bash
    [1]-  Killed                  vi foobar1.txt
    [2]+  Killed                  vi foobar2.txt
    ```

## Завдання 7

### Ідентифікація процесу за допомогою `pidof`

#### Щоб знайти ідентифікатор процесу запущеної команди за допомогою `pidof`

1. Давайте виберемо зразок/поширений запущений процес, ідентифікатор процесу якого ми хочемо знайти. Ми будемо використовувати `systemd` як наш приклад.

2. Використовуйте команду `pidof`, щоб знайти ідентифікатор процесу `systemd`. Впишіть:

   ```bash
   pidof systemd
   ```

   Зверніть увагу на ідентифікатор(и) процесу `systemd`.

3. Перевірте існування ідентифікованого процесу за допомогою команди `ps`.

   ```bash
   ps -p <PID>
   ```

   Замініть <PID> фактичним ідентифікатором процесу, отриманим на кроці 2.

   !!! question "Питання"

   ```
    Поясніть різницю між `pgrep` і `pidof` для пошуку ідентифікатора процесу запущеної команди.
   ```

## Завдання 8

### Вивчення файлової системи /sys

#### Щоб дослідити файлову систему /sys

1. Виведіть вміст каталогу /sys. Впишіть:

   ```bash
   ls /sys
   ```

   !!! question "Питання"

   ```
    Яка інформація зберігається в каталозі /sys?
   ```

2. Перейдіть до певного запису /sys, наприклад, інформації про ЦП.

   ```bash
   cd /sys/devices/system/cpu
   ```

3. Виведіть список вмісту поточного каталогу, щоб переглянути інформацію, пов’язану з ЦП.

   ```bash
   ls
   ```

   !!! question "Питання"

   ```
    Яка інформація про ЦП доступна у файловій системі /sys?
   ```

   !!! question "Питання"

   ```
    Поясніть призначення файлової системи /sys в Linux і її роль в управлінні обладнанням і конфігурацією системи.
   ```

## Завдання 9

### Знищення процесів за назвою за допомогою `pkill`

#### Щоб завершити процеси за назвою за допомогою `pkill`

1. Ідентифікуйте процеси з конкретною назвою, наприклад "firefox".

   ```bash
   pkill firefox
   ```

   !!! question "Питання"

   ```
    Чи всі процеси з назвою "firefox" були припинені?
   ```

2. Перевірте стан процесів, які ви зупинили за допомогою `ps`.

   ```bash
    ps aux | grep firefox
   ```

   !!! question "Питання"

   ```
    Чи залишилися процеси з назвою "firefox"?
   ```

   Використовуйте `pkill`, щоб примусово припинити всі процеси з певним іменем.

   ```bash
   pkill -9 firefox
   ```

   Переконайтеся, що всі процеси з назвою «firefox» завершено.

   !!! question "Питання"

   ```
    Яка різниця між використанням `kill` і `pkill` для завершення процесів за назвою?
   ```

## Вправа 10

Ця вправа охоплює використання потужної команди `exec`.

### Керування процесом за допомогою `exec`

#### Щоб замінити поточну оболонку іншою командою за допомогою `exec`

1. Розпочніть новий сеанс оболонки. Впишіть:

   ```bash
   bash
   ```

2. Виконайте команду, яка не завершується в новій оболонці, наприклад простий цикл while.

   ```bash
    while true; do echo "Running..."; done
   ```

3. У поточній оболонці замініть запущену команду на іншу за допомогою `exec`.

   ```bash
    exec echo "This replaces the previous command."
   ```

   Зауважте, що попередня команда завершується, та виконується нова команда.

4. Переконайтеся, що стара команда більше не виконується за допомогою `ps`.

   ```bash
   ps aux | grep "while true"
   ```

   !!! question "Питання"

   ```
    Попередня команда все ще виконується?
   ```

   !!! question "Питання"

   ```
    Поясніть, як команда `exec` може замінити поточний процес оболонки на іншу команду.
   ```

## Вправа 11

### Керування процесом за допомогою `killall`

Як і `kill`, `killall` є командою для завершення процесів за назвою. Можна спостерігати певну подібність між використанням `killall` , `kill` і `pkill` у завершенні процесу.

#### Щоб завершити процеси за назвою за допомогою `killall`

1. Ідентифікуйте процеси за допомогою конкретної назви, наприклад «chrome».

   ```bash
    killall chrome
   ```

   !!! question "Питання"

   ```
    Чи всі процеси з назвою "chrome" були припинені?
   ```

2. Перевірте стан процесів, які ви зупинили за допомогою `ps`.

   ```bash
    ps aux | grep chrome
   ```

   !!! question "Питання"

   ```
    Чи залишилися процеси з назвою "chrome"?
   ```

3. Використовуйте `killall`, щоб примусово припинити всі процеси з певною назвою.

   ```bash
    killall -9 chrome
   ```

   Переконайтеся, що всі процеси з іменем "chrome" завершено.

   !!! question "Питання"

   ```
    Чим `killall` відрізняється від `pkill` і `kill` при завершенні процесів за назвою?
   ```

## Вправа 12

### Керування `cgroups`

#### Для керування процесами за допомогою `cgroups`

1. Перелічіть існуючі `cgroups` у вашій системі.

   ```bash
   cat /proc/cgroups
   ```

   !!! question "Питання"

   ```
    Які контролери `cgroup` доступні у вашій системі?
   ```

2. Створіть нову cgroup за допомогою контролера ЦП. Назвіть її «mygroup».

   ```bash
   sudo mkdir -p /sys/fs/cgroup/cpu/mygroup
   ```

3. Перемістіть певний процес (наприклад, запущену команду сну) до «mygroup» `cgroup`.

   ```bash
   echo <PID> | sudo tee /sys/fs/cgroup/cpu/mygroup/cgroup.procs
   ```

   Замініть <PID> фактичним PID процесу.

4. Перевірте, чи процес перенесено до "mygroup" `cgroup`.

   ```bash
   cat /sys/fs/cgroup/cpu/mygroup/cgroup.procs
   ```

   !!! question "Питання"

   ```
    Чи вказаний процес у "mygroup" cgroup?
   ```

   !!! question "Питання"

   ```
    Поясніть концепцію «cgroups» у Linux і те, як вони можуть керувати та контролювати розподіл ресурсів для процесів.
   ```

## Вправа 13

### Керування процесами за допомогою `renice`

#### Щоб налаштувати пріоритет запущеного процесу за допомогою `renice`

1. Визначте запущений процес із певним PID та пріоритетом за допомогою `ps`.

   ```bash
   ps -p <PID> -o ni
   ```

   !!! question "Питання"

   ```
    Який поточний пріоритет (значення nice) процесу?
   ```

2. Використовуйте команду `renice`, щоб змінити пріоритет запущеного процесу (значення nice).

   ```bash
   renice <PRIORITY> -p <PID>
   ```

   Замініть <PRIORITY> на нове значення пріоритету, яке ви хочете встановити, а <PID> на фактичний PID процесу.

3. Переконайтеся, що пріоритет процесу було змінено за допомогою `ps`.

   ```bash
   ps -p <PID> -o ni
   ```

   !!! question "Питання"

   ```
    Зараз пріоритет інший?
   ```

4. Поекспериментуйте зі зміною пріоритету на вищі та нижчі значення та спостерігайте за впливом на використання ресурсів процесу.

   !!! question "Питання"

   ```
    Що відбувається зі споживанням ресурсів процесом із різними значеннями nice?
   ```

   !!! question "Питання"

   ```
    Поясніть, як команда renice використовується для налаштування пріоритету запущених процесів і її вплив на використання ресурсів процесу.
   ```
