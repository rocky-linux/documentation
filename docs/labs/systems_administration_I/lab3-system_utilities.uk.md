- - -
author: Wale Soyinka contributors: Steven Spencer, Ganna Zhyrnova tested on: Всі версії tags:
  - лабораторна вправа
  - системні утиліти
  - cli
- - -

## Цілі

Виконавши цю лабораторну роботу, ви зможете

- Використовувати звичайні системні утиліти, які є в більшості систем Linux

Приблизний час виконання цієї лабораторної роботи: 70 хвилин

## Загальні системні утиліти в системах Linux

### Що таке системна утиліта?

У середовищі Linux *системні утиліти* — це програми та команди, які дозволяють керувати, контролювати та оптимізувати роботу операційної системи. Ці інструменти є незамінними для системних адміністраторів, розробників та досвідчених користувачів, оскільки вони спрощують такі завдання, як управління файлами, контроль процесів, налаштування мережі та багато іншого.

На відміну від графічних інтерфейсів, багато утиліт доступні через командний рядок, що забезпечує більшу гнучкість, автоматизацію та контроль над системою.

Вправи в цій лабораторній роботі охоплюють деякі основні системні утиліти, з якими повинні бути знайомі користувачі та адміністратори. Більшість команд використовуються для навігації та керування файловою системою. Файлова система складається з файлів і каталогів.

Вправи стосуватимуться використання утиліт – `pwd`, `cd`, `ls`, `rm`, `mv`, `ftp`, `cp`, `touch`, `mkdir`, `file`, `cat`, `find` та `locate`.

## Вправи

### 1. Навігація по файловій системі за допомогою `cd`

Команда `cd` (скорочення від ==Change Directory==) є однією з найчастіше використовуваних команд в системах Linux та Unix-подібних системах. Вона дозволяє переміщатися між каталогами в файловій системі, даючи користувачам можливість переходити між папками та отримувати доступ до файлів, що містяться в них. Команда `cd` є необхідною для роботи в оболонці Linux, оскільки вона дозволяє ефективно досліджувати та організовувати файлову систему.

#### Як використовувати `cd`

1. Увійдіть на комп'ютер як root

2. Перейдіть із поточного каталогу до каталогу /etc.

    ```bash
    [root@localhost root]# cd /etc
    ```

3. Зауважте, що ваш запит змінився з “[root@localhost root]# ” на : “[root@localhost etc]# “

4. Перейдіть до каталогу `/usr/local/`

    ```bash
    [root@localhost etc]# cd /usr/local

    [root@localhost local]#
    ```

    !!! Question "Питання"

     Що змінилося у вашому запиті?

5. Поверніться до домашнього каталогу root

    ```bash
    [root@localhost local]# cd /root
    ```

6. Знову перейдіть до каталогу `/usr/local/`. Впишіть:

    ```bash
    [root@localhost root]# cd /usr/local
    ```

7. Щоб перейти до батьківського каталогу локального каталогу, введіть `cd ..`

    ```bash
    [root@localhost local]# cd ..
    ```

    !!! Question "Питання"

     Що таке батьківський каталог для каталогу `/usr/local/`?

8. Щоб швидко повернутися до домашнього каталогу root, введіть `cd` без аргументів.

    ```bash
    [root@localhost usr]# cd
    [root@localhost root]#
    ```

### 2. Відобразити шлях за допомогою `pwd`

Команда `pwd` (==Поточний робочий каталог (Present Working Directory)==) показує користувачеві абсолютний шлях до поточного каталогу в файловій системі. Вона використовується для визначення поточного розташування під час роботи в терміналі, коли ви хочете точно знати, де ви знаходитесь.  
Ця команда є необхідною для навігації по файловій системі, особливо під час роботи зі складними шляхами або автоматизованими скриптами.

#### Як використовувати `pwd`

1. Щоб дізнатися тип поточного робочого каталогу

    ```bash
    [root@localhost root]# pwd
    /root
    ```

2. Перейдіть до каталогу `/usr/local/` за допомогою команди `cd`:

    ```bash
    [root@localhost root]# cd /usr/local
    ```

3. Використовуйте `pwd`, щоб знайти поточний робочий каталог

    ```bash
    [root@localhost local]# pwd
    /usr/local
    ```

4. Повернутися до домашнього каталогу root.

    ```bash
    [root@localhost root]# cd
    ```

### 3. Створіть папки за допомогою `mkdir`

Команда `mkdir` (==Створити каталог==) дозволяє створювати нові каталоги (папки) у файловій системі. У цьому вправі ви створите дві папки з іменами `folder1` та `folder2`.

#### Як використовувати `mkdir`

1. Створіть перший каталог під назвою `folder1`

    ```bash
    [root@localhost root]# mkdir folder1
    ```

2. Створіть другий каталог під назвою `folder2`

    ```bash
    [root@localhost root]# mkdir folder2
    ```

3. Тепер змініть робочу директорію на директорію `folder1`, яку ви створили вище.

    ```bash
    [root@localhost root]# cd folder1
    ```

4. Покажіть ваш поточний робочий каталог.

    ```bash
    [root@localhost folder1]# pwd
    /root/folder1
    ```

    !!! question "Питання"

     Не виходячи з поточного каталогу, перейдіть до каталогу `folder2. Яка команда для цього?

5. Поверніться до домашнього каталогу root.

### 4. Змінити метадані файлу за допомогою `touch`

Команда touch — це інструмент, який дозволяє створювати нові порожні файли або змінювати дати доступу/зміни існуючих файлів, а також використовується для складних завдань у скриптах та автоматизації. Назва ==touch== походить від ідеї «*доторкатися*» до метаданих файлу без обов'язкового змінення його вмісту.  
Файли *file11*, *file12*, *file21* та *file22* будуть створені у вищезгаданих папках.

#### Як використовувати `touch`

1. Змініть каталог, наприклад `cd` на `folder1` та створіть *file11*:

    ```bash
    [root@localhost folder1]# touch file11
    ```

2. Перебуваючи в `folder1`, створіть *file12*:

    ```bash
    [root@localhost folder1]# touch file12
    ```

3. Тепер поверніться до домашнього каталогу root.

4. `cd`  до `folder2` та створіть *file21* і *file22*

    ```bash
    [root@localhost folder2]# touch file21 file22
    ```

5. Поверніться до домашнього каталогу root.

### 5. Перелічить каталоги за допомогою `ls`

Команда ls (==Список==) є однією з найосновніших і найпоширеніших команд в системах Linux та Unix-подібних системах. Він дозволяє переглядати вміст каталогу, відображаючи файли та підкаталоги з різними опціями форматування та сортування.

#### Щоб використовувати `ls`

1. Введіть `ls` у домашній каталог root

    ```bash
    [root@localhost root]# ls
    ```

    !!! Question "Питання"

     Перелічіть вміст каталогу

2. Перейдіть до каталогу `folder1`

3. Виведіть вміст каталогу `folder1`. Впишіть `ls`

    ```bash
    [root@localhost folder1]# ls
    file11  file12
    ```

4. Перейдіть до каталогу `folder2` і перелічіть його вміст тут:

5. Поверніться до домашнього каталогу та перерахуйте **всі** приховані файли та папки:

    ```bash
    [root@localhost folder2]# cd
    [root@localhost root]# ls –a
    ..  .bash_history  .bash_logout  .bash_profile  .bashrc  folder1  folder2  .gtkrc  .kde   screenrc
    ```

6. Щоб отримати довгий або детальний список усіх файлів і папок у вашому домашньому каталозі, введіть:

    ```bash
    [root@localhost root]# ls –al
    total 44
    drwx------    5 root    root        4096 May  8 10:15 .
    drwxr-xr-x    8 root     root         4096 May  8 09:44 ..
    -rw-------    1 root    root          43 May  8 09:48 .bash_history
    -rw-r--r--    1 root    root          24 May  8 09:44 .bash_logout
    -rw-r--r--    1 root    root         191 May  8 09:44 .bash_profile
    -rw-r--r--    1 root    root         124 May  8 09:44 .bashrc
    drwxrwxr-x    2 root    root        4096 May  8 10:17 folder1
    drwxrwxr-x    2 root    root        4096 May  8 10:18 folder2
    ………………………..
    ```

### 6. Переміщення файлів за допомогою `mv`

Команда `mv` (==Move==) надає інструмент для управління файлами в системі. Її основною функцією є переміщення або перейменування файлів і каталогів у файловій системі. Ця команда особливо корисна для реорганізації структури каталогів, виконання пакетних операцій над групами файлів та ефективного управління резервними копіями.

#### Як використовувати `mv`

1. Змініть каталог на каталог `folder1` і перегляньте його вміст:

    ```bash
    [root@localhost root]# cd folder1
    [root@localhost folder1] ls
    file11  file12
    ```

2. Ви перейменуєте *file11* і *file12* в каталозі `folder1` відповідно на *temp_file11* і *temp_file12*:

    ```bash
    [root@localhost folder1]# mv file11 temp_file11
    ```

3. Знову перерахуйте вміст `folder1`.

    ```bash
    [root@localhost folder1]# ls
    ```

    !!! Question "Питання"

     Запишіть зміст:

4. Перейменуйте *file12* на *temp_file12*:

    ```bash
    [root@localhost folder1]# mv file12 temp_file12
    ```

5. Не змінюючи каталог, перейменуйте файли *file21* та *file22* у `folder2` відповідно на *temp_file21* та *temp_file22*:

    ```bash
    [root@localhost folder1]# mv /root/folder2/file21 /root/folder2/temp_file21
    [root@localhost folder1]# mv /root/folder2/file22 /root/folder2/temp_file22
    ```

6. Не змінюючи ваш поточний каталог, перегляньте вміст `folder2`.

    !!! question "Питання"
   
        Яка команда для цього? Також перелічіть результат команди?

### 7. Копіювання файлів за допомогою `cp`

Команда `cp` (==Copy==) дозволяє дублювати файли та каталоги з одного місця в інше в файловій системі, зберігаючи оригінальний файл без змін. Його простота у використанні та універсальність роблять його незамінним як для повсякденних операцій, так і для більш складних завдань системного адміністрування. Серед найкорисніших функцій команди `cp` є можливість збереження оригінальних атрибутів файлів під час копіювання, включаючи *права доступу*, *мітки часу* та *інформацію про власника*. Ця функція є особливо важливою під час роботи з файлами конфігурації або коли необхідно зберегти певні властивості документа.

#### Як використовувати `cp`

1. Змініть свій каталог на каталог `folder2`.

2. Скопіюйте вміст папки `folder2` (*temp_file21* та *temp_file22*) до папки `folder1`:

    ```bash
    [root@localhost folder2]# cp temp_file21 temp_file22 ../folder1
    ```

3. Перелічіть вміст `folder1`.

    ```bash
    [root@localhost folder2]# ls ../folder1
    temp_file11  temp_file12  temp_file21  temp_file22
    ```

4. Перелічіть вміст `folder2`. Зверніть увагу, що оригінальні копії *temp_file21* та *temp_file22*  залишаються в  `folder2`.

    ```bash
    [root@localhost folder2]# ls
    temp_file21  temp_file22
    ```

### 8. Визначення типу файлу за допомогою `file`

Команда `file` є діагностичним інструментом, який дозволяє визначити тип файлу шляхом аналізу його вмісту. На відміну від розширень файлів, які можуть бути змінені або вводити в оману, ця команда перевіряє фактичну структуру даних, щоб точно визначити їх характер. Однією з найважливіших особливостей команди `file` є її здатність розрізняти різні типи текстових файлів, ідентифікуючи, наприклад, скрипти оболонки, вихідний код на різних мовах програмування, файли XML або JSON. Для бінарних файлів він може розпізнавати виконувані файли, спільні бібліотеки, зображення в різних форматах та багато інших типів структурованих даних.

#### Як використовувати `file`

1. Поверніться до домашнього каталогу.

2. Щоб перевірити, чи є `folder1` файлом або каталогом, впишіть:

    ```bash
    [root@localhost root]# file folder1
    folder1: directory
    ```

3. Перейдіть до каталогу `folder1`

4. Використовуйте утиліту `file`, щоб визначити тип файлу для *temp_file11*:

    ```bash
    [root@localhost folder1]# file temp_file11
    temp_file11: empty
    ```

5. Скористайтеся утилітою `file`, щоб дізнатися тип файлу для всіх файлів у каталозі `folder1`. Перелік тут:

6. Змініть каталог на каталог `/etc`:

    ```bash
    [root@localhost folder1]# cd /etc
    ```

7. Використовуйте утиліту `file`, щоб дізнатися тип файлу для файлу *passwd*.

    ```bash
    [root@localhost etc]# file passwd
    ```

    !!! Question "Питання"

     Який це тип файлу?

### 9. Перелічити та об'єднати файли за допомогою `cat`

Команда `cat` (скорочення від ==Concatenate==) є незамінним інструментом для управління текстовими файлами в Linux. Його основною функцією є відображення вмісту одного або декількох файлів безпосередньо в терміналі, але його також можна використовувати для створення, об'єднання або копіювання файлів.  
Команда cat особливо корисна в поєднанні з іншими інструментами (такими як `grep` або `more`) для обробки або фільтрації тексту безпосередньо з терміналу. Незважаючи на свою простоту, це одна з найпоширеніших команд для швидкої обробки файлів.  
Ви будете використовувати `cat` разом із символом перенаправлення «>» для створення файлу.

#### Щоб створити файл за допомогою `cat`

1. Змініть каталог на каталог `/root/folder1`

2. Створіть новий текстовий файл з назвою *first.txt*

    ```bash
    [root@localhost folder1]# cat > first.txt
    ```

3. Введіть наведену нижче фразу в пустому рядку та натисніть ++enter++.

    ```bash
    Це рядок з first.txt !!
    ```

4. Одночасно натисніть ++ctrl+c++.

5. Введіть `cat first.txt`, щоб прочитати щойно введений текст:

    ```bash
    [root@localhost folder1]# cat first.txt
    This is a line from first.txt !!
    ```

6. Створіть інший файл під назвою *second.txt* за допомогою `cat`. Введіть у файл наступний текст – «This is a line from second.txt!!»

    !!! Question "Питання"
   
        Яка команда для цього?

#### Щоб використовувати `cat` для об’єднання файлів

1. Ви об’єднаєте файли *first.txt* та *second.txt*. Впишіть:

    ```bash
    [root@localhost folder1]# cat first.txt second.txt
    ```

    !!! Question "Питання"

     Який ваш вихід?

### 10. Передача файлів за допомогою `ftp`

Команда `ftp` (File Transfer Protocol) — це інструмент командного рядка для передачі файлів між віддаленими та локальними системами. Хоча він був частково замінений більш сучасними та безпечними протоколами, такими як *SFTP* та *SCP*, він залишається корисним у застарілих контекстах або на серверах, які підтримують лише FTP.  
FTP передає дані у вигляді **відкритого тексту**, включаючи облікові дані та вміст, тому його не рекомендується використовувати для передачі конфіденційної інформації.  
Хоча FTP все ще використовується в деяких середовищах, для безпечних операцій краще використовувати зашифровані протоколи.  
У цьому вправі ви дізнаєтеся, як анонімно увійти на FTP-сервер і завантажити файл із сервера за допомогою програми *ftp-клієнт*.

!!! note "Примітка"

    Вам потрібно буде виконати вправи з попередньої лабораторної роботи, щоб продовжувати цю конкретну вправу, для якої потрібен доступний FTP-сервер, який працює десь доступно.

#### Як використовувати `ftp`

1. Увійдіть на свою машину як root

2. Змініть каталог на `/usr/local/src/`

3. Створіть новий каталог під назвою `downloads` в каталозі `/usr/local/src/`.

    !!! Question "Питання"
   
        Яка команда для цього?

4. Змініть каталог на щойно створений каталог `downloads`

    ```bash
    [root@localhost src]# cd downloads
    ```

5. Введіть `ftp`, щоб запустити клієнт *ftp client*:

    ```bash
    [root@localhost downloads]# ftp
    ftp>
    ```

6. Для підключення до FTP-сервера введіть:

    ```bash
    ftp> open  < server-address>    (Obtain the <server-address> from your instructor)
    ………
    220 localhost.localdomain FTP server (Version wu-2.6.2-5) ready.
    ………..
    ```

7. Увійдіть як анонімний користувач. Введіть “*anonymous*” у запиті:

    ```bash
    Name (10.4.51.29:root):  anonymous
    ```

8. У вікні запиту пароля введіть будь-яку *e-mail address* та натисніть клавішу ++enter++

    ```bash
    Password: ***************
    230 Guest login ok, access restrictions apply.
    Remote system type is UNIX.
    Using binary mode to transfer files.
    ftp>
    ```

9. Перейти в двійковий режим. Впишіть:

    ```bash
    ftp> binary
    ```

    !!! Question "Питання"

     Що таке вихід двійкової команди і що таке двійковий режим "двійковий режим"?

10. Перелічіть поточні каталоги на ftp-сервері. Введіть `ls` у запит *ftp prompt*:

    ```bash
    ftp> ls
    227 Entering Passive Mode (10,0,4,5,16,103).
    125 Data connection already open; Transfer starting.
    11-23-43  10:23PM       <DIR>          images
    11-02-43  02:20PM       <DIR>          pub
    226 Transfer complete.
    ```

11. Змініть каталог на каталог `pub`. Впишіть:

    ```bash
    ftp> cd  pub
    ```

12. Використовуйте команду `ls`, щоб отримати список файлів і каталогів у каталозі `pub`

    !!! Question "Питання"
    
         Скільки файлів і каталогів там зараз?

13. Завантажте файл під назвою “*hello-2.1.1.tar.gz*” у свій локальний каталог. Введіть “*yes*” у запиті.

    ```bash
    ftp> mget hello-2.1.1.tar.gz
    mget hello-2.1.1.tar.gz? yes
    227 Entering Passive Mode (10,0,4,5,16,252).
    125 Data connection already open; Transfer starting.
    226 Transfer complete.
    389363 bytes received in 0.0745 secs (5.1e+03 Kbytes/sec)
    ```

14. Вийдіть із FTP-сервера та вийдіть із клієнта *ftp client*. Впишіть:

    ```bash
    ftp> bye
    ```

15. Ви будете кинуті назад у свою локальну оболонку.

16. Переконайтеся, що ви все ще перебуваєте в каталозі `downloads` локальної машини.

    !!! question "Питання"
    
         Перелічіть файли в папці завантажень.

### 11. Використання перенаправлення

Більшість утиліт і команд, якими ви користуєтеся в Linux, надсилають вихідні дані на екран. Екран називається стандартним виводом (*stdout*). Переспрямування дає змогу надіслати результат кудись ще – можливо, файл.

Кожна програма, запущена в системі Linux, має три відкриті дескриптори файлів: *stdin* **(0)**, *stdout* **(1)** та *stderr* **(2)**. Ви можете перенаправляти або «*передавати*» їх окремо. Символами перенаправлення є ++більше++ та ++менше++.

#### Як використовувати перенаправлення

1. Переконайтеся, що ви все ще перебуваєте в каталозі `folder1`.

2. Ви будете використовувати перенаправлення виводу, щоб перенаправити вивід команди `ls` (*list*) у текстовий файл під назвою *myredirects*:

    ```bash
    [root@localhost folder1]# ls > myredirects
    ```

3. Перегляньте вміст нового файлу (*myredirects*), створеного в каталозі `folder1`.

    ```bash
    [root@localhost folder1] # cat myredirects
    temp_file11  temp_file12  temp_file21  temp_file22 myredirects
    ```

4. Тепер ви перенаправите вихід команди file у той самий файл. Ви хочете дізнатися тип файлу *temp_file11* у каталозі `folder1` і надіслати результат у файл *myredirects*:

    ```bash
    [root@localhost folder1]# file temp_file11 > myredirects
    ```

5. Перегляньте вміст файлу myredirects.

    !!! question "Питання"
   
        Воно змінилося. Що сталося?

6. Якщо ви хочете запобігти тому, що сталося вище, ви будете використовувати подвійний символ перенаправлення ++«>»+«>»++. Це додасть (*add*) новий вивід до файлу, замість того, щоб замінювати його. Впишіть:

    ```bash
    [root@localhost folder1]# ls >> myredirects
    ```

7. Тепер знову перегляньте вміст файлу *myredirects* за допомогою команди `cat`.

    !!! Question "Питання"
   
        Запишіть його зміст тут:

#### Використання перенаправлення для придушення виводу команди

Ви будете часто використовувати концепції, розглянуті тут, у Linux, тому, будь ласка, зверніть на це особливу увагу. Це може бути трохи складно.

Будуть випадки, коли ви не хочете, щоб користувач бачив результат виконання команди - наприклад, повідомлення про помилку. Зазвичай це відбувається тому, що дивні повідомлення про помилки часто лякають звичайних користувачів. У цьому вправі ви будете надсилати вихідні дані ваших команд на *нульовий пристрій* ( `/dev/null/` ). Пристрій *null* схожий на «*bit bucket*». Все, що ви кладете всередину, зникає назавжди. Ви також можете надсилати (або перенаправляти) звичайний вивід команди на *нульовий пристрій*.

Використовуйте наведені нижче вказівки:

| Перенаправлення | Функція                                                           |
| --------------- | ----------------------------------------------------------------- |
| > file          | Направляє стандартний вивід у файл                                |
| < file          | Приймає стандартний вхід з файлу                                  |
| Cmd1 \         | cmd2 | Pipe; бере стандартний вивід cmd1 як стандартний ввід cmd2 |
| n> file         | Направляє файловий дескриптор n до файлу                          |
| N< file         | Встановлює файл як файловий дескриптор n                          |
| >&n             | Дублює стандартний вивід у файловий дескриптор n                  |
| <&n             | Дублює стандартний ввід з файлового дескриптора n                 |
| &>file          | Направляє стандартний вивід і стандартну помилку у файл           |

1. Переконайтеся, що ви все ще перебуваєте в каталозі `folder1`. Використовуйте опцію довгого переліку команди `ls` для *temp_file11*:

    ```bash
    [root@localhost folder1]# ls –l temp_file11
    -rw-r--r-- 1 root   root    0   Jul 26 18:26    temp_file11
    ```

2. Ви перенаправите вихідні дані тієї ж команди, що наведена вище (`ls –l  temp_file11`), на нульовий пристрій.

    ```bash
    [root@localhost folder1]# ls –l temp_file11 > /dev/null
    ```

    У вас не повинно бути результату.

3. Тепер, якщо ви випадково неправильно ввели назву файлу, інформацію про який ви хочете переглянути; Ви отримаєте:

    ```bash
    [root@localhost folder1]# ls –l te_file1
    ls: te_file1: No such file or directory
    ```

    Наведене вище є результатом типу помилки, яку було запрограмовано видати командою `ls`.

4. Виконайте ту саму команду, що й вище, з неправильним написанням імені файлу та перенаправте її до `/dev/null`

    ```bash
    [root@localhost folder1]# ls -l te_file1 > /dev/null
    ls: te_file1: No such file or directory
    ```

    !!! Question "Питання"

     Що тут сталося? Чому вихідні дані все ще з’являються на екрані (*stdout*)?

5. З різних причин ви можете придушити такі повідомлення про помилки, як наведене вище. Щоб зробити це, впишіть:

    ```bash
    [root@localhost folder1]# ls –l te_file1 > /dev/null 2>&1
    ```

    Ви не отримаєте результату. Цього разу стандартний вихід, а також стандартна помилка пригнічуються.

    Порядок перенаправлення ВАЖЛИВИЙ!!

    Переспрямування читається зліва направо в командному рядку. Найлівіша частина символу перенаправлення - ++greater++ - надсилає стандартний вивід (*stdout*) до `/dev/null`. Тоді права частина перенаправлення - `2>&1` буде дублювати стандартну помилку **(2)** до стандартного виводу **(1)**.

    Отже, вищезазначену команду можна прочитати так: *перенаправити stdout(1) до «/dev/null», а потім скопіювати stderr (2) до stdout*

6. Щоб додатково продемонструвати важливість порядку перенаправлення. Спробуйте:

    ```bash
    [root@localhost folder1]# ls –l tem_file 2>&1 > order.txt
    ```

    Використовуйте команду `cat`, щоб перевірити вміст файлу “*order.txt*”

    Крайня ліва частина – `2>&1` скопіює стандартну помилку до стандартного виводу. Потім крайня права частина вищезазначеного – `> order.txt` перенаправляє *stdout* до файлу *order.txt*.

7. Спробуйте цей варіант описаного вище кроку:

    ```bash
    [root@localhost folder1]# ls –l hgh_ghz 2> order2.txt > order2.txt
    ```

    !!! question "Питання"

     Перегляньте файл “order2.txt” і поясніть, що сталося?

8. Щоб надіслати стандартний вивід і стандартну помилку в окремі файли, впишіть:

    ```bash
    [root@localhost folder1]# ls –l tep_f > standard_out 2> standard_err
    ```

    !!! question "Питання"

     Було створено два нових файли. Як називаються файли і який їх вміст?

9. Ви можете аналогічно перенаправити як *stdout*, так і *stderr* в один і той же файл, використовуючи:

    ```bash
    [root@localhost folder1]# ls –l te_fil &> standard_both
    ```

### 12. Видалення файлів за допомогою `rm`

Команда `rm` (Remove) дозволяє назавжди видалити один або кілька файлів, каталогів та їх вміст без можливості відновлення, якщо не використовувати зовнішні засоби відновлення. Це потужна команда, але вона може бути небезпечною, якщо її використовувати неправильно, оскільки її дії не можна скасувати. З цієї причини важливо використовувати його з обережністю, завжди перевіряючи шляхи та імена файлів перед виконанням операції. Ви будете використовувати `rm` для видалення деяких файлів, які ви створили в попередніх вправах.

#### Як використовувати `rm`

1. Перебуваючи в каталозі `folder1`, видаліть файл *standard_err*. Введіть ++«y»++ у вікні підтвердження:

    ```bash
    [root@localhost folder1]# rm standard_err
    rm: remove `standard_err'? y
    ```

2. Видаліть файл *standard_out*. Щоб уникнути запиту на підтвердження перед видаленням файлу, використовуйте опцію `–f` разом із командою `rm`:

    ```bash
    [root@localhost folder1]# rm -f standard_out
    ```

3. Поверніться до свого домашнього каталогу (`/root`) і видаліть каталог `folder2`. Щоб видалити папку за допомогою команди `rm`, потрібно використовувати параметр `–r`:

    ```bash
    [root@localhost root]# rm -r folder2
    rm: descend into directory 'folder2'? y
    rm: remove 'folder2/temp_file21'? y
    rm: remove 'folder2/temp_file22'? y
    rm: remove directory 'folder2'? y
    ```

    !!! Question "Питання"

     Вам знову було запропоновано підтвердити видалення кожного файлу в каталозі та самого каталогу.  Яку опцію ви використаєте з командою `rm –r`, щоб запобігти цьому?

### 13. Вивчення `vi`

Редактор `vi` є одним з найпотужніших і найпоширеніших текстових редакторів, доступних в системах Linux і Unix-подібних системах. Це незамінний інструмент для системних адміністраторів та розробників завдяки своїй ефективності та універсальності. На відміну від багатьох сучасних редакторів, `vi` працює переважно в текстовому режимі, пропонуючи швидкі команди та комбінації клавіш, які дозволяють редагувати файли з надзвичайною точністю та швидкістю.

Спочатку його освоєння може бути складним, але після того, як ви опануєте основні функції, він стане незамінним інструментом для редагування конфігураційних файлів, скриптів і вихідного коду безпосередньо з терміналу.

`vi` - це великий товстий монстр, який може робити майже все, включаючи приготування кави чи какао!!

Замість того, щоб намагатися навчити вас `vi`, ця вправа вкаже вам на інструмент, який може краще ознайомити вас з `vi`. Будь ласка, знайдіть час, щоб ознайомитися з онлайн-підручником `vi` (точніше `vim`). Просто дотримуйтесь інструкцій.

#### Для вивчення `vi`

1. Увійшовши в систему, введіть:

    [root@localhost root]# vimtutor

### 14. Пошук файлів за допомогою `find` та `locate`

У цій вправі буде розглянуто дві найпопулярніші утиліти, які використовуються для пошуку файлів і каталогів у файловій системі. Це команди `find` і `locate`.

#### `find`

Команда `find` дозволяє шукати файли та каталоги у файловій системі за широким спектром критеріїв, таких як ім'я, тип, розмір, дата модифікації, права доступу та багато іншого. Його здатність виконувати дії над знайденими результатами, такі як видалення, переміщення або обробка файлів, робить його незамінним інструментом для системних адміністраторів та досвідчених користувачів.

Загальний синтаксис `find` має вигляд:

```bash
find   [path]    [options]   [criterion]    [action]
```

Якщо ви не вказали жодного каталогу або шляху, `find` буде шукати в поточному каталозі. Якщо ви не вкажете критерій, це буде еквівалентно «*true*», отже, будуть знайдені всі файли. Утиліта `find` має багато параметрів для будь-якого типу пошуку файлу. Нижче наведено лише деякі параметри, критерії та дії.

| Параметр              | Опис                                                                                                                                                           |
| --------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| -xdev                 | не здійснює пошук у каталогах, розташованих в інших файлових системах                                                                                          |
| -mindepth `<n>` | спускається щонайменше на `<n>` рівнів нижче вказаного каталогу перед пошуком файлів                                                                     |
| -maxdepth `<n>` | шукає файли, розташовані на рівні не більше `<n>` нижче вказаного каталогу                                                                               |
| -follow               | слідує за символічними посиланнями, якщо вони ведуть до каталогів                                                                                              |
| -daystart             | при використанні тестів, пов'язаних з часом (див. нижче), бере початок поточного дня як мітку часу замість стандартного значення (24 години до поточного часу) |

| Критерій                                                      | Опис                                                                                                                                                                                                                                                                                                                              |
| ------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| -type `<type>`                                          | пошук певного типу файлів; `<type>` може бути одним з наступних: **f** (*звичайний файл*), **d** (*каталог*) **l** (*символічне посилання*), **s** (*сокет*), **b** (*файл у блоковому режимі*), **c** (*файл у символьному режимі*) або **p** (*іменований канал*)                                                         |
| -name `<pattern>`                                       | знаходить файли, імена яких відповідають заданим `<pattern>`                                                                                                                                                                                                                                                                |
| -iname `<pattern>`                                      | як *-name*, але ігнорує регістр                                                                                                                                                                                                                                                                                                   |
| -atime `<n>`, -amin `<n>`                         | знаходить файли, до яких востаннє зверталися `<n>` днів тому (*-atime*) або `<n>` хвилин тому (*-amin*). Ви також можете вказати `+<n>` або `-<n>`, у цьому випадку пошук буде здійснюватися для файлів, до яких було здійснено доступ відповідно *найбільше* або *найменше* `<n>` днів/хвилин тому |
| -anewer `<file>`                                        | знаходить файли, до яких було здійснено доступ пізніше, ніж до файлу `<file>`                                                                                                                                                                                                                                               |
| -ctime `<n>`, -cmin `<n>`, -cnewer `<file>` | так само, як для *-atime*, *-amin* та *-anewer*, але застосовується до останнього часу, коли вміст файлу було змінено                                                                                                                                                                                                             |
| -regex `<pattern>`                                      | те саме, що й *-name*, але шаблон розглядається як регулярний вираз                                                                                                                                                                                                                                                               |
| -iregex `<pattern>`                                     | те саме, що *-regex*, але ігнорує регістр                                                                                                                                                                                                                                                                                         |

| Дія                     | Опис                                                                                                                                                                                                                                            |
| ----------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| -print                  | просто виводить назву кожного файлу на стандартний вивід. Це стандартна дія                                                                                                                                                                     |
| -ls                     | виводить на стандартний вивід еквівалент `ls -ilds` для кожного знайденого файлу                                                                                                                                                                |
| -exec `<command>` | виконує команду `<command>` для кожного знайденого файлу. Командний рядок `<command>` повинен закінчуватися символом `;`, який необхідно екранувати, щоб оболонка не інтерпретувала його; позиція файлу позначається символами `{}` |
| -ok `<command>`   | те саме, що *-exec*, але запитує підтвердження для кожної команди                                                                                                                                                                               |

#### Як використовувати `find`

1. Переконайтеся, що ви перебуваєте у своєму домашньому каталозі.

2. Ви використаєте find для відображення всіх файлів у вашому поточному каталозі (`pwd`). Впишіть:

    ```bash
    [root@localhost root]# find
    ………..
    ./.bash_profile
    ./.bashrc
    ./.cshrc
    ./.tcshrc
    ./.viminfo
    ./folder1
    ./folder1/first.txt
    …………
    ```

    Ваш результат показує стандартну поведінку команди find при використанні без будь-яких опцій.  
Вона відображає всі файли та каталоги (*включно з прихованими файлами*) у робочому каталозі рекурсивно.

3. Тепер використовуйте `find`, щоб знайти лише каталоги у вашому *pwd*. Впишіть:

    ```bash
    [root@localhost root]# find -type d
    ./folder1
    ./folder2
    ………
    ```

    !!! question "Питання"

     З наведеної вище команди `find –type d`; що таке “*option*”, що таке “*path*”, що таке “*criterion*” і, нарешті, що таке “*action*?

4. Далі ви шукатимете всі файли у вашій системі, які закінчуються суфіксом “*.txt*”:

    ```bash
    [root@localhost root]# find / -maxdepth 3 -name "*.txt" -print
    /root/folder1/first.txt
    /root/folder1/second.txt
    /root/folder1/order.txt
    /root/folder1/order2.txt
    ```

    !!! question "Питання"

     Знову з наведеної вище команди; що таке “*option*”, “*path*”, “*criterion*” and “*action*”? (ПІДКАЗКА: дія = “- print”)

    Пошук буде виконуватися тільки в 3 каталогах, розташованих глибше каталогу `/`. Зірочка, використана у вищезазначеній команді, є одним із символів «*wild card*» в Linux.  
Використання символів wild-card в Linux називається «*globbing*».

5. Використовуйте команду `find`, щоб знайти всі файли у вашому “*pwd*”, які мають розмір “менший” за 200 кілобайт. Впишіть:

    ```bash
    [root@localhost root]# find . –size    -200k
    ```

6. Використовуйте команду `find`, щоб знайти всі файли у вашому pwd, які «більші» за 10 кілобайт, а також відобразити їхній «тип файлу». Впишіть:

    ```bash
    [root@localhost root]#  find   . –size  +10k   –exec    file     "{ }"      ";"
    ```

#### `locate`

Команда `locate` дозволяє шукати файли та каталоги в системі. На відміну від інших команд, таких як `find`, які виконують пошук у реальному часі, `locate` базується на попередньо скомпільованій базі даних, що містить шляхи до всіх файлів у системі, забезпечуючи майже миттєві результати. Ця база даних зазвичай періодично оновлюється за допомогою команди `updatedb`, яка керується *завданням cron*. Завдяки своїй ефективності, `locate` особливо корисний для швидкого пошуку файлів або папок без необхідності вручну сканувати всю файлову систему.  
Однак важливо пам'ятати, що результати можуть бути не завжди актуальними, якщо база даних не була нещодавно синхронізована з поточним станом системи.

| Використання пошуку:                                                                    |
| --------------------------------------------------------------------------------------- |
| locate [-qi] [-d `<path>`] [--database=`<path>`] `<search string>`... |
| locate [-r `<regexp>`] [--regexp=`<regexp>`]                                |

| Використання бази даних:                                                                                                          |
| --------------------------------------------------------------------------------------------------------------------------------- |
| locate [-qv] [-o `<file>`] [--output=`<file>`]                                                                        |
| locate [-e `<dir1,dir2,...>`] [-f `<fs_type1,...>`] [-l `<level>`] [-c] [-U `<path>`] [-u] [`pattern...`] |

| Загальне використання:                |
| ------------------------------------- |
| locate \[-Vh\] \[--version\] [--help] |

#### Як використовувати `locate`

1. Перейдіть до каталогу folder1 і створіть порожні файли temp1, temp2 і temp3:

    ```bash
    [root@localhost root]# cd   folder1;   touch temp1   temp2    temp3
    [root@localhost folder1]#
    ```

    Крапка з комою (;), яка використовується у наведеній вище команді, дозволяє виконувати кілька команд в одному рядку!!

2. Використовуйте `locate` для пошуку всіх файлів у вашому pwd, які мають суфікс «temp»

    ```bash
    [root@localhost folder1]# locate  temp*
    /root/folder1/temp_file11
    /root/folder1/temp_file12
    /root/folder1/temp_file21
    /root/folder1/temp_file22
    ```

    Зауважте, що три файли, які ви створили на кроці 1, НЕ знайдено.

3. Ви примусово оновите базу даних за допомогою `updatedb`, щоб дозволити їй враховувати всі новостворені файли. Впишіть:

    ```bash
    [root@localhost folder1]# updatedb
    ```

4. Тепер спробуйте пошук знову. Впишіть:

    ```bash
    [root@localhost folder1]# locate    temp
    ```

    !!! Question "Питання"

     Що сталося цього разу?

5. Ви закінчили цю лабораторну роботу.
