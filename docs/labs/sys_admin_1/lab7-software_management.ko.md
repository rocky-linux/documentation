- - -
title: 소프트웨어 관리 및 설치(Lab 7) author: Wale Soyinka contributors: Steven Spencer tested on: 8.8 tags:
  - lab exercise
  - 소프트웨어 관리
- - -

# Lab 7:  소프트웨어 관리 및 설치

## 목표


이 실습을 완료한 후에는 다음을 수행할 수 있습니다.

- 정보를 위해 패키지 쿼리
- 바이너리 패키지에서 소프트웨어 설치
- 일부 기본 종속성 문제 해결
- 소스 코드에서 소프트웨어 컴파일 및 설치


이 실습을 완료하는 데 예상 소요 시간: 90분



## 바이너리 파일과 소스 파일

시스템에 현재 설치된 응용 프로그램은 몇 가지 요인에 의존합니다. 주요한 요인은 운영 체제 설치 중 선택된 소프트웨어 패키지 그룹에 의존합니다. 다른 요인은 시스템이 사용 중인 이후에 수행된 작업에 의존합니다.

시스템 관리자로서 루틴 업무 중 하나는 소프트웨어 관리입니다. 이는 일반적으로 다음을 포함합니다:

- 새로운 소프트웨어 설치
- 소프트웨어 제거
- 이미 설치된 소프트웨어 업데이트


Linux 기반 시스템에 소프트웨어를 설치하는 방법은 여러 가지가 있습니다. 소스에서 설치하거나 미리 컴파일된 바이너리에서 설치할 수 있습니다. 후자의 방법은 훨씬 더 간단하지만 맞춤 설정할 수 있는 기능은 적습니다. 미리 컴파일된 바이너리에서 설치할 때 대부분의 작업이 이미 완료된 상태입니다. 그래도 원하는 특정 소프트웨어의 이름과 위치를 알아야 합니다.

거의 모든 소프트웨어는 C 또는 "C++" 프로그래밍 언어 소스 파일로 제공됩니다. 소스 프로그램은 일반적으로 소스 파일의 아카이브로 배포됩니다. 보통 tar 또는 gzip 또는 bzip2로 압축된 파일입니다. 즉, 압축되어 있는지 또는 단일 번들로 제공됩니다.

대부분의 개발자는 소스 코드를 GNU 표준에 맞게 작성하여 다른 사람과 공유하기 쉽게 만들었습니다. 또한 패키지가 모든 UNIX 또는 UNIX 유사 시스템 (예: Linux)에서 컴파일될 수 있음을 의미합니다.

RPM은 Rocky Linux, Fedora, Red Hat Enterprise Linux (RHEL), openSuSE, Mandrake 등과 같은 Red Hat 기반 배포판에서 응용 프로그램(패키지)을 관리하기 위한 기본 도구입니다.

Linux 배포판에서 소프트웨어를 관리하는 데 사용되는 응용 프로그램을 패키지 관리자라고 합니다. 예를 들면:

- 레드햇 패키지 관리자(`rpm`).  패키지는 " .rpm" 확장자를 가집니다.
- Debian 패키지 관리 시스템(`dpkg`).  패키지는 " .deb" 확장자를 가집니다.

RPM 명령에 대한 일부 인기 있는 명령행 옵션과 구문은 다음과 같습니다:

**rpm**

사용법 : rpm [OPTION...]

**패키지 쿼리**

```
쿼리 옵션 (-q 또는 --query와 함께 사용):

  -c, --configfiles                  모든 구성 파일 나열
  -d, --docfiles                     모든 문서 파일 나열
  -L, --licensefiles                 모든 라이선스 파일 나열
  -A, --artifactfiles                모든 아티팩트 파일 나열
      --dump                         기본 파일 정보 덤프
  -l, --list                         패키지 내의 파일 나열
      --queryformat=QUERYFORMAT      다음 쿼리 형식 사용
  -s, --state                        나열된 파일의 상태 표시
```

**패키지 확인**

```
확인 옵션 (-V 또는 --verify와 함께 사용):
      --nofiledigest                 파일 다이제스트를 확인하지 않음
      --nofiles                      패키지 내의 파일을 확인하지 않음
      --nodeps                       패키지 종속성을 확인하지 않음
      --noscript                     검증 스크립트 실행하지 않음

```

**패키지 설치, 업그레이드 및 제거**

```
설치/업그레이드/제거 옵션:
      --allfiles                     건너뛸 수 있는 구성을 포함하여 모든 파일을 설치 
  -e, --erase=<package>+             패키지 삭제
      --excludedocs                  문서 설치하지 않음
      --excludepath=<path>           경로 <path>로 시작하는 파일 건너뛰기
      --force                        --replacepkgs --replacefiles의 약어
  -F, --freshen=<packagefile>+       이미 설치된 경우 패키지 업그레이드
  -h, --hash                         패키지 설치 시 해시 마크 출력 (-v와 함께 사용)
      --noverify                     --ignorepayload --ignoresignature의 약어
  -i, --install                      패키지 설치
      --nodeps                       패키지 종속성 확인하지 않음
      --noscripts                    패키지 스크립트 실행하지 않음
      --percent                      패키지 설치 시 백분율 출력
      --prefix=<dir>                 패키지를 <dir>로 이동 (재배치 가능한 경우)
      --relocate=<old>=<new>         경로 <old>에서 <new>로 파일 이동
      --replacefiles                 패키지 간 파일 충돌 무시
      --replacepkgs                  패키지 이미 존재하는 경우 재설치
      --test                         설치하지 않고 동작 여부 확인
  -U, --upgrade=<packagefile>+       패키지 업그레이드
      --reinstall=<packagefile>+     패키지 재설치
```

## 연습문제 1

### 패키지 설치, 쿼리 및 제거

이 랩에서는 RPM 시스템의 사용 방법을 배우고 시스템에 샘플 애플리케이션을 설치합니다.

!!! !!!

    Rocky Linux 패키지를 얻을 수 있는 다양한 옵션이 있습니다. 신뢰할 수 있는 [또는 신뢰할 수 없는] 저장소에서 직접 다운로드할 수 있습니다. 배포 ISO에서 가져올 수도 있습니다. nfs, git, https, ftp, smb, cifs 등의 프로토콜을 사용하여 중앙 공유 위치에서 가져올 수도 있습니다. 궁금한 경우 다음 공식 웹 사이트를 보고 원하는 패키지에 해당하는 저장소를 탐색할 수 있습니다.
    
    https://download.rockylinux.org/pub/rocky/8.8/

#### 패키지 정보 조회하기

1.  시스템에 현재 설치된 모든 패키지 목록을 보려면 다음 명령을 입력합니다:
    ```
    $ rpm -qa
    python3-gobject-base-*
    NetworkManager-*
    rocky-repos-*
    ...<OUTPUT TRUNCATED>...
    ```
긴 목록이 표시됩니다.

2.  이제 좀 더 자세히 살펴보고자 시스템에 설치된 패키지 중 하나에 대해 자세히 알아보겠습니다. NetworkManager를 조사해 보겠습니다. `rpm` 명령과 --query (-q) 및 --info (-i) 옵션을 사용합니다. 다음을 입력하세요:
    ```
    $ rpm -qi NetworkManager
    Name        : NetworkManager
    Epoch       : 1
    ...<OUTPUT TRUNCATED>...
    ```
이것은 많은 정보(메타데이터)입니다!

3.  이전 명령에서 요약(summary) 필드만 표시하고 싶다고 가정해 보겠습니다. rpm의 쿼리 형식 옵션을 사용하여 쿼리 옵션으로부터 반환되는 정보를 필터링할 수 있습니다.

 예를 들어, 요약 필드만 보려면 다음과 같이 입력합니다:
    ```
    $ rpm -q --queryformat '%{summary}\n' NetworkManager
    ```

4. 설치된 NetworkManager 패키지의 버전과 요약 필드를 모두 보려면 다음과 같이 입력합니다:
    ```
    $ rpm -q --queryformat '%{version}  %{summary}\n' NetworkManager 
    ```


5.  시스템에 설치된 bash 패키지에 대한 정보를 보려면 해당 패키지에 대한 정보를 확인하는 명령을 입력하세요.

    !!! 참고사항 
   
        이전 연습에서는 이미 시스템에 설치된 패키지에 대한 조회 및 작업을 수행했습니다. 다음 연습에서는 아직 설치되지 않은 패키지를 사용하게 됩니다. 이후 단계에서 사용할 패키지를 다운로드하기 위해 DNF 애플리케이션을 사용할 것입니다.

6.  먼저 `wget` 애플리케이션이 이미 시스템에 설치되지 않았는지 확인합니다. 다음을 입력하세요:

    ```
    $ rpm -q wget
    package wget is not installed
    ```

    `wget`이 데모 시스템에 설치되지 않은 것 같습니다.

7. Rocky Linux 8.x부터 `dnf download` 명령을 사용하면 `wget`용 최신 `rpm` 패키지를 얻을 수 있습니다. 다음을 입력하세요:

    ```
    dnf download wget
    ```

8. `ls` 명령을 사용하여 패키지가 현재 디렉토리에 다운로드되었는지 확인합니다. 다음을 입력하세요:

    ```
    $ ls -lh wg*
    ```

9. `rpm` 명령을 사용하여 다운로드한 wget-*.rpm에 대한 정보를 조회합니다. 다음을 입력하세요:

    ```
    $ rpm -qip wget-*.rpm
    Name        : wget
    Architecture: x86_64
    Install Date: (not installed)
    Group       : Applications/Internet
    ...<TRUNCATED>...
    ```

10. 이전 단계에서의 출력을 기반으로 `wget` 패키지는 무엇인가요? 패키지를 다운로드할 때 설명 필드를 보려면 rpm 쿼리 형식 옵션을 사용할 수 있습니다.

11. `wget-*.rpm` 패키지에 포함된 파일을 확인하려면 다음과 같이 입력합니다:

    ```
    $ rpm -qlp wget-*.rpm | head
    /etc/wgetrc
    /usr/bin/wget
    ...<TRUNCATED>...
    /usr/share/doc/wget/AUTHORS
    /usr/share/doc/wget/COPYING
    /usr/share/doc/wget/MAILING-LIST
    /usr/share/doc/wget/NEWS
    ```

12. `wget` 패키지의 일부로 나열된 `/usr/share/doc/wget/AUTHORS` 파일의 내용을 보겠습니다. `cat` 명령을 사용합니다. 다음을 입력하세요:

    ```
    $ cat /usr/share/doc/wget/AUTHORS
    cat: /usr/share/doc/wget/AUTHORS: No such file or directory
    ```

    `wget`이 아직 (설치되지 않았으므로) 데모 시스템에 없습니다! 그래서 함께 제공되는 AUTHORS 파일을 볼 수 없습니다.

13. *이미* 시스템에 설치된 다른 패키지(curl)에 포함된 파일 목록을 보겠습니다. 다음을 입력하세요:

    ```
    $ rpm -ql curl
    /usr/bin/curl
    /usr/lib/.build-id
    /usr/lib/.build-id/fc
    ...<>...
    ```

    !!! !!!

     이전 명령에서 `curl` 패키지의 전체 이름을 참조할 필요가 없었습니다. 이는 `curl` 이 이미 설치되어 있기 때문입니다.

## 연습문제 2

### 패키지 무결성

1.  손상되거나 오염된 파일을 다운로드하거나 종료할 수 있습니다. 다운로드한 `wget` 패키지의 무결성을 확인할 수 있습니다. 다음을 입력하세요:

    ```
    $ rpm -K  wget-*.rpm
    wget-1.19.5-10.el8.x86_64.rpm: digests signatures OK
    ```

    출력된 "digests signatures OK" 메시지는 패키지가 정상임을 나타냅니다.

2.  우리는 악의적으로 다운로드한 패키지를 고의로 변경해 볼 것입니다. 원본 패키지에 어떤 것을 추가하거나 제거함으로써 이를 수행할 수 있습니다. 원래 패키지 제작자가 의도하지 않은 방식으로 패키지를 변경하는 것은 패키지를 손상시킬 것입니다. 우리는 echo 명령을 사용하여 "haha"라는 문자열을 패키지에 추가하여 파일을 변경할 것입니다. 다음 명령어를 입력하세요:

    ```
    $ echo haha >> wget-1.19.5-10.el8.x86_64.rpm 
    ```

3.  이제 rpm의 -K 옵션을 사용하여 패키지의 무결성을 다시 확인해 보세요. 유형:

    ```
    $ rpm -K  wget-*.rpm
    wget-1.19.5-10.el8.x86_64.rpm: DIGESTS SIGNATURES NOT OK
    ```

    매우 다른 메시지가 출력됩니다. "DIGESTS SIGNATURES NOT OK" 출력은 해당 패키지를 사용하거나 설치하지 말아야 함을 명확히 알려줍니다. 더 이상 신뢰할 수 없습니다.

4.  `rm` 명령을 사용하여 손상된 `wget` 패키지 파일을 삭제하고 `dnf`를 사용하여 새로운 복사본을 다운로드하세요. 다음을 입력하세요:

    ```
    $ rm wget-*.rpm  && dnf download wget
    ```
    새로 다운로드한 패키지가 RPM의 무결성 검사를 통과하는지 한 번 더 확인하세요.


## 연습문제 3

### 패키지 설치

시스템에 소프트웨어를 설치하려고 할 때 "의존성 실패" 문제가 발생할 수 있습니다. 특히 시스템에서 응용 프로그램을 수동으로 관리하는 저수준 RPM 도구를 사용할 때 이러한 문제가 흔히 발생합니다.

예를 들어, "abc.rpm" 패키지를 설치하려고 하면 RPM 설치 프로그램이 의존성 실패에 대해 에러를 표시할 수 있습니다. "abc.rpm" 패키지를 설치하려면 다른 패키지 "xyz.rpm"이 먼저 설치되어야 한다는 메시지가 나타날 수 있습니다. 응용 프로그램은 거의 항상 다른 소프트웨어나 라이브러리에 의존합니다. 시스템에 필요한 프로그램이나 공유 라이브러리가 이미 설치되어 있지 않은 경우, 해당 의존성을 해결하기 위해 필요한 사전 작업을 수행해야 합니다.


저수준 RPM 도구는 종종 애플리케이션 간의 종종 애플리케이션 간의 상호 의존성에 대해 알고 있습니다. 그러나 일반적으로 문제를 해결하기 위해 필요한 응용 프로그램이나 라이브러리를 어떻게 어디에서 가져와야 하는지 알지 못합니다. 달리 말하면 RPM은 *무엇*과 *어떻게*를 알고 있지만 *어디서* 질문에 답할 수 있는 기본 제공 기능이 없습니다. 이때 `dnf`, `yum` 등의 도구가 도움을 줄 수 있습니다.

#### 패키지 설치하기

이 연습에서는 `wget` 패키지(wget-*.rpm)를 설치해 보겠습니다.

1. `wget` 애플리케이션을 설치해 보세요. RPM의 -ivh 명령 줄 옵션을 사용합니다. 유형:

    ```
    $ rpm -ivh wget-*.rpm
    error: Failed dependencies:
        libmetalink.so.3()(64bit) is needed by wget-*
    ```

    의존성 문제가 발생했습니다! 위 예시 출력에서는 `wget`이 "libmetalink.so.3"이라는 라이브러리 파일이 필요하다고 알려줍니다.

    !!! 참고사항

     위 테스트의 출력에 따르면 wget-<em x-id="3">.rpm 패키지를 설치하려면 libmetalink-</em>.rpm 패키지가 설치되어야 합니다. 즉, libmetalink는 wget-<em x-id="3">.rpm 설치의 선행 조건입니다. "nodeps" 옵션을 사용하여 강제로 wget-</em>.rpm 패키지를 설치할 수도 있지만, 이는 일반적으로 권장되지 않는 방법입니다.

2. RPM은 누락된 부분에 대한 힌트를 유용하게 제공했습니다. rpm은 무엇과 방법을 알고 있지만 반드시 위치를 알 필요는 없다는 것을 기억할 것입니다. 따라서 `dnf` 도구를 사용하여 누락된 라이브러리를 제공하는 패키지 이름을 찾아보겠습니다. 다음을 입력하세요:

    ```
    $ dnf whatprovides libmetalink.so.3
    ...<TRUNCATED>...
    libmetalink-* : Metalink library written in C
    Repo        : baseos
    Matched from:
    Provide    : libmetalink.so.3
    ```

3. 출력에서 누락된 라이브러리를 제공하는 `libmetalink` 패키지를 다운로드해야 합니다. 특히 64비트 버전의 라이브러리가 필요합니다. 별도의 도구인 `dnf`를 호출하여 데모용 64비트(x86_64) 아키텍처에 맞는 패키지를 찾아 다운로드하도록 하겠습니다. 다음을 입력하세요:

    ```
    dnf download --arch x86_64  libmetalink
    ```

4. 이제 작업 디렉토리에 적어도 2개의 rpm 패키지가 있어야 합니다. `ls` 명령을 사용하여 확인하세요.

5. 누락된 `libmetalink` 종속성을 설치하세요. 다음을 입력하세요:

    ```
    $ sudo rpm -ivh libmetalink-*.rpm
    ```

6. 종속성이 설치되었으므로 이제 원래 목표인 `wget` 패키지를 설치할 수 있습니다. 다음을 입력하세요:

    ```
    $ sudo rpm -ivh wget-*.rpm
    ```

    !!! 참고사항

     RPM은 트랜잭션을 지원합니다. 이전 연습에서 원하는 패키지뿐만 아니라 해당 패키지가 의존하는 모든 패키지와 라이브러리를 포함하는 단일 RPM 트랜잭션을 수행할 수 있었습니다. 아래와 같은 단일 명령으로 충분합니다:
            ```
            $  rpm -Uvh  wget-*.rpm  libmetalink-*.rpm
            ```

7. 이제 진실의 순간입니다. `wget` 프로그램을 옵션 없이 실행하여 설치되었는지 확인해 보세요. 다음을 입력하세요:

    ```
    $ wget
    ```

8. 작동 중인 `wget`을 살펴보겠습니다. `wget`을 사용하여 커맨드 라인에서 인터넷에서 파일을 다운로드해 보겠습니다. 다음을 입력하세요:

    ```
    wget  https://kernel.org
    ```

    이렇게 하면 kernel.org 웹사이트의 기본 index.html 파일이 다운로드됩니다!

9. `wget` 애플리케이션에 포함된 모든 파일 목록을 확인하기 위해 `rpm`을 사용하세요.

10. `wget` 패키지에 포함된 문서를 확인하기 위해 `rpm`을 사용하세요.

11. `wget` 패키지에 설치된 모든 실행 파일 목록을 확인하기 위해 `rpm`을 사용하세요.

12. `wget`을 설치하기 위해 `libmetalink` 패키지를 설치해야 했습니다. 이제 명령줄에서 `libmetalink`을 실행해 보세요. 다음 명령어를 입력하세요:

    ```
    $ libmetalink
    -bash: libmetalink: command not found
    ```

    !!! 주목

     무엇이 제공됩니까? 왜 `libmetalink`을 실행할 수 없을까요?


#### rpm을 통해 공개 키 가져오기

!!! 팁 

    Rocky Linux 프로젝트에서 패키지 서명에 사용되는 GPG 키는 프로젝트 웹사이트, FTP 사이트, 배포 미디어, 로컬 소스 등 다양한 소스에서 얻을 수 있습니다. RL 시스템의 키링에 적절한 키가 누락된 경우, 로컬 RL 시스템으로부터 Rocky Linux의 공개 키를 가져오기 위해 `rpm`의 `--import` 옵션을 사용할 수 있습니다. 다음과 같이 실행하세요: `sudo rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-rockyofficial`

!!! note "질문:"

    패키지를 설치할 때 `rpm -Uvh`와 `rpm -ivh`의 차이점은 무엇인가요? 
    `rpm`의 매뉴얼 페이지를 참조하세요.

## 연습문제 4

### 패키지 제거

패키지를 제거하는 것은 설치하는 것과 마찬가지로 Red Hat의 패키지 관리자(RPM)를 사용하여 쉽게 할 수 있습니다.

이 연습에서는 `rpm`을 사용하여 시스템에서 몇 가지 패키지를 제거해 보겠습니다.

#### 패키지 제거하기

1. 시스템에서 `libmetalink` 패키지를 제거하세요. 다음 명령어를 입력하세요:

    ```
    $ sudo rpm -e libmetalink
    ```

    !!! note "질문:"

     패키지를 제거할 수 없는 이유를 설명하세요.


2.  RPM을 사용하여 패키지를 제거하는 정확하고 올바른 방법은 해당 패키지와 종속성을 함께 제거하는 것입니다. `libmetalink` 패키지를 제거하려면 이에 의존하는 `wget` 패키지도 제거해야 합니다. 다음 명령어를 입력하세요:

    ```
    $ sudo rpm -e libmetalink wget
    ```

    !!! 참고사항

     <code>libmetalink에 의존하는 패키지를 깨뜨리고 시스템에서 강제로 패키지를 제거하려면 rpm의 --nodeps 옵션을 다음과 같이 사용할 수 있습니다 - 
      $ sudo rpm  -e  --nodeps  libmetalink 즉, 모든 종속성을 무시합니다.  
     **ii.** 위의 내용은 시스템에서 패키지를 강제로 제거하는 방법을 보여주기 위한 것입니다. 이것이 필요한 경우가 있을 수 있지만 일반적으로 *좋은 습관은 아닙니다*.  
     이렇게 하는 경우가 있을 수 있지만, *좋은 관행은 아닙니다*.  
    **iii.** 다른 설치된 패키지인 "abc"가 의존하는 패키지 "xyz"를 강제로 제거하면 패키지 "abc"를 사용할 수 없거나 어느 정도 손상될 수 있습니다.  
    </code>

## 연습문제 5

### DNF - 패키지 관리자

DNF는 RPM 기반 Linux 배포판을 위한 패키지 관리자입니다. 이는 인기 있는 YUM 유틸리티의 후속 제품입니다. DNF는 YUM과의 호환성을 유지하며 두 유틸리티는 매우 유사한 명령줄 옵션과 구문을 공유합니다.

DNF는 Rocky Linux와 같은 RPM 기반 시스템에서 소프트웨어를 관리하는 많은 도구 중 하나입니다. `rpm`과 비교하여 이러한 상위 도구들은 패키지의 설치, 제거, 조회를 단순화하는 데 도움을 줍니다. 이러한 도구는 RPM 시스템이 제공하는 기본 프레임워크를 사용합니다. 그래서 먼저 RPM을 사용하는 방법을 이해하는 것이 유용합니다.

DNF(그리고 이와 유사한 도구)는 RPM을 감싸는 래퍼(wrapper) 역할을 하며, RPM이 제공하지 않는 추가 기능을 제공합니다. DNF는 패키지 및 라이브러리 종속성을 처리하는 방법을 알고 있으며, 구성된 저장소를 자동으로 활용하여 대부분의 문제를 해결할 수 있습니다.

`dnf` 유틸리티와 함께 자주 사용되는 옵션은 다음과 같습니다:

```
    사용법: dnf [options] COMMAND

    주요 명령어 목록:

    alias                     명령 별칭을 나열하거나 생성합니다. autoremove                원래 종속성으로 설치된 모든 불필요한 패키지를 제거합니다. check                     패키지 데이터베이스에 문제가 있는지 확인합니다. check-update              사용 가능한 패키지 업그레이드를 확인합니다. clean                     캐시된 데이터를 제거합니다. deplist                   [사용되지 않음, repoquery --deplist 사용] 패키지의 종속성과 해당 패키지를 제공하는 패키지를 나열합니다. distro-sync               설치된 패키지를 최신 버전으로 동기화합니다. downgrade                 패키지를 다운그레이드합니다. group                     그룹 정보를 표시하거나 사용합니다. help                      도움말 메시지를 표시합니다.
    module                    모듈과 상호작용합니다.
    repoquery                 키워드와 일치하는 패키지를 검색합니다. repository-packages       지정된 저장소의 모든 패키지에 대해 명령을 실행합니다. search                    지정된 문자열에 대한 패키지 세부 정보를 검색합니다. shell                     대화형 DNF 쉘을 실행합니다. swap                      제거 및 하나의 스펙을 설치하기 위한 대화형 DNF 모드를 실행합니다. updateinfo                패키지에 대한 알림을 표시합니다. upgrade                   시스템에 설치된 패키지 또는 패키지를 업그레이드합니다. upgrade-minimal           시스템에 영향을 주는 문제를 해결하는 '최신' 패키지만 업그레이드합니다.

```

#### `dnf`를 사용하여 패키지 설치하기

이전 연습에서 `wget` 유틸리티를 제거한 상태라고 가정하고, 다음 단계에서 dnf를 사용하여 패키지를 설치해 보겠습니다. `rpm`을 사용하여 `wget`를 설치할 때 필요한 2-3 단계 과정을 `dnf`를 사용하면 1 단계로 단순화할 수 있습니다. `dnf`가 종속성을 자동으로 해결해 줄 것입니다.

1.  먼저, 시스템에서 `wget`과 `libmetalink`가 제거되었는지 확인해 보세요. 다음 명령어를 입력하세요:

    ```
    $ sudo rpm -e wget libmetalink
    ```

    제거한 후에 CLI에서 `wget`을 실행하면 *wget: command not found*와 같은 메시지가 표시됩니다.

2. 이제 dnf를 사용하여 `wget`을 설치해 보겠습니다. 다음 명령어를 입력하세요:

    ```
    $ sudo dnf -y install wget
    Dependencies resolved.
    ...<TRUNCATED>...
    Installed:
    libmetalink-*           wget-*
    Complete!
    ```

    !!! !!!

     위의 명령에서 사용된 "-y" 옵션은 `dnf`가 수행할 작업을 확인하기 위한 "[y/N]" 프롬프트를 억제합니다. 대신, 자동으로 "yes" (y)로 가정합니다.


3. DNF는 "환경 그룹" 옵션을 제공하여 시스템에 새로운 기능 세트를 추가하는 것을 간편하게 할 수 있습니다. 해당 기능을 추가하려면 일반적으로 몇 가지 패키지를 개별적으로 설치해야 할 수도 있지만, `dnf`를 사용하면 원하는 기능의 이름이나 설명만 알고 있으면 됩니다. `dnf`를 사용하여 사용 가능한 모든 그룹을 나열해 보세요. 다음을 입력하세요:

    ```
    $ dnf group list
    ```

4. "Development Tools" 그룹/기능에 관심이 있습니다. 그룹에 대해 자세한 정보를 얻어보겠습니다. 다음을 입력하세요:

    ```
   $ dnf group info "Development Tools"
   ```

5. 나중에 "Development Tools" 그룹에 포함된 몇 가지 프로그램이 필요할 것입니다. 다음을 실행하여 "Development Tools" 그룹을 `dnf`를 사용하여 설치해 보세요:

    ```
    $ sudo dnf -y group install "Development Tools"
    ```

#### `dnf`를 사용하여 패키지 제거하기


1.  `dnf`를 사용하여 `wget` 패키지를 제거하려면 다음을 입력하세요:

    ```
    $ sudo dnf -y remove wget
    ```

2. `dnf`를 사용하여 패키지가 시스템에서 제거되었는지 확인해 보세요. 다음 명령어를 입력하세요:

    ```
    $ sudo dnf -y remove wget
    ```

3. `wget`을 사용해 보세요. 다음 명령어를 입력하세요:

    ```
    $ wget
    ```

#### `dnf`를 사용하여 패키지 업데이트하기

DNF를 사용하여 저장소에서 사용 가능한 최신 버전의 개별 패키지를 확인하고 설치할 수 있습니다. 또한 특정 버전의 패키지를 설치하는 데에도 사용할 수 있습니다.

1. `dnf`와 함께 리스트 옵션을 사용하여 시스템에서 사용 가능한 `wget` 프로그램의 모든 버전을 확인해 보세요. 다음 명령어를 입력하세요:

    ```
    $ dnf list wget
    ```

2. 패키지의 업데이트된 버전이 있는지 확인하려면 `dnf`와 함께 check-update 옵션을 사용하세요. 예를 들어, `wget` 패키지의 경우 다음과 같이 입력하세요:

    ```
    $ dnf check-update wget
    ```

4. 시스템의 커널 패키지에 대해 사용 가능한 모든 버전을 나열해 보세요. 다음을 입력하세요:

    ```
    $ sudo dnf list kernel
    ```

5. 설치된 커널 패키지에 대해 업데이트된 패키지가 있는지 확인하려면 다음을 입력하세요: 다음을 입력하세요:

    ```
    $ dnf  check-update kernel
    ```

6. 패키지 업데이트는 버그 수정, 새 기능 또는 보안 패치 때문일 수 있습니다. 커널 패키지에 대한 보안 관련 업데이트가 있는지 보려면 다음을 입력합니다:

    ```
    $ dnf  --security check-update kernel
    ```

#### `dnf` 사용하여 저장소 관리하기

DNF를 사용하여 시스템에 설치된 모든 패키지의 최신 버전을 확인하고 설치할 수 있습니다. 업데이트 설치를 주기적으로 확인하는 것은 시스템 관리의 중요한 측면입니다.

1. 현재 시스템에 설치한 패키지에 대한 업데이트가 있는지 확인하려면 다음을 입력하십시오.

    ```
    $ dnf check-update
    ```

2. 시스템에 설치된 모든 패키지에 대한 보안 관련 업데이트가 있는지 확인하려면 다음을 입력하십시오.

    ```
    $ dnf --security check-update
    ```

3. 시스템에 설치된 전체 패키지를 배포 실행에 사용할 수 있는 최신 버전으로 업데이트하려면 다음을 수행하십시오.

    ```
    $ dnf -y check-update
    ```

## 연습문제 6

### 소스 코드로부터 소프트웨어 빌드하기

모든 소프트웨어/응용 프로그램/패키지는 일반적으로 사람이 읽을 수 있는 일반 텍스트 파일인 소스 코드에서 유래됩니다. 파일을 집합적으로 소스 코드라고 합니다. 리눅스 배포판에 설치된 RPM 패키지는 소스 코드로부터 생성됩니다.

이 연습에서는 원본 소스 파일로부터 샘플 프로그램을 다운로드하고 컴파일하고 설치할 것입니다. 편의를 위해 소스 파일은 일반적으로 tar-볼(tarball)이라고 불리는 하나의 압축 파일로 배포됩니다.

다음 연습은 오래된 Hello 프로젝트 소스 코드를 기반으로 합니다. hello는 C++로 작성된 간단한 명령줄 응용 프로그램으로, 단순히 터미널에 `hello`를 출력하는 역할을 합니다. [여기서 프로젝트에 대해 더 알아보세요.](http://www.gnu.org/software/hello/hello.html)

#### 소스 파일 다운로드하기

1.  `curl`을 사용하여 `hello` 애플리케이션의 최신 소스 코드를 다운로드하세요. 파일을 다운로드하고 Downloads 폴더에 저장합니다.

https://ftp.gnu.org/gnu/hello/hello-2.12.tar.gz

#### 파일을 압축 해제하려면

1. 로컬 머신에서 hello 소스 코드를 다운로드한 디렉터리로 이동하세요.

2. `tar` 프로그램을 사용하여 tarball을 압축 해제하세요. 다음을 입력하세요:

    ```
    $ tar -xvzf hello-2.12.tar.gz
    hello-2.12/
    hello-2.12/NEWS
    hello-2.12/AUTHORS
    hello-2.12/hello.1
    hello-2.12/THANKS
    ...<TRUNCATED>...
    ```

4. `ls` 명령을 사용하여 현재 디렉터리의 내용을 확인하세요.

    압축 해제 중에 hello-2.12라는 새로운 디렉터리가 생성되었어야 합니다.

5. 해당 디렉터리로 이동하고 내용을 나열하세요. 다음 명령어를 입력하세요:

    ```
    $ cd hello-2.12 ; ls
    ```

6. 일반적으로 소스 코드와 함께 제공되는 특수 설치 지침을 검토하는 것이 좋습니다. 이러한 파일들은 주로 INSTALL, README 등의 이름을 가지고 있습니다.

    페이저(pager)를 사용하여 INSTALL 파일을 열어서 내용을 읽어보세요. 다음을 입력하세요:
    ```
    $ less INSTALL
    ```

    파일 검토가 완료되면 페이저를 종료하세요.

#### 패키지 구성하기

대부분의 응용 프로그램은 사용자가 활성화 또는 비활성화할 수 있는 기능을 가지고 있습니다. 이는 소스 코드에 액세스하고 해당 소스 코드를 통해 설치할 수 있는 장점 중 하나입니다. 응용 프로그램이 가지고 있는 설정 가능한 기능을 제어할 수 있습니다. 이는 미리 컴파일된 이진 파일로부터 패키지 매니저가 설치하는 모든 것을 받아들이는 것과 대조적입니다.

일반적으로 소프트웨어를 구성할 수 있는 스크립트는 "configure"라는 이름으로 알맞게 지정됩니다.

1.  `ls` 명령을 다시 사용하여 현재 작업 디렉토리(pwd)에 *configure*라는 파일이 있는지 확인하세요.

2.  `hello` 프로그램에서 활성화하거나 비활성화할 수 있는 모든 옵션을 보려면 다음을 입력하세요:

    ```
    $ ./configure --help
    ```

    !!! note "질문:"

     명령의 출력에서 "--prefix" 옵션은 무엇을 합니까?

3. 구성 스크립트가 제공하는 기본 옵션에 만족한다면 다음을 입력하세요: 다음을 입력하세요:

    ```
    $ ./configure
    ```

    !!! 참고사항

     구성 단계가 원활하게 진행되었기를 바랍니다. 이제 컴파일 단계로 넘어갈 수 있어야 합니다.

    구성 단계에서 오류가 발생한 경우, 오류의 원인을 확인하기 위해 출력의 뒷부분을 주의 깊게 살펴보아야 합니다. 오류는 *때때로* 자명하고 수정하기 쉽습니다. 예를 들어, 다음과 같은 오류가 발생할 수 있습니다:

    configure: error: no acceptable C compiler found in $PATH

    위의 오류는 시스템에 C 컴파일러(gcc 등)가 설치되어 있지 않거나, 컴파일러가 PATH 변수에 포함되어 있지 않은 경우를 의미합니다.

#### 패키지 컴파일하기

다음 단계에서는 hello 응용 프로그램을 빌드합니다. 앞에서 DNF를 사용하여 이전에 설치한 개발 도구 그룹에 포함된 일부 프로그램이 유용하게 사용됩니다.

1.  "configure" 스크립트를 실행한 후에 make 명령을 사용하여 패키지를 컴파일하세요. 다음을 입력하세요:

    ```
    $ make
    ...<OUTPUT TRUNCATED>...
    gcc  -g -O2   -o hello src/hello.o  ./lib/libhello.a
    make[2]: Leaving directory '/home/rocky/hello-2.12'
    make[1]: Leaving directory '/home/rocky/hello-2.12'
    ```

    잘 진행된다면 중요한 `make` 단계에서 최종 `hello` 응용 프로그램 이진 파일이 생성될 것입니다.

2. 현재 작업 디렉토리의 파일 목록을 다시 확인하세요. `hello` 프로그램을 포함하여 새로 생성된 파일이 보여야 합니다.

#### 응용 프로그램 설치하기

최종 설치 단계에는 응용 프로그램 바이너리와 라이브러리를 올바른 폴더로 복사하는 등의 작업이 포함됩니다.

1. hello 응용 프로그램을 설치하려면 make install 명령을 실행하세요. 다음 명령어를 입력하세요:

    ```
    $ sudo make install
    ```
    이 명령은 "configure" 스크립트와 함께 사용된 기본 프리픽스(--prefix) 인자로 지정된 위치에 패키지를 설치합니다. --prefix가 설정되지 않은 경우 기본 프리픽스인 `/usr/local/`이 사용됩니다.

#### hello 프로그램 실행하기

1. `whereis` 명령을 사용하여 시스템에서 `hello` 프로그램이 있는 위치를 확인하세요. 다음 명령어를 입력하세요:
    ```
    $ whereis hello
    ```

2. `hello` 응용 프로그램을 실행하여 어떤 일이 발생하는지 확인해보세요. 다음을 입력하세요:
    ```
   $ hello
   ```

3. `hello`를 다시 실행하고 `--help` 옵션을 사용하여 할 수 있는 다른 작업을 확인하세요.

4. `sudo`를 사용하여 슈퍼유저로 `hello`를 다시 실행하세요. 다음을 입력하세요:
    ```
    $ sudo hello
    ```

    !!! !!!

     일반 사용자도 프로그램을 사용할 수 있도록 일반 사용자로서 프로그램을 테스트하는 것은 좋은 실천 방법입니다. 이진 파일의 권한이 잘못 설정되어 슈퍼유저만 프로그램을 사용할 수 있는 경우가 있을 수 있습니다. 물론 일반 사용자도 프로그램을 사용할 수 있도록 원하는 경우입니다.

5.  끝났습니다! 이 실습이 완료되었습니다!

