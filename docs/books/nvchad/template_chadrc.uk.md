---
title: Приклад Config
author: Franco Colussi
contributors: Steven Spencer, Ganna Zhyrnova
tested_with: 8.7, 9.1
tags:
  - nvchad
  - coding
  - плагіни
---

# Приклад конфігурації

!!! danger "Більше не надається"

    Приклад конфігурації більше не надається під час встановлення NvChad, отже, ця сторінка застаріла та буде видалена в новій версії посібника. Інструкції будуть оновлені якомога швидше.

## :material-message-outline: Вступ

У версії 2.0 NvChad з’явилася можливість створювати папку ==custom== на етапі встановлення. Його створення є відправною точкою для налаштування редактора шляхом зміни його файлів. Встановлений під час завантаження, він дозволяє використовувати редактор із основними функціями IDE під час першого запуску, але також може бути включений після встановлення NvChad.

Найважливішим аспектом його встановлення є створення базових структур для включення деяких розширених функцій, таких як мовні сервери, лінтери та засоби форматування. Ці структури дозволяють інтегрувати необхідну функціональність з невеликими змінами.

Папку створено на основі прикладу в репозиторії GitHub NvChad: ([example-config](https://github.com/NvChad/example_config)).

## :material-monitor-arrow-down-variant: Встановлення

=== "Встановлення за допомогою початкового завантаження"

    Щоб створити його під час встановлення, дайте відповідь «у» на запитання, яке нам задають на початку встановлення:
    
    > Do you want to install example custom config? (y/N):
    
    Ствердна відповідь розпочне процес, який клонує вміст папки *example-config* із GitHub у **~/.config/nvim/lua/custom/** і після завершення видалить з нього папку **.git**.  
    Його видалення дозволяє помістити папку під персональний контроль версій.
    
    Папка готова та використовуватиметься під час наступного запуску NvChad для введення власних конфігурацій у редактор.

=== "Встановлення із репозиторію"

    Встановлення конфігурації, надане за допомогою ==example-config==, також можна виконати після встановлення NvChad, у цьому випадку сховище все ще використовується, але отримується вручну.
    
    Стандартна інсталяція без ==example-config== усе одно створює папку *custom*, де потрібно зберегти файл ==chadrc.lua== для налаштувань користувача, який слід видалити або зберегти в ==резервній копії==, щоб забезпечити запуск клону. Потім збережіть наявну конфігурацію за допомогою:

    ```bash
    mv ~/.config/nvim/lua/custom/ ~/.config/nvim/lua/custom.bak
    ```


    І клонуйте репозиторій GitHub до вашої конфігурації:

    ```bash
    git clone https://github.com/NvChad/example_config.git ~/.config/nvim/lua/custom
    ```


    Ця команда копіює весь вміст репозиторію, знайдений в Інтернеті, до папки `~/.config/nvim/lua/custom/`, копіюючи приховану папку `.git`, яку потрібно видалити вручну, щоб дозволити перейти до особистого контролю версій. Для видалення виконайте команду:

    ```bash
    rm rf ~/.config/nvim/lua/custom/.git/
    ```


    Папка готова та використовуватиметься під час наступного запуску NvChad для введення власних конфігурацій у редактор.

## :material-file-outline: Структура

Структура папки ==custom== складається з кількох конфігураційних файлів і папки `configs`, яка містить файли опцій плагіна, встановлені в *plugins.lua*.

Використання окремих файлів для налаштувань плагіна дає змогу мати набагато оптимізованіший файл *plugins.lua* та працювати лише над кодом плагіна під час його налаштування. Це також рекомендований метод для розробки плагінів, які ви додасте пізніше.

Створена структура виглядає наступним чином:

```text
custom/
├── chadrc.lua
├── configs
│   ├── conform.lua
│   ├── lspconfig.lua
│   └── overrides.lua
├── highlights.lua
├── init.lua
├── mappings.lua
├── plugins.lua
└── README.md

```

Як ми бачимо, папка містить кілька однойменних файлів, які також зустрічаються в базовій структурі NvChad. Ці файли дозволяють інтегрувати конфігурацію та замінювати основні параметри редактора.

## :octicons-file-code-16: Аналіз структури

Тепер перейдемо до його змісту:

### :material-file-multiple-outline: Основні файли

#### :material-language-lua: chadrc.lua

```lua
---@type ChadrcConfig
local M = {}

-- Path to overriding theme and highlights files
local highlights = require "custom.highlights"

M.ui = {
  theme = "onedark",
  theme_toggle = { "onedark", "one_light" },

  hl_override = highlights.override,
  hl_add = highlights.add,
}

M.plugins = "custom.plugins"

-- check core.mappings for table structure
M.mappings = require "custom.mappings"

return M
```

Файл вставляється в конфігурацію Neovim за допомогою функції `load_config`, встановленої у файлі **~/.config/nvim/lua/core/utils.lua**. Функція завантажує параметри за замовчуванням і, якщо є, налаштування файлу *chadrc.lua* в папці *custom*:

```lua
M.load_config = function()
  local config = require "core.default_config"
  local chadrc_path = vim.api.nvim_get_runtime_file("lua/custom/chadrc.lua", false)[1]
...
```

Його функція полягає в тому, щоб вставляти файли з папки *custom* у конфігурацію NvChad, а потім використовувати їх разом із файлами за замовчуванням для запуску екземпляра *Neovim*. Файли вставляються в дерево конфігурації за допомогою функцій `require', таких як:

```lua
require("custom.mappings")
```

Рядок **custom.mappings** вказує відносний шлях до файлу без розширення на відміну від шляху за замовчуванням, який у цьому випадку є **~/.config/nvim/lua/**. Крапка замінює скісну риску, оскільки це домовленість у коді, написаному мовою Lua (у *мові lua* немає поняття *каталог*).

Підсумовуючи, ми можемо сказати, що виклик, описаний вище, вставляє конфігурації, записані у файлі `custom/mappings.lua`, у відображення NvChad, таким чином вставляючи ярлики для виклику команд для плагінів, встановлених у ` custom/plugins.lua`.

Розділ у файлі також замінює деякі параметри конфігурації інтерфейсу користувача NvChad, що містяться в `core/default_config.lua`, зокрема розділ **M.ui**, який дозволяє, наприклад, виберіть світлу або темну тему.

У кінці файлу встановлюється виклик ==require== до файлу `custom/plugins.lua`, який відповідає рядку:

```lua
M.plugins = "custom.plugins"
```

Таким чином плагіни, встановлені в `custom/plugins.lua`, разом із тими, що складають конфігурацію NvChad, будуть передані до *lazy.nvim* для встановлення та керування ними. У цьому випадку включення не в дерево Neovim. Натомість у конфігурації *lazy.nvim*, оскільки цей плагін повністю вимикає відповідні функції редактора за допомогою виклику `vim.go.loadplugins = false`. Натомість він міститься в конфігурації *lazy.nvim*, оскільки цей плагін повністю вимикає відповідні функції редактора за допомогою виклику `vim.go.loadplugins = false`.

#### :material-language-lua: init.lua

Цей файл використовується для перезапису налаштувань, визначених у `core/init.lua`, таких як відступ або інтервал запису на диск. Він також використовується для створення автоматичних команд, як описано в коментованих рядках у файлі. Прикладом може бути наступне, до якого включено деякі налаштування для написання документів у Markdown:

```lua
--local autocmd = vim.api.nvim_create_autocmd

-- settings for Markdown
local opt = vim.opt

opt.tabstop = 4
opt.softtabstop = 4
opt.shiftwidth = 4
opt.shiftround = false
opt.expandtab = true
opt.autoindent = true
opt.smartindent = true

-- Auto resize panes when resizing nvim window
--autocmd("VimResized", {
--   pattern = "*",
--   command = "tabdo wincmd =",
-- })
```

Це, серед іншого, замінює 2-пробілну табуляцію на 4-пробілну табуляцію, яка більше підходить для коду Markdown.

#### :material-language-lua: plugins.lua

Цей файл встановлює плагіни, які потрібно додати до базової конфігурації NvChad. Додавання плагінів детально описано на сторінці, присвяченій [Менеджеру плагінів](nvchad_ui/plugins_manager.md).

Файл *plugins.lua*, створений за допомогою *example-config*, містить у першій частині кілька налаштувань, які замінюють параметри визначення плагіна та конфігурації плагіна за замовчуванням. Цю частину файлу нам не потрібно змінювати, оскільки для цього розробники підготували спеціальні файли, які знаходяться в папці *config*.

Далі встановлюється плагін. Це було створено як приклад, щоб ознайомити вас із використовуваним форматом *lazy.nvim*.

```lua
  -- Install a plugin
  {
    "max397574/better-escape.nvim",
    event = "InsertEnter",
    config = function()
      require("better_escape").setup()
    end,
  },
```

Ви можете вставити всі додаткові плагіни після цього плагіна та перед останньою дужкою. Існує ціла екосистема плагінів, які підходять для будь-яких цілей. Ви можете відвідати [Neovimcraft](https://neovimcraft.com/) для першого огляду.

#### :material-language-lua: mappings.lua

Цей файл призначений для включення в дерево конфігурації відповідностей (комбінацій клавіш), необхідних для виклику додаткових команд плагіна.

Тут також представлено приклад налаштування, щоб можна було вивчити його формат:

```lua
M.general = {
    n = {
        [";"] = { ":", "enter command mode", opts = { nowait = true } },
    },
}
```

Це відображення вводиться для стану NORMAL `n =` символ ++";"++, який, якщо натиснути на клавіатурі, відтворює символ ++двокрапка++. Цей символ використовується для входу в КОМАНДНИЙ режим. Параметр `nowait = true` також встановлено для негайного входу в цей режим. Таким чином, на клавіатурі з американською розкладкою QWERTY нам не потрібно буде використовувати ++shift++ для входу в режим COMMAND.

!!! tip "Порада"

    Користувачам європейських клавіатур (наприклад, італійської) рекомендується замінити символ ++";"++ на ++","++.

#### :material-language-lua: highlights.lua

Файл використовується для налаштування стилю редактора. Наведені тут параметри використовуються для зміни таких аспектів, як стиль шрифту (**жирний**,*курсив*), колір фону елемента, колір переднього плану тощо.

### :material-folder-cog-outline: Папка configs

Ця папка містить усі конфігураційні файли, які використовуються у файлі **custom/plugins.lua** для зміни параметрів за замовчуванням плагінів, які працюють із мовними серверами (*lspconfig*), linter/formatters ( *conform*), а також для заміни базових налаштувань **treesitter**, **mason** і **nvim-tree** (*override*).

```text
configs/
├── conform.lua
├── lspconfig.lua
└── overrides.lua
```

#### :material-language-lua: lspconfig.lua

Файл *lspconfig.lua* встановлює локальні мовні сервери, які може використовувати редактор. Це дозволить розширеним функціям для підтримуваних файлів, таким як автозаповнення або фрагменти, швидко створювати частини коду. Щоб додати наш *lsp* до конфігурації, ми просто редагуємо таблицю (в *lua* те, що представлено нижче у фігурних дужках, є таблицею), підготовлену спеціально розробниками NvChad:

```lua
local servers = { "html", "cssls", "tsserver", "clangd" }
```

Як ми бачимо, деякі сервери вже налаштовані за замовчуванням. Щоб додати новий, введіть його в кінці таблиці. Доступні сервери можна знайти на [mason packages](https://github.com/williamboman/mason.nvim/blob/main/PACKAGES.md), а для їх конфігурацій ви можете звернутися до [lsp server configurations](https://github.com/neovim/nvim-lspconfig/blob/master/doc/server_configurations.md).

Наприклад, якщо ми також хочемо підтримувати мову `yaml`, ми можемо додати її, як показано в наступному прикладі:

```lua
local servers = { "html", "cssls", "tsserver", "clangd", "yamlls" }
```

Однак зміна файлу не передбачає встановлення відповідного мовного сервера. Це потрібно встановити окремо за допомогою *Mason*. Мовний сервер, який підтримує *yaml*, це [yaml-language-server](https://github.com/redhat-developer/yaml-language-server), який нам потрібно встановити за допомогою команди `:MasonInstall yaml-language-server</2 >. На цьому етапі ми матимемо, наприклад, контроль над кодом, написаним у заголовках (<em x-id="3">frontmatter</em>) сторінок документації Rocky Linux.</p>

<h4 spaces-before="0">:material-language-lua: conform.lua</h4>

<p spaces-before="1">Цей файл налаштовує деякі функції, спрямовані на керування та форматування написаного коду. Редагування цього файлу вимагає більше досліджень для конфігурації, ніж попередній. Огляд доступних компонентів можна знайти на <a href="https://github.com/stevearc/conform.nvim/tree/master?tab=readme-ov-file#formatters">сторінці вбудованих компонентів</a>.</p>

<p spaces-before="0">Знову було створено таблицю ==formatters_by_ft==, у яку потрібно вводити налаштування:</p>

<pre><code class="lua">--type conform.options
local options = {
  lsp_fallback = true,

  formatters_by_ft = {
    lua = { "stylua" },

    javascript = { "prettier" },
    css = { "prettier" },
    html = { "prettier" },
    sh = { "shfmt" },
  },
}
`</pre>

Як бачите, у початкову конфігурацію входили лише стандартні форматери. Наприклад, вам може знадобитися форматувальник для мови Markdown, і в цьому випадку ви можете додати, наприклад, [Markdownlint](https://github.com/DavidAnson/markdownlint):

```lua
    markdown = { "markdownlint" },
```

Знову ж таки, конфігурація вимагає встановлення відповідного пакета, який можна встановити за допомогою *Mason*:

```text
:MasonInstall markdownlint
```

!!! note "Примітка"

    Конфігурація цього форматера також вимагає створення файлу конфігурації у вашій домашній папці, про що в цьому документі не йдеться.

#### :material-language-lua: overrides.lua

Файл *overrides.lua* містить зміни, які потрібно внести в налаштування плагіна за замовчуванням. Плагіни, до яких буде застосовано зміни, указано в розділі ==-- Перевизначити параметри визначення плагіна== у файлі `custom/plugins.lua` за допомогою **opts** (наприклад, `opts = overrides.mason`).

У початковій конфігурації є три плагіни, позначені як такі, що потребують перевизначення, і це *treesitter*, *mason* і *nvim-tree*. Залишаючи наразі *nvim-tree*, ми зосередимося на перших двох, які дозволяють нам суттєво змінити досвід редагування.

*treesitter* — це синтаксичний аналізатор коду, який піклується про його форматування в інтерактивний спосіб. Щоразу, коли ми зберігаємо файл, розпізнаний *treesitter*, він передається синтаксичному аналізатору, який повертає оптимально виділене дерево коду з відступом, що полегшує читання, інтерпретацію та редагування коду в редакторі.

Частина коду, яка це робить, така:

```lua
M.treesitter = {
    ensure_installed = {
        "vim",
        "lua",
        "html",
        "css",
        "javascript",
        "typescript",
        "tsx",
        "c",
        "markdown",
        "markdown_inline",
    },
    indent = {
        enable = true,
        -- disable = {
        --   "python"
        -- },
    },
}
```

Тепер, дотримуючись прикладу, наведеного раніше, якщо ми хочемо, щоб *frontmatter* наших сторінок документації на Rocky Linux було правильно виділено, ми можемо додати підтримку для *yaml* у ` secure_installed` після останнього набору аналізатора:

```text
    ...
    "tsx",
    "c",
    "markdown",
    "markdown_inline",
    "yaml",
    ...
```

Наступного разу, коли ми відкриємо NvChad, аналізатор, який ми щойно додали, також буде автоматично встановлено.

Щоб мати доступ до аналізатора безпосередньо у запущеному екземплярі NvChad, ми завжди можемо встановити його, навіть не редагуючи файл, за допомогою команди:

```text
:TSInstall yaml
```

Далі у файлі є частина, яка стосується встановлення серверів *Mason*. Усі сервери, указані в цій таблиці, встановлюються однією операцією за допомогою команди `:MasonInstallAll` (ця команда також викликається під час створення *користувацької* папки). Частина має наступний вигляд:

```lua
M.mason = {
    ensure_installed = {
        -- lua stuff
        "lua-language-server",
        "stylua",

        -- web dev stuff
        "css-lsp",
        "html-lsp",
        "typescript-language-server",
        "deno",
        "prettier",
    },
}
```

Знову ж таки, слідуючи початковому прикладу, де ми ввімкнули підтримку для *yaml*, встановивши сервер вручну, ми можемо переконатися, що він завжди встановлений, додавши його до таблиці:

```text
    ...
    "typescript-language-server",
    "deno",
    "prettier",

    -- yaml-language-server
    "yaml-language-server",
    ...
```

Хоча цей аспект може бути незначним на запущеному екземплярі NvChad, оскільки ми завжди можемо вручну встановити відсутні сервери, він виявляється дуже корисним під час перенесення нашої конфігурації з однієї машини на іншу.

Наприклад, припустімо, що ми налаштували папку `custom` із усіма потрібними функціями та хочемо перенести її до іншої інсталяції NvChad. Якщо ми налаштували цей файл, після копіювання або клонування нашої папки `custom` `:MasonInstallAll` буде достатньо, щоб мати всі сервери, готові до використання в іншій установці.


Остання частина конфігурації, розділ `M.nvimtree`, піклується про налаштування *nvim-tree*, увімкнувши функцію відображення стану в дереві файлів, що стосуються репозиторію git:

```lua
  git = {
    enable = true,
  },
```

їх виділення та відповідні значки:

```lua
  renderer = {
    highlight_git = true,
    icons = {
      show = {
        git = true,
      },
    },
  },
```

## :material-contain-end: Висновок

Поява в NvChad 2.0 можливості створювати `спеціальну` папку під час першого встановлення, безсумнівно, є великою підмогою для всіх тих користувачів, які вперше користуються цим редактором. Це також значна економія часу для тих, хто вже мав справу з NvChad.

Завдяки представленню та використанню *Mason* інтеграція ваших функцій є простою та швидкою. Потрібно лише внести кілька змін, і ви одразу готові використовувати IDE для написання коду.
