---
title: Приклад Config
author: Franco Colussi
contributors: Steven Spencer, Ganna Zhyrnova
tested_with: 8.7, 9.1
tags:
  - nvchad
  - coding
  - плагіни
---

# Приклад конфігурації

!!! danger "Більше не надається"

    Приклад конфігурації більше не надається під час встановлення NvChad, отже, ця сторінка застаріла та буде видалена в новій версії посібника. Інструкції будуть оновлені якомога швидше.

## :material-message-outline: Вступ

У версії 2.0 NvChad з’явилася можливість створювати папку ==custom== на етапі встановлення. Його створення є відправною точкою для налаштування редактора шляхом зміни його файлів. Встановлений під час завантаження, він дозволяє використовувати редактор із основними функціями IDE під час першого запуску, але також може бути включений після встановлення NvChad.

Найважливішим аспектом його встановлення є створення базових структур для включення деяких розширених функцій, таких як мовні сервери, лінтери та засоби форматування. Ці структури дозволяють інтегрувати необхідну функціональність з невеликими змінами.

Папку створено на основі прикладу в репозиторії GitHub NvChad: ([example-config](https://github.com/NvChad/example_config)).

## :material-monitor-arrow-down-variant: Встановлення

\=== "Встановлення за допомогою початкового завантаження"

    ```
    Щоб створити його під час встановлення, дайте відповідь «у» на запитання, яке нам задають на початку встановлення:
    
    > Do you want to install example custom config? (y/N):
    
    Ствердна відповідь розпочне процес, який клонує вміст папки *example-config* із GitHub у **~/.config/nvim/lua/custom/** і після завершення видалить з нього папку **.git**.  
    Його видалення дозволяє помістити папку під персональний контроль версій.
    
    Папка готова та використовуватиметься під час наступного запуску NvChad для введення власних конфігурацій у редактор.
    ```

\=== "Встановлення із репозиторію"

    ````
    Встановлення конфігурації, надане за допомогою ==example-config==, також можна виконати після встановлення NvChad, у цьому випадку сховище все ще використовується, але отримується вручну.
    
    Стандартна інсталяція без ==example-config== усе одно створює папку *custom*, де потрібно зберегти файл ==chadrc.lua== для налаштувань користувача, який слід видалити або зберегти в ==резервній копії==, щоб забезпечити запуск клону. Потім збережіть наявну конфігурацію за допомогою:
    
    ```bash
    mv ~/.config/nvim/lua/custom/ ~/.config/nvim/lua/custom.bak
    ```
    
    
    І клонуйте репозиторій GitHub до вашої конфігурації:
    
    ```bash
    git clone https://github.com/NvChad/example_config.git ~/.config/nvim/lua/custom
    ```
    
    
    Ця команда копіює весь вміст репозиторію, знайдений в Інтернеті, до папки `~/.config/nvim/lua/custom/`, копіюючи приховану папку `.git`, яку потрібно видалити вручну, щоб дозволити перейти до особистого контролю версій. Для видалення виконайте команду:
    
    ```bash
    rm rf ~/.config/nvim/lua/custom/.git/
    ```
    
    
    Папка готова та використовуватиметься під час наступного запуску NvChad для введення власних конфігурацій у редактор.
    ````

## :material-file-outline: Структура

Структура папки ==custom== складається з кількох конфігураційних файлів і папки `configs`, яка містить файли опцій плагіна, встановлені в _plugins.lua_.

Використання окремих файлів для налаштувань плагіна дозволяє мати набагато спрощений файл _plugins.lua_ та працювати лише з кодом плагіна під час його налаштування. Це також рекомендований метод для розробки плагінів, які ви додасте пізніше.

Створена структура виглядає наступним чином:

```text
custom/
├── chadrc.lua
├── configs
│   ├── conform.lua
│   ├── lspconfig.lua
│   └── overrides.lua
├── highlights.lua
├── init.lua
├── mappings.lua
├── plugins.lua
└── README.md

```

Як ми бачимо, папка містить кілька однойменних файлів, які також зустрічаються в базовій структурі NvChad. Ці файли дозволяють інтегрувати конфігурацію та замінювати основні параметри редактора.

## :octicons-file-code-16: Аналіз структури

Тепер перейдемо до його змісту:

### :material-file-multiple-outline: Основні файли

#### :material-language-lua: chadrc.lua

```lua
---@type ChadrcConfig
local M = {}

-- Path to overriding theme and highlights files
local highlights = require "custom.highlights"

M.ui = {
  theme = "onedark",
  theme_toggle = { "onedark", "one_light" },

  hl_override = highlights.override,
  hl_add = highlights.add,
}

M.plugins = "custom.plugins"

-- check core.mappings for table structure
M.mappings = require "custom.mappings"

return M
```

Файл вставляється в конфігурацію Neovim функцією `load_config`, встановленою у файлі **~/.config/nvim/lua/core/utils.lua**. Функція завантажує налаштування за замовчуванням, а також, якщо такі є, налаштування файлу _chadrc.lua_ у папці _custom_:

```lua
M.load_config = function()
  local config = require "core.default_config"
  local chadrc_path = vim.api.nvim_get_runtime_file("lua/custom/chadrc.lua", false)[1]
...
```

Його функція полягає у вставці файлів з папки _custom_ до конфігурації NvChad, а потім у використанні їх разом із файлами за замовчуванням для запуску екземпляра _Neovim_. Файли вставляються в дерево конфігурації за допомогою функцій \`require', таких як:

```lua
require("custom.mappings")
```

Рядок **custom.mappings** вказує відносний шлях до файлу без розширення, на відміну від шляху за замовчуванням, який у цьому випадку є **~/.config/nvim/lua/**. Крапка замінює скісну риску, оскільки це є домовленістю в коді, написаному на Lua (у _мові lua_ немає поняття _каталогу_).

Підсумовуючи, ми можемо сказати, що виклик, описаний вище, вставляє конфігурації, записані у файлі `custom/mappings.lua`, у відображення NvChad, таким чином вставляючи ярлики для виклику команд для плагінів, встановлених у ` custom/plugins.lua`.

Розділ у файлі також замінює деякі параметри конфігурації інтерфейсу користувача NvChad, що містяться в `core/default_config.lua`, зокрема розділ **M.ui**, який дозволяє, наприклад, виберіть світлу або темну тему.

У кінці файлу встановлюється виклик ==require== до файлу `custom/plugins.lua`, який відповідає рядку:

```lua
M.plugins = "custom.plugins"
```

Таким чином, плагіни, встановлені в `custom/plugins.lua`, передаються разом з тими, що складають конфігурацію NvChad, до _lazy.nvim_ для встановлення та керування ними. У цьому випадку включення не в дерево Neovim. Натомість у конфігурації <em x-id="3">lazy.nvim</em>, оскільки цей плагін повністю вимикає відповідні функції редактора за допомогою виклику <code>vim.go.loadplugins = false</code>. Натомість, це знаходиться в конфігурації _lazy.nvim_, оскільки цей плагін повністю вимикає пов'язану функціональність редактора за допомогою виклику `vim.go.loadplugins = false`.

#### :material-language-lua: init.lua

Цей файл використовується для перезапису налаштувань, визначених у `core/init.lua`, таких як відступи або інтервал запису підкачки, на диск. Він також використовується для створення автоматичних команд, як описано в коментованих рядках у файлі. Прикладом може бути наступне, до якого включено деякі налаштування для написання документів у Markdown:

```lua
--local autocmd = vim.api.nvim_create_autocmd

-- settings for Markdown
local opt = vim.opt

opt.tabstop = 4
opt.softtabstop = 4
opt.shiftwidth = 4
opt.shiftround = false
opt.expandtab = true
opt.autoindent = true
opt.smartindent = true

-- Auto resize panes when resizing nvim window
--autocmd("VimResized", {
--   pattern = "*",
--   command = "tabdo wincmd =",
-- })
```

Це, серед іншого, замінює 2-пробілну табуляцію на 4-пробілну табуляцію, яка більше підходить для коду Markdown.

#### :material-language-lua: plugins.lua

Цей файл встановлює плагіни, які потрібно додати до базової конфігурації NvChad. Додавання плагінів детально пояснюється на сторінці, присвяченій [Менеджеру плагінів] (nvchad_ui/plugins_manager.md).

Файл _plugins.lua_, створений командою _example-config_, має у першій частині низку налаштувань, які замінюють параметри визначення плагіна та конфігурації плагінів за замовчуванням. Цю частину файлу нам не потрібно змінювати, оскільки розробники підготували для цього спеціальні файли, які знаходяться в папці _config_.

Далі встановлюється плагін. Це було створено як приклад, щоб ви могли ознайомитися з форматом, який використовується _lazy.nvim_.

```lua
  -- Install a plugin
  {
    "max397574/better-escape.nvim",
    event = "InsertEnter",
    config = function()
      require("better_escape").setup()
    end,
  },
```

Ви можете вставити всі додаткові плагіни після цього плагіна та перед останньою дужкою. Існує ціла екосистема плагінів, які підходять для будь-яких цілей. Ви можете відвідати [Neovimcraft](https://neovimcraft.com/) для першого огляду.

#### :material-language-lua: mappings.lua

Цей файл призначений для включення в дерево конфігурації відповідностей (комбінацій клавіш), необхідних для виклику додаткових команд плагіна.

Тут також представлено приклад налаштування, щоб можна було вивчити його формат:

```lua
M.general = {
	n = {
		[";"] = { ":", "enter command mode", opts = { nowait = true } },
	},
}
```

Це відображення вводиться для НОРМАЛЬНОГО стану `n =` символ ++";"++, який при натисканні на клавіатурі відтворює символ ++двокрапки++. Цей символ використовується для входу в КОМАНДНИЙ режим. Опція `nowait = true` також встановлена ​​для негайного переходу в цей режим. Таким чином, на клавіатурі з американською розкладкою QWERTY нам не потрібно буде використовувати ++shift++ для входу в режим COMMAND.

!!! tip "Порада"

    Користувачам європейських клавіатур (наприклад, італійської) рекомендується замінити символ ++";"++ на ++","++.

#### :material-language-lua: highlights.lua

Файл використовується для налаштування стилю редактора. Налаштування, описані тут, використовуються для зміни таких аспектів, як стиль шрифту (**жирний**, _курсив_), колір фону елемента, колір переднього плану тощо.

### :material-folder-cog-outline: Папка configs

Ця папка містить усі конфігураційні файли, які використовуються у файлі **custom/plugins.lua** для зміни параметрів за замовчуванням плагінів, які працюють із мовними серверами (_lspconfig_), linter/formatters ( _conform_), а також для заміни базових налаштувань **treesitter**, **mason** і **nvim-tree** (_override_).

```text
configs/
├── conform.lua
├── lspconfig.lua
└── overrides.lua
```

#### :material-language-lua: lspconfig.lua

Файл _lspconfig.lua_ встановлює локальні мовні сервери, які може використовувати редактор. Це дозволить розширеним функціям для підтримуваних файлів, таким як автозаповнення або фрагменти, швидко створювати частини коду. Щоб додати наш _lsp_ до конфігурації, ми просто редагуємо таблицю (у _lua_ те, що представлено нижче у фігурних дужках, є таблицею), спеціально підготовлену розробниками NvChad:

```lua
local servers = { "html", "cssls", "tsserver", "clangd" }
```

Як ми бачимо, деякі сервери вже налаштовані за замовчуванням. Щоб додати новий, введіть його в кінці таблиці. Доступні сервери можна знайти в [пакетах mason](https://github.com/williamboman/mason.nvim/blob/main/PACKAGES.md), а їх конфігурації дивіться в [конфігураціях сервера lsp](https://github.com/neovim/nvim-lspconfig/blob/master/doc/server_configurations.md).

Наприклад, якщо ми також хочемо підтримувати мову `yaml`, ми можемо додати її, як показано в наступному прикладі:

```lua
local servers = { "html", "cssls", "tsserver", "clangd", "yamlls" }
```

Однак зміна файлу не передбачає встановлення відповідного мовного сервера. Це потрібно встановити окремо за допомогою _Mason_. Мовний сервер, що забезпечує підтримку _yaml_, — це [yaml-language-server](https://github.com/redhat-developer/yaml-language-server), який нам потрібно буде встановити за допомогою команди `:MasonInstall yaml-language-server`. На цьому етапі ми матимемо, наприклад, контроль над кодом, написаним у заголовках (_frontmatter_) сторінок документації Rocky Linux.

#### :material-language-lua: conform.lua

Цей файл налаштовує деякі функції, спрямовані на керування та форматування написаного коду. Редагування цього файлу вимагає більше досліджень для конфігурації, ніж попередній. Огляд доступних компонентів можна знайти на [сторінці вбудованих компонентів](https://github.com/stevearc/conform.nvim/tree/master?tab=readme-ov-file#formatters).

Знову було створено таблицю ==formatters_by_ft==, у яку потрібно вводити налаштування:

```lua
--type conform.options
local options = {
  lsp_fallback = true,

  formatters_by_ft = {
    lua = { "stylua" },

    javascript = { "prettier" },
    css = { "prettier" },
    html = { "prettier" },
    sh = { "shfmt" },
  },
}
```

Як бачите, у початкову конфігурацію входили лише стандартні форматери. Наприклад, вам може знадобитися форматувальник для мови Markdown, і в такому випадку ви можете додати, наприклад, [Markdownlint](https://github.com/DavidAnson/markdownlint):

```lua
    markdown = { "markdownlint" },
```

Знову ж таки, конфігурація вимагає встановлення відповідного пакета, який можна встановити за допомогою _Mason_:

```text
:MasonInstall markdownlint
```

!!! note "Примітка"

    Конфігурація цього форматера також вимагає створення файлу конфігурації у вашій домашній папці, про що в цьому документі не йдеться.

#### :material-language-lua: overrides.lua

Файл _overrides.lua_ містить зміни, які потрібно внести до налаштувань плагіна за замовчуванням. Плагіни, до яких мають бути застосовані зміни, вказані в розділі ==-- Override plugin definition options== файлу `custom/plugins.lua` за допомогою опції **opts** (наприклад, `opts = overrides.mason`).

У початковій конфігурації є три плагіни, позначені як такі, що потребують перевизначення, а саме _treesitter_, _mason_ та _nvim-tree_. Залишивши _nvim-tree_ поки що без розгляду, ми зосередимося на перших двох, які дозволяють нам суттєво змінити наш досвід редагування.

_treesitter_ — це парсер коду, який інтерактивно виконує форматування коду. Щоразу, коли ми зберігаємо файл, розпізнаний _treesitter_, він передається синтаксичному аналізатору, який повертає оптимально відступне та виділене дерево коду, що полегшує читання, інтерпретацію та редагування коду в редакторі.

Частина коду, яка це робить, така:

```lua
M.treesitter = {
	ensure_installed = {
		"vim",
		"lua",
		"html",
		"css",
		"javascript",
		"typescript",
		"tsx",
		"c",
		"markdown",
		"markdown_inline",
	},
	indent = {
		enable = true,
		-- disable = {
		--   "python"
		-- },
	},
}
```

Тепер, дотримуючись прикладу, наведеного раніше, якщо ми хочемо, щоб _frontmatter_ наших сторінок документації на Rocky Linux було правильно виділено, ми можемо додати підтримку для _yaml_ у ` secure_installed` після останнього набору аналізатора:

```text
    ...
    "tsx",
    "c",
    "markdown",
    "markdown_inline",
    "yaml",
    ...
```

Наступного разу, коли ми відкриємо NvChad, аналізатор, який ми щойно додали, також буде автоматично встановлено.

Щоб мати доступ до аналізатора безпосередньо у запущеному екземплярі NvChad, ми завжди можемо встановити його, навіть не редагуючи файл, за допомогою команди:

```text
:TSInstall yaml
```

Далі у файлі йде частина, що стосується встановлення серверів користувачем _Mason_. Усі сервери, зазначені в цій таблиці, встановлюються однією операцією за допомогою команди `:MasonInstallAll` (ця команда також викликається під час створення папки _custom_). Частина має наступний вигляд:

```lua
M.mason = {
	ensure_installed = {
		-- lua stuff
		"lua-language-server",
		"stylua",

		-- web dev stuff
		"css-lsp",
		"html-lsp",
		"typescript-language-server",
		"deno",
		"prettier",
	},
}
```

Знову ж таки, слідуючи початковому прикладу, де ми ввімкнули підтримку для _yaml_, встановивши сервер вручну, ми можемо переконатися, що він завжди встановлений, додавши його до таблиці:

```text
    ...
    "typescript-language-server",
    "deno",
    "prettier",

    -- yaml-language-server
    "yaml-language-server",
    ...
```

Хоча цей аспект може бути незначним на запущеному екземплярі NvChad, оскільки ми завжди можемо вручну встановити відсутні сервери, він виявляється дуже корисним під час перенесення нашої конфігурації з однієї машини на іншу.

Наприклад, припустимо, що ми налаштували нашу папку `custom` і хочемо перенести її до іншої інсталяції NvChad. Якщо ми налаштували цей файл, то після копіювання або клонування нашої папки `custom` файлу `:MasonInstallAll` буде достатньо, щоб усі сервери були готові до використання і на іншій інсталяції.

Остання частина конфігурації, розділ `M.nvimtree`, піклується про налаштування _nvim-tree_, увімкнувши функцію відображення стану в дереві файлів, що стосуються репозиторію git:

```lua
  git = {
    enable = true,
  },
```

їх виділення та відповідні значки:

```lua
  renderer = {
    highlight_git = true,
    icons = {
      show = {
        git = true,
      },
    },
  },
```

## :material-contain-end: Висновок

Впровадження в NvChad 2.0 можливості створення власної папки під час першої інсталяції, безумовно, є великою допомогою для всіх тих користувачів, які вперше користуються цим редактором. Це також значна економія часу для тих, хто вже мав справу з NvChad.

Завдяки його впровадженню та використанню _Mason_, інтеграція власного функціоналу є простою та швидкою. Потрібно лише внести кілька змін, і ви одразу готові використовувати IDE для написання коду.
