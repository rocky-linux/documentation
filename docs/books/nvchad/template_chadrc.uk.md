---
title: Шаблон Chadrc
author: Franco Colussi
contributors: Steven Spencer, Ganna Zhyrnova
tested_with: 8.7, 9.1
tags:
  - nvchad
  - coding
  - плагіни
---

# Шаблон Chadrc

У версії 2.0 NvChad розробники представили можливість створювати на етапі інсталяції папку `custom`, де ви можете робити власні налаштування. Запровадження цієї функції дає змогу мати редактор із основними функціями IDE із самого початку.

Найважливішим аспектом створення папки _custom_ є запис файлів, які містять конфігурації для налаштування деяких додаткових функцій, таких як мовні сервери, лінтери та засоби форматування. Ці файли дозволяють нам інтегрувати, лише з кількома змінами, потрібну нам функціональність.

Папка також містить файли для підсвічування коду та відображення настроюваних команд.

Папку створено на основі прикладу в репозиторії GitHub NvChad: ([example-config](https://github.com/NvChad/example_config)). Щоб створити його під час встановлення, просто дайте відповідь «у» на запитання, яке нам задають на початку встановлення:

> Do you want to install chadrc template? (Бажаєте встановити шаблон chadrc?) (y/N) :

Позитивна відповідь розпочне процес, який клонуватиме вміст папки _example-config_ із GitHub у **~/.config/ nvim/lua/custom/** і після завершення видалить з нього папку **.git**. Це дозволяє нам поставити конфігурацію під наш власний контроль версій.

Після завершення ми матимемо наступну структуру:

```text
custom/
├── chadrc.lua
├── init.lua
├── plugins.lua
├── mappings.lua
├── highlights.lua
├── configs
│   ├── lspconfig.lua
│   ├── null-ls.lua
│   └── overrides.lua
└── README.md
```

Як ми бачимо, папка містить кілька файлів з такою ж назвою, які також зустрічаються в базовій структурі NvChad. Ці файли дозволяють інтегрувати конфігурацію та замінювати основні параметри редактора.

## Аналіз структури

Тепер перейдемо до його змісту:

### Основні файли

#### chadrc.lua

```lua
---@type ChadrcConfig
local M = {}

-- Path to overriding theme and highlights files
local highlights = require "custom.highlights"

M.ui = {
  theme = "onedark",
  theme_toggle = { "onedark", "one_light" },

  hl_override = highlights.override,
  hl_add = highlights.add,
}

M.plugins = "custom.plugins"

-- check core.mappings for table structure
M.mappings = require "custom.mappings"

return M
```

Файл вставляється в конфігурацію Neovim за допомогою функції `load_config`, встановленої у файлі **~/.config/nvim/lua/core/utils.lua**, функція, яка піклується про завантаження параметрів за замовчуванням і, якщо є, також параметрів нашого _chadrc.lua_:

```lua
M.load_config = function()
  local config = require "core.default_config"
  local chadrc_path = vim.api.nvim_get_runtime_file("lua/custom/chadrc.lua", false)[1]
...
```

Його функція полягає в тому, щоб вставити файли з нашої папки _custom_ у конфігурацію NvChad, щоб потім використовувати їх разом із файлами за замовчуванням для запуску _ Neovim_екземпляра. Файли вставляються в дерево конфігурації за допомогою функцій `require`, таких як:

```lua
require "custom.mappings"
```

Рядок **custom.mappings** вказує відносний шлях до файлу без розширення на відміну від шляху за замовчуванням, який у цьому випадку становить **~/.config/nvim/lua/**. Крапка замінює косу риску, оскільки це конвенція в коді, написаному мовою Lua (у _мові lua_ немає поняття _каталогу _).

Підсумовуючи, ми можемо сказати, що описаний вище виклик вставляє конфігурації, записані у файлі **custom/mappings.lua**, у відображення NvChad, таким чином вставляючи наші ярлики для виклику команд наших плагінів.

Потім у нас є розділ, який замінює деякі параметри конфігурації інтерфейсу користувача NvChad, що містяться в **~/.config/nvim/lua/core/default_config.lua**, точніше в <code Розділ >M.ui</code>, який дозволяє нам, наприклад, вибрати світлу або темну тему.

Ми також маємо включення наших плагінів, визначених у **custom/plugins.lua** відповідно до рядка:

```lua
M.plugins = "custom.plugins"
```

Таким чином наші плагіни разом із тими, що складають конфігурацію NvChad, будуть передані до _lazy.nvim_ для встановлення та керування. У цьому випадку включення відбувається не в дереві Neovim, а в конфігурації _lazy.nvim_, оскільки цей плагін повністю вимикає відносну функціональність редактора за допомогою виклику `vim.go.loadplugins = false`.

#### init.lua

Цей файл використовується для перезапису на диск налаштувань, визначених у **~/.config/nvim/lua/core/init.lua**, як-от відступ або інтервал запису своп. Він також використовується для створення автоматичних команд, як описано в коментованих рядках у файлі. Прикладом може бути наступне, до якого включено деякі налаштування для написання документів у Markdown:

```lua
--local autocmd = vim.api.nvim_create_autocmd

-- settings for Markdown
local opt = vim.opt

opt.tabstop = 4
opt.softtabstop = 4
opt.shiftwidth = 4
opt.shiftround = false
opt.expandtab = true
opt.autoindent = true
opt.smartindent = true

-- Auto resize panes when resizing nvim window
--autocmd("VimResized", {
--   pattern = "*",
--   command = "tabdo wincmd =",
-- })
```

Таким чином, наші налаштування замінять налаштування за замовчуванням.

#### plugins.lua

Цей файл, як ви можете здогадатися з назви, використовується для додавання наших плагінів до плагінів у базовій конфігурації NvChad. Вставлення плагінів детально описано на сторінці, присвяченій [Менеджеру плагінів](nvchad_ui/plugins_manager.md).

Файл _plugins.lua_, створений за допомогою _шаблону chadrc_, у першій частині має низку налаштувань, які замінюють параметри визначення плагіна та конфігурації плагіна за замовчуванням. Цю частину файлу ми не потребуємо змінювати, оскільки для цього розробники підготували спеціальні файли, які знаходяться в папці _config_.

Потім виконайте встановлення плагіна. Це налаштовано як приклад, щоб ви могли почати знайомитися з форматом, який використовує _lazy.nvim_, який дещо відрізняється від формату, який використовує _packer.nvim_, обробник, який використовувався у версії 1.0.

```lua
  -- Install a plugin
  {
    "max397574/better-escape.nvim",
    event = "InsertEnter",
    config = function()
      require("better_escape").setup()
    end,
  },
```

Після цього плагіна та перед останньою дужкою ми можемо вставити всі наші плагіни. Існує ціла екосистема плагінів, які підходять для будь-яких цілей. Щоб отримати початкові знання, відвідайте [Neovimcraft](https://neovimcraft.com/).

#### mappings.lua

Цей файл вставляє в дерево конфігурації відображення (комбінації клавіш), які будуть потрібні для виклику команд плагінів, які ми збираємося додати.

Тут також представлено приклад налаштування для вивчення його формату:

```lua
M.general = {
  n = {
    [";"] = { ":", "enter command mode", opts = { nowait = true } },
  },
}
```

Це відображення вводиться для НОРМАЛЬНОГО стану `n =` символ <kbd>;</kbd>, який при натисканні на клавіатурі відтворює символ <kbd>:</kbd>. Цей символ використовується для входу в режим COMMAND. Параметр `nowait = true` також встановлено для негайного входу в цей режим. Таким чином, на клавіатурі з американською розкладкою QWERTY нам не потрібно буде використовувати <kbd>SHIFT</kbd> для входу в режим COMMAND.

!!! tip "Порада"

    Для користувачів європейських клавіатур (таких як італійська) рекомендується замінити символ <kbd>;</kbd> з <kbd>,</kbd>.

#### highlights.lua

Файл використовується для налаштування стилю редактора. Наведені тут налаштування використовуються для зміни таких аспектів, як стиль шрифту (**жирний**,_курсив_), колір фону елементу, колір переднього плану тощо.

### Папка configs

Файли в цій папці – це файли конфігурації, які використовуються у файлі **custom/plugins.lua** для зміни параметрів плагінів за замовчуванням, які працюють із мовними серверами (_lspconfig_), linter/formatters (_null-ls_), а також для заміни основних налаштувань **treesitter**, **mason** і **nvim-tree** (_override_).

```text
configs/
├── lspconfig.lua
├── null-ls.lua
└── overrides.lua
```

#### lspconfig.lua

Файл _lspconfig.lua_ встановлює локальні мовні сервери, які може використовувати редактор. Це дозволить використовувати додаткові функції для підтримуваних файлів, наприклад автозаповнення або фрагменти, для швидкого створення фрагментів коду. Щоб додати наш _lsp_ до конфігурації, ми просто редагуємо таблицю (у _lua_ те, що представлено нижче фігурним у дужках — таблиця), яка підготовлена спеціально розробниками NvChad:

```lua
local servers = { "html", "cssls", "tsserver", "clangd" }
```

Як ми бачимо, деякі сервери вже налаштовані за замовчуванням. Щоб додати новий, просто введіть його в кінці таблиці. Доступні сервери можна знайти на [mason packages](https://github.com/williamboman/mason.nvim/blob/main/PACKAGES.md), а для їх конфігурацій можна звернутися до [конфігурації сервера lsp](https://github.com/neovim/nvim-lspconfig/blob/master/doc/server_configurations.md).

Наприклад, якщо ми також хочемо підтримувати мову `yaml`, ми можемо додати її, як показано в наступному прикладі:

```lua
local servers = { "html", "cssls", "tsserver", "clangd", "yamlls" }
```

Однак зміна файлу не передбачає встановлення відповідного мовного сервера. Це потрібно буде встановити окремо за допомогою _Mason_. Мовний сервер, який підтримує _yaml_, це [yaml-language -server](https://github.com/redhat-developer/yaml-language-server), який нам потрібно встановити за допомогою команди `:MasonInstall yaml-language-server`. На цьому етапі ми матимемо, наприклад, контроль над кодом, написаним у заголовках (_frontmatter_) сторінок документації Rocky Linux.

#### null-ls.lua

Цей файл піклується про налаштування деяких функцій, спрямованих на керування та форматування написаного коду. Редагування цього файлу вимагає трохи більше досліджень для налаштування, ніж попередній файл. Огляд доступних компонентів можна знайти на [сторінці вбудованих компонентів](https://github.com/jose-elias-alvarez/null-ls.nvim/blob/main/doc/BUILTINS.md).

Знову ж таки, було створено таблицю, таблицю `локальних джерел`, куди ми можемо вводити свої налаштування, які ми можемо побачити нижче:

```lua
local sources = {

  -- webdev stuff
  b.formatting.deno_fmt,
  b.formatting.prettier.with { filetypes = { "html", "markdown", "css" } },
  -- Lua
  b.formatting.stylua,

  -- cpp
  b.formatting.clang_format,
}
```

Як ми бачимо, у початковій конфігурації були включені лише засоби форматування, але нам, наприклад, може знадобитися діагностика для мови Markdown, і в такому випадку ми можемо додати [Markdownlint](https://github.com/DavidAnson/markdownlint) так:

```lua
  -- diagnostic markdown
  b.diagnostics.markdownlint,
```

Знову ж таки, конфігурація потребує встановлення відповідного пакета, який ми завжди встановлюємо за допомогою _Mason_:

```text
:MasonInstall markdownlint
```

!!! note "Примітка"

    Конфігурація цього інструменту діагностики також вимагає створення файлу конфігурації у вашій домашній папці, про що в цьому документі не йдеться.

#### overrides.lua

Файл _overrides.lua_ містить зміни, які потрібно внести в налаштування плагіна за замовчуванням. Плагіни, до яких мають бути застосовані зміни, указано в розділі `-- override plugin configs` у файлі **custom/plugins.lua** через використання опції `opts` (наприклад, `opts = overrides.mason`).

У початковій конфігурації є три плагіни, позначені як такі, що потребують перевизначення, і це _treesitter_, _mason_ і _nvim-tree_. Наразі не згадуючи _nvim-tree_, ми зосередимося на перших двох, які дозволяють нам суттєво змінити досвід редагування.

_treesitter_ — це аналізатор коду, який інтерактивно піклується про його форматування. Кожного разу, коли ми зберігаємо файл, розпізнаний _treesitter_, він передається синтаксичному аналізатору, який повертає оптимально виділене дерево коду з відступами, тому його буде легше читати, інтерпретувати та редагувати код у редакторі.

Частина коду, яка це стосується, наступна:

```lua
M.treesitter = {
  ensure_installed = {
    "vim",
    "lua",
    "html",
    "css",
    "javascript",
    "typescript",
    "tsx",
    "c",
    "markdown",
    "markdown_inline",
  },
  indent = {
    enable = true,
    -- disable = {
    --   "python"
    -- },
  },
}
```

Тепер, дотримуючись прикладу, наведеного раніше, якщо ми хочемо, щоб _frontmatter_ наших сторінок документації про Rocky Linux було правильно виділено, ми можемо додати підтримку для *yaml* у таблиці `ensure_installed` після останнього набору аналізатора:

```text
    ...
    "tsx",
    "c",
    "markdown",
    "markdown_inline",
    "yaml",
    ...
```

Тепер, коли ми наступного разу відкриємо NvChad, аналізатор, який ми щойно додали, також буде автоматично встановлено.

Щоб мати доступ до аналізатора безпосередньо у запущеному екземплярі NvChad, ми завжди можемо встановити його, навіть не редагуючи файл, за допомогою команди:

```text
:TSInstall yaml
```

Далі у файлі є частина, яка стосується встановлення серверів _Mason_. Усі сервери, указані в цій таблиці, встановлюються за одну операцію за допомогою команди `:MasonInstallAll` (ця команда також викликається під час створення папки _custom_). Частина має наступний вигляд:

```lua
M.mason = {
  ensure_installed = {
    -- lua stuff
    "lua-language-server",
    "stylua",

    -- web dev stuff
    "css-lsp",
    "html-lsp",
    "typescript-language-server",
    "deno",
    "prettier"
  },
}
```

Знову ж таки, слідуючи початковому прикладу, де ми ввімкнули підтримку для _yaml_, встановивши сервер вручну, ми можемо переконатися, що він у нас завжди встановлений, додавши його до таблиці:

```text
    ...
    "typescript-language-server",
    "deno",
    "prettier",

    -- yaml-language-server
    "yaml-language-server",
    ...
```

Хоча цей аспект може бути незначним для запущеного екземпляра NvChad, оскільки ми завжди можемо вручну встановити відсутні сервери, він виявляється дуже корисним під час перенесення нашої конфігурації з однієї машини на іншу.

Наприклад, припустімо, що ми налаштували папку `custom` із усіма потрібними функціями та хочемо перенести її до іншої інсталяції NvChad. Якщо ми налаштували цей файл, після копіювання або клонування нашої папки `custom` `:MasonInstallAll` буде достатньо, щоб мати всі сервери, готові до використання в іншій установці.

Остання частина налаштування, розділ `M.nvimtree`, піклується про налаштування _nvim-tree_, увімкнувши функцію відображення стану в дерево файлів щодо репозиторію git:

```lua
  git = {
    enable = true,
  },
```

їх виділення та відповідні значки:

```lua
  renderer = {
    highlight_git = true,
    icons = {
      show = {
        git = true,
      },
    },
  },
```

## Висновок

Введення в NvChad 2.0 можливості створювати папку `custom` під час першого встановлення, безперечно, є великою підмогою для всіх тих користувачів, які вперше використовують цей редактор. Це також значна економія часу для тих, хто вже мав справу з NvChad.

Завдяки його представленню та використанню _Mason_ дуже легко та швидко інтегрувати власні функції. Потрібно лише внести кілька змін, і ви одразу готові використовувати IDE для написання коду.
