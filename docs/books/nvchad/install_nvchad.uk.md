---
title: Встановлення NvChad
author: Franco Colussi
contributors: Steven Spencer, Ganna Zhyrnova
tested_with: 8.7, 9.1
tags:
  - nvchad
  - coding
---

# Перетворення Neovim на просунутий IDE

## Передумови

Як зазначено на сайті NvChad, вам потрібно переконатися, що система відповідає таким вимогам:

- [Neovim 0.8.3](https://github.com/neovim/neovim/releases/tag/v0.8.3).
- [Шрифт Nerd](https://www.nerdfonts.com/) Установіть його в емуляторі терміналу.
  - Переконайтеся, що шрифт, який ви налаштували, не закінчується на **Mono**
   - **Приклад:** шрифт Iosevka Nerd, а не ~~Шрифт Iosevka Nerd Mono~~
- [Ripgrep](https://github.com/BurntSushi/ripgrep) потрібен для пошуку grep за допомогою Telescope **(НЕОБОВ’ЯЗКОВО)**.
- GCC

Насправді це не справжня «інсталяція», а скоріше написання спеціальної конфігурації Neovim для нашого користувача.

!!! warning «Виконання чистої інсталяції»

    Як зазначено у вимогах, встановлення цієї нової конфігурації поверх попередньої може створити проблеми, які неможливо виправити. Рекомендується чиста інсталяція.

### Попередні операції

Якщо ви раніше використовували інсталяцію Neovim, вона створить три папки для запису ваших файлів, а саме:

```text
~/.config/nvim
~/.local/share/nvim
~/.cache/nvim
```

Щоб виконати чисту інсталяцію конфігурації, нам потрібно спочатку створити резервну копію попередньої:

```bash
mkdir ~/backup_nvim
cp -r ~/.config/nvim ~/backup_nvim
cp -r ~/.local/share/nvim ~/backup_nvim
cp -r ~/.cache/nvim ~/backup_nvim
```

А потім видаляємо всі попередні конфігурації та файли:

```bash
rm -rf ~/.config/nvim
rm -rf ~/.local/share/nvim
rm -rf ~/.cache/nvim
```

Тепер, коли ми очистили, ми можемо переходити до встановлення NvChad.

Щоб зробити це, просто запустіть таку команду з будь-якого місця у вашому _домашньому каталозі_:

```bash
git clone https://github.com/NvChad/NvChad ~/.config/nvim --depth 1 && nvim
```

Перша частина команди клонує репозиторій NvChad до папки `~/.config/nvim`; це типовий шлях Neovim для пошуку конфігурації користувача. Параметр `--depth 1` наказує _git_ клонувати лише репозиторій, встановлений як «за замовчуванням» на GitHub.

Після завершення процесу клонування у другій частині команди викликається виконуваний файл Neovim (_nvim_), який, знайшовши папку конфігурації, почне імпортувати конфігурації, знайдені в його файли `init.lua` у попередньо визначеному порядку.

Перед початком початкового завантаження програма встановлення запропонує встановити базову структуру (_template chadrc_) для наших подальших налаштувань:

> Do you want to install chadrc template? (Бажаєте встановити шаблон chadrc?) (y/n):

Хоча вибір для встановлення рекомендованої структури не є обов’язковим, це однозначно рекомендується для тих, хто новачок у цьому редакторі. Поточні користувачі NvChad, які вже мають папку `custom`, зможуть її використовувати після внесення необхідних змін.

Структура, створена за допомогою шаблону, також використовуватиметься в цьому посібнику для розробки конфігурації для написання документів у Markdown.

Для тих, хто хоче дізнатися більше про цю тему перед початком встановлення, можна переглянути відповідну сторінку [Template Chadrc](template_chadrc.md).

Сторінка містить інформацію про структуру папки, яка буде створена, функції пов’язаних файлів та іншу корисну інформацію для налаштування NvChad.

На цьому етапі почнеться завантаження та конфігурація базових плагінів, а також, якщо ми вибрали інсталяцію шаблону, інсталяція налаштованого мовного сервера. Після завершення процесу наш редактор буде готовий до використання.

![Інсталяція](images/installed_first_time.png)

Як видно на скріншоті нижче, завдяки внесеним змінам конфігурації редактор повністю змінився на вигляд порівняно з базовою версією Neovim. Однак слід пам’ятати, що хоча конфігурація NvChad повністю трансформує редактор, основою залишається Neovim.

![NvChad Rockydocs](images/nvchad_ui.png)

### Структура конфігурації

Давайте тепер перейдемо до аналізу структури, створеної конфігурацією, яка виглядає наступним чином:

```text
.config/nvim
├── init.lua
├── lazy-lock.json
├── LICENSE
└── lua
    ├── core
    │   ├── bootstrap.lua
    │   ├── default_config.lua
    │   ├── init.lua
    │   ├── mappings.lua
    │   └── utils.lua
    └── plugins
        ├── configs
        │   ├── cmp.lua
        │   ├── lazy_nvim.lua
        │   ├── lspconfig.lua
        │   ├── mason.lua
        │   ├── nvimtree.lua
        │   ├── others.lua
        │   ├── telescope.lua
        │   ├── treesitter.lua
        │   └── whichkey.lua
        └── init.lua
```

І якщо ми вирішимо також встановити _шаблон chadrc_, ми також матимемо папку `nvim/lua/custom` із наступною структурою:

```text
.config/nvim/lua/custom/
├── chadrc.lua
├── configs
│   ├── lspconfig.lua
│   ├── null-ls.lua
│   └── overrides.lua
├── highlights.lua
├── init.lua
├── mappings.lua
└── plugins.lua
```


Перший файл, який ми зустрічаємо, це файл `init.lua`, який ініціалізує конфігурацію, вставляючи папку `lua/core` та `lua/core/utils.lua` (і якщо є, файли `lua/custom/init.lua`) у дерево _nvim_. Запускає завантажувальну програму `lazy.nvim` (менеджер плагінів) і після завершення ініціалізує папку `plugins`.

Зокрема, функція `load_mappings()` викликається для завантаження комбінацій клавіш. Крім того, функція `gen_chadrc_template()` надає підпрограму для створення папки `custom`.

```lua
require "core"

local custom_init_path = vim.api.nvim_get_runtime_file("lua/custom/init.lua", false)[1]

if custom_init_path then
  dofile(custom_init_path)
end

require("core.utils").load_mappings()

local lazypath = vim.fn.stdpath "data" .. "/lazy/lazy.nvim"

-- bootstrap lazy.nvim!
if not vim.loop.fs_stat(lazypath) then
  require("core.bootstrap").gen_chadrc_template()
  require("core.bootstrap").lazy(lazypath)
end

vim.opt.rtp:prepend(lazypath)
require "plugins"

dofile(vim.g.base46_cache .. "defaults")
```

Включення папки `core` також призводить до включення файлу `core/init.lua`, який замінює деякі конфігурації інтерфейсу Neovim і готує до керування буфером.

Як ми бачимо, кожен файл `init.lua` включено відповідно до добре встановленого порядку. Це використовується для вибіркового перевизначення різних параметрів із основних налаштувань. Загалом можна сказати, що файли `init.lua` мають функції для завантаження глобальних параметрів, autocmd або будь-чого іншого.

Це виклик, який повертає основні відображення команд:

```lua
require("core.utils").load_mappings()
```

Це встановлює чотири основні клавіші, за допомогою яких разом з іншими клавішами можна запускати команди. Основні ключі:

- C = <kbd>CTRL</kbd>
- leader = <kbd>ПРОБІЛ</kbd>
- A = <kbd>ALT</kbd>
- S = <kbd>SHIFT</kbd>

!!! note "примітка"

    Ми будемо посилатися на ці зіставлення ключів кілька разів у цих документах.

Відображення за замовчуванням міститься в _core/mapping.lua_, але його можна розширити за допомогою інших спеціальних команд за допомогою власного _mappings.lua_.

Деякі приклади стандартного відображення:

```text
<пробіл>, щоб змінити тему
<CTRL-n> щоб відкрити nvimtree
<ALT-i> щоб відкрити термінал у плаваючій вкладці
```

Існує багато попередньо встановлених комбінацій, які охоплюють усі можливості використання NvChad. Варто зупинитися, щоб проаналізувати зіставлення ключів, перш ніж почати використовувати свій екземпляр Neovim, налаштований за допомогою NvChad.

Продовжуючи структурний аналіз, ми знаходимо папку _lua/plugins_, яка містить налаштування вбудованих плагінів та їх конфігурації. Основні плагіни конфігурації будуть описані в наступному розділі. Як ми бачимо, папка _core/plugins_ також містить файл `init.lua`, який тут використовується для встановлення та подальшої компіляції плагінів.

Нарешті ми знаходимо файл `lazy-lock.json`. Цей файл дозволяє нам синхронізувати конфігурацію плагінів NvChad на кількох робочих станціях, щоб мати однакову функціональність на всіх використовуваних робочих станціях. Його функції буде краще пояснено в розділі, присвяченому менеджеру плагінів.
