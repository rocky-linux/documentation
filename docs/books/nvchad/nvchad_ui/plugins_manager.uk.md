---
title: Менеджер плагінів
author: Franco Colussi
contributors: Steven Spencer, Ganna Zhyrnova
tested_with: 8.7, 9.1
tags:
  - nvchad
  - coding
  - плагіни
---

# Менеджер плагінів

Керування плагінами в NvChad 2.0 здійснюється за допомогою [folke/lazy.nvim](https://github.com/folke/lazy.nvim), цей плагін установлюється під час першого встановлення з процедурою початкового завантаження. Плагін дозволяє виконувати всі типові операції з плагінами, такі як встановлення, оновлення тощо.

![Lazy Nvim](../images/lazy_nvim.png)

## :material-application-import: Основні особливості

- Управління всіма операціями над плагінами з єдиного інтерфейсу.
- Оптимізована продуктивність плагіна за рахунок кешування та компіляції байт-коду модуля Lua.
- Автоматична перевірка та встановлення відсутніх плагінів під час запуску, дуже корисна функція під час перенесення конфігурації з однієї машини на іншу.
- Профайлер для консультації щодо часу завантаження плагіна. Дозволяє відстежувати та усувати проблеми, спричинені несправними плагінами.
- Синхронізація плагінів на кількох робочих станціях шляхом збереження версій усіх встановлених плагінів у файлі *lazy-lock.json*.

## :material-arrow-bottom-right-bold-outline: Попередні операції

*lazy.nvim* інтегрує функцію перевірки працездатності середовища, яку можна викликати за допомогою команди `:checkhealth lazy`. Команда має повернути щось подібне до нового буфера:

```text
lazy: require("lazy.health").check()
========================================================================
## lazy.nvim
  - OK: Git installed
  - OK: no existing packages found by other package managers
  - OK: packer_compiled.lua not found
  - WARNING: {nvim-lspconfig}: overriding <config>
```

Хоча це і не обов’язково, перевірка середовища збірки перед тим, як ми почнемо працювати над нашою спеціальною конфігурацією, дозволяє нам виключити цю змінну з будь-яких помилок або несправностей, які можуть виникнути в самих плагінах або під час написання їхніх конфігурацій.

Також може бути цікаво переглянути вбудовану довідку, надану самим плагіном. Щоб відкрити його, ми можемо скористатися командою `:Lazy help` або викликати її з інтерфейсу плагіна, ввівши ++"?"++.

![Lazy Help](../images/lazy_help.png)

Довідка надає інформацію про навігацію інтерфейсом, елементами керування та їхніми функціями.

Тепер, перевіривши середовище та отримавши базові знання, ми можемо перейти до створення власної конфігурації. Мета полягає в тому, щоб додати функціональність до редактора, щоб задовольнити наші потреби, і оскільки це досягається шляхом включення плагінів у конфігурацію NvChad, ми почнемо з додавання плагіна.

## :material-location-enter: Вставити плагін

Хоча керування встановленими плагінами можна зручно виконувати з інтерфейсу *lazy.nvim*, вставлення нового плагіна потребує редагування файлу **lua/plugins/init.lua** вручну.

У цьому прикладі ми встановимо плагін [natecraddock/workspaces.nvim](https://github.com/natecraddock/workspaces.nvim). Цей плагін дозволяє зберігати та пізніше використовувати робочі сеанси (робочі області), щоб мати до них швидкий доступ. Відкриваємо файл за допомогою:

```bash
nvim ~/.config/nvim/lua/plugins/init.lua
```

і ми вставляємо наступний код після плагіна *better-escape.nvim*:

```lua
    -- Workspaces
    {
        "natecraddock/workspaces.nvim",
        cmd = { "WorkspacesList", "WorkspacesAdd", "WorkspacesOpen", "WorkspacesRemove" },
        config = function()
            require("workspaces").setup {
        hooks = {
            open = "Telescope find_files",
        },
      }
    end,
    },
```

Щойно файл буде збережено, ми отримаємо сповіщення з запитом на наше схвалення:

```text
# Config Change Detected. Reloading...

- **changed**: `lua/plugins/init.lua`
```

Це завдяки механізму, вбудованому в *lazy.nvim*, який перевіряє стан плагінів та їхні конфігурації, що дозволяє виконувати операції з плагінами без виходу з редактора.

Однозначно ми відповімо «так».

Тепер, якщо ми відкриємо менеджер плагінів за допомогою команди `:Lazy`, ми побачимо, що наш плагін розпізнано та готовий до встановлення. Щоб встановити його, просто введіть ++"I"++

![Встановити плагін](../images/lazy_install.png)

На цьому етапі *lazy.nvim* подбає про завантаження репозиторію в шляху **.local/share/nvim/lazy/** та виконання побудови. Після завершення встановлення ми матимемо нову папку під назвою *workspaces.nvim*:

```text
.local/share/nvim/lazy/workspaces.nvim/
├── CHANGELOG.md
├── doc
│   ├── tags
│   └── workspaces.txt
├── LICENSE
├── lua
│   ├── telescope
│   │   └── _extensions
│   │       └── workspaces.lua
│   └── workspaces
│       ├── init.lua
│       └── util.lua
├── README.md
└── stylua.toml
```

Тепер у нас буде функція плагіна, яку можна викликати за допомогою команд, налаштованих у масиві:

```lua
cmd = { "WorkspacesList", "WorkspacesAdd", "WorkspacesOpen", "WorkspacesRemove" },
```

Введення також передбачає додавання рядка до файлу *lazy-lock.json* для відстеження статусу та наступних оновлень. Функцію файлу *lazy-lock.json* буде описано у відповідному розділі нижче.

```json
  "workspaces.nvim": { "branch": "master", "commit": "dd9574c8a6fbd4910bf298fcd1175a0222e9a09d" },
```

## :material-tray-remove: Видалення плагіна

Як і під час інсталяції, для видалення плагіна з конфігурації потрібно вручну відредагувати файл *lua/plugins/init.lua*. Щоб наслідувати приклад, ми видалимо щойно встановлений плагін.

Відкриваємо наш редактор і видаляємо плагін з конфігурації. Це зручно зробити, вибравши рядки, які потрібно видалити, за допомогою миші, а потім натиснувши ++"x"++, щоб видалити їх, і ++ctrl++ + ++"s"++, щоб зберегти файл.

![Видалити плагін](../images/remove_plugin_01.png)

Ми знову отримаємо сповіщення про зміну файлу *init.lua*, на яке ми відповімо "так", і коли ми відкриємо *Lazy* наш плагін буде позначено як видалений. Видалення виконується натисканням клавіші ++"X"++.

![Lazy Clean](../images/remove_plugin_02.png)

Видалення плагіна в основному складається з видалення папки, створеної під час встановлення.

## Оновлення плагінів

Після встановлення та налаштування плагінів ними незалежно керує *lazy.nvim*. Щоб перевірити наявність оновлень, просто відкрийте менеджер і введіть ++"C"++. *Lazy* перевірить сховища встановлених плагінів (*git fetch*), а потім надасть нам список оновлюваних плагінів, які після перевірки можна оновити в одному перейдіть за допомогою ++"U"++ або окремо, вибравши їх за допомогою ++"u"++.

![Lazy Check](../images/lazy_check.png)

!!! note "Примітка"

    Навіть якщо їх немає на знімку екрана вище, якщо є плагіни з комітами, включаючи «небезпечні зміни», вони відображатимуться першими.

Існує також можливість запустити весь цикл оновлення лише за допомогою команди `Sync`. З інтерфейсу, ввівши ++"S"++ або команду `:Lazy sync`, ми викличемо функцію, яка складається з конкатенації `install` + `clean` + `update`.

Процес оновлення, окремо чи сукупно, також змінить файл *lazy-lock.json*. Зокрема, коміти будуть змінені для їх синхронізації зі станом репозиторію на GitHub.

## Додаткові можливості

Під час написання плагіна особливу увагу було приділено продуктивності та ефективності коду, а також щоб дати нам можливість оцінити час запуску різних плагінів. Нам надається *профайлер*, який можна викликати за допомогою команди `:Lazy profile` або за допомогою клавіші ++"P"++ в інтерфейсі.

![Lazy Profiler](../images/lazy_profile.png)

Тут ми можемо побачити час завантаження різних плагінів, які можна відсортувати за допомогою комбінації клавіш ++ctrl++ + ++"s"++ за записом конфігурації або часом завантаження. Ми також можемо шукати час завантаження плагінів, встановивши мінімальний поріг у мілісекундах за допомогою комбінації ++ctrl++ + ++"f"++.

Ця інформація може бути корисною для усунення несправностей, якщо редактор сповільнюється ненормально.

Плагін також надає відображення останніх операцій, виконаних над плагінами, дисплей, який можна викликати за допомогою клавіші ++"L"++ з інтерфейсу або за допомогою команди `:Lazy log` з самого редактору.

![Lazy Log](../images/lazy_log.png)

Він також інтегрує функцію налагодження, яка дозволяє нам перевіряти активні обробники відкладеного завантаження та те, що знаходиться в кеші модуля. Щоб активувати його, ми можемо скористатися клавішею ++"D"++ в інтерфейсі або викликати його за допомогою команди `:Lazy debug`.

![Lazy Debug](../images/lazy_debug.png)

## Синхронізація

Lazy.nvim дозволяє синхронізувати всі встановлені плагіни, зберігаючи їх стан у файлі *json*. У ньому створюється рядок для кожного плагіна, який містить назву папки, що відповідає встановленому плагіну, знайденому в **~/.local/share/nvim/lazy/**, відповідну гілку та комміт використовується для синхронізації зі сховища GitHub. Для цієї мети використовується файл `lazy-lock.json`, розташований у кореневій папці **~/.config/nvim**. Нижче ми можемо побачити уривок файлу:

```json
{
  "Comment.nvim": { "branch": "master", "commit": "8d3aa5c22c2d45e788c7a5fe13ad77368b783c20" },
  "LuaSnip": { "branch": "master", "commit": "025886915e7a1442019f467e0ae2847a7cf6bf1a" },
  "base46": { "branch": "v2.0", "commit": "eea1c3155a188953008bbff031893aa8cb0610e9" },
  "better-escape.nvim": { "branch": "master", "commit": "426d29708064d5b1bfbb040424651c92af1f3f64" },
  "cmp-buffer": { "branch": "main", "commit": "3022dbc9166796b644a841a02de8dd1cc1d311fa" },
  "cmp-nvim-lsp": { "branch": "main", "commit": "0e6b2ed705ddcff9738ec4ea838141654f12eeef" },
  "cmp-nvim-lua": { "branch": "main", "commit": "f3491638d123cfd2c8048aefaf66d246ff250ca6" },
  "cmp-path": { "branch": "main", "commit": "91ff86cd9c29299a64f968ebb45846c485725f23" },
  "cmp_luasnip": { "branch": "master", "commit": "18095520391186d634a0045dacaa346291096566" },
...
```

Завдяки виділеному сховищу ми можемо бачити стан плагіна в репозиторії під час встановлення чи оновлення. Це дозволяє нам за допомогою функції `restore` повернути його або повернути його до того самого стану також у редакторі. Функція, яку можна викликати за допомогою клавіші ++"R"++ з інтерфейсу або за допомогою `:Lazy restore`, оновлює всі плагіни в редакторі до стану, визначеного в *lazy-lock.json *.

Копіюючи файл *lazy-lock.json* зі стабільної конфігурації десь у безпечному місці, ми маємо можливість відновити редактор до цього стану, якщо оновлення викличе проблеми. Експортувавши його на іншу робочу станцію, ми можемо використовувати його для налаштування редактора з тією самою функціональністю.

Якщо натомість ми поставимо його під керування версіями, ми зможемо досягти синхронізації конфігурації між усіма робочими станціями, які ми використовуємо.

Тепер, проілюструвавши диспетчер плагінів, ми можемо перейти до аналізу інтерфейсу користувача.
