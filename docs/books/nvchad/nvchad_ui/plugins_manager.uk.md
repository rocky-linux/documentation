---
title: Менеджер плагінів
author: Franco Colussi
contributors: Steven Spencer, Ganna Zhyrnova
tested_with: 8.7, 9.1
tags:
  - nvchad
  - coding
  - плагіни
---

# Менеджер плагінів

Керування плагінами в NvChad 2.0 здійснюється за допомогою [folke/lazy.nvim](https://github.com/folke/lazy.nvim), цей плагін установлюється під час першого встановлення з процедурою початкового завантаження. Плагін дозволяє виконувати всі типові операції з плагінами, такі як встановлення, оновлення тощо.

![Lazy Nvim](../images/lazy_nvim.png)

## Основні особливості

- Управління всіма операціями над плагінами з єдиного інтерфейсу.
- Оптимізована продуктивність плагіна за рахунок кешування та компіляції байт-коду модуля Lua.
- Автоматична перевірка та встановлення відсутніх плагінів під час запуску, дуже корисна функція під час перенесення конфігурації з однієї машини на іншу.
- Профайлер для консультації щодо часу завантаження плагіна. Дозволяє відстежувати та усувати проблеми, спричинені несправними плагінами.
- Синхронізація плагінів на кількох робочих станціях шляхом збереження версій усіх встановлених плагінів у файлі _lazy-lock.json_.

## Попередні операції

_lazy.nvim_ інтегрує функцію перевірки працездатності середовища, яку можна викликати за допомогою команди `:checkhealth lazy`. Команда має повернути щось подібне до нового буфера:

```text
lazy: require("lazy.health").check()
========================================================================
## lazy.nvim
  - OK: Git installed
  - OK: no existing packages found by other package managers
  - OK: packer_compiled.lua not found
  - WARNING: {nvim-lspconfig}: overriding <config>
```

Хоча це і не обов’язково, перевірка середовища збірки перед тим, як ми почнемо працювати над нашою спеціальною конфігурацією, дозволяє нам виключити цю змінну з будь-яких помилок або несправностей, які можуть виникнути в самих плагінах або під час написання їхніх конфігурацій.

Також може бути цікаво переглянути вбудовану довідку, надану самим плагіном. Щоб відкрити його, ми можемо скористатися командою `:Lazy help` або викликати її з інтерфейсу плагіна, ввівши <kbd>?</kbd>.

![Lazy Help](../images/lazy_help.png)

Довідка надає інформацію про навігацію інтерфейсом, елементами керування та їхніми функціями.

Тепер, перевіривши середовище та отримавши базові знання, ми можемо перейти до створення власної конфігурації. Мета полягає в тому, щоб додати функціональність до редактора, щоб задовольнити наші потреби, і оскільки це досягається шляхом включення плагінів у конфігурацію NvChad, ми почнемо з додавання плагіна.

## Вставити плагін

!!! примітка

    У цих прикладах передбачається, що під час інсталяції NvChad ви вирішили створити структуру папок `custom` із _template chadrc_.

Хоча керування встановленими плагінами можна зручно виконувати з інтерфейсу _lazy.nvim_, щоб вставити новий плагін, потрібно вручну редагувати **custom /plugins.lua**.

У цьому прикладі ми встановимо плагін [natecraddock/workspaces.nvim](https://github.com/natecraddock/workspaces.nvim). Цей плагін дозволяє зберігати та пізніше використовувати робочі сеанси (робочі області), щоб мати до них швидкий доступ. Відкриваємо файл за допомогою:

```bash
nvim ~/.config/nvim/lua/custom/plugins.lua
```

і ми вставляємо наступний код після плагіна _better-escape.nvim_:

```lua
    -- Workspaces
    {
        "natecraddock/workspaces.nvim",
        cmd = { "WorkspacesList", "WorkspacesAdd", "WorkspacesOpen", "WorkspacesRemove" },
        config = function()
            require("workspaces").setup {
        hooks = {
            open = "Telescope find_files",
        },
      }
    end,
    },
```

Щойно файл буде збережено, ми отримаємо сповіщення з запитом на наше схвалення:

```text
# Config Change Detected. Reloading...

> - **changed**: `plugins.lua`
```

Це завдяки механізму, вбудованому в _lazy.nvim_, який перевіряє стан плагінів і їх конфігурації, що дозволяє виконувати операції з плагінами без необхідності виходити з редактора, операція, яка була необхідною з версією 1.0.

Однозначно ми відповімо «так».

Тепер, якщо ми відкриємо менеджер плагінів за допомогою команди `:Lazy`, ми побачимо, що наш плагін розпізнано та готовий до встановлення. Щоб встановити його, просто введіть <kbd>I</kbd>

![Встановити плагін](../images/lazy_install.png)

На цьому етапі _lazy.nvim_ подбає про завантаження репозиторію в шляху **.local/share/nvim /lazy/** і виконання побудови. Після завершення встановлення ми матимемо нову папку під назвою _workspaces.nvim_:

```text
.local/share/nvim/lazy/workspaces.nvim/
├── CHANGELOG.md
├── doc
│   ├── tags
│   └── workspaces.txt
├── LICENSE
├── lua
│   ├── telescope
│   │   └── _extensions
│   │       └── workspaces.lua
│   └── workspaces
│       ├── init.lua
│       └── util.lua
├── README.md
└── stylua.toml
```

Тепер у нас буде функція плагіна, яку можна викликати за допомогою команд, налаштованих у масиві:

```lua
cmd = { "WorkspacesList", "WorkspacesAdd", "WorkspacesOpen", "WorkspacesRemove" },
```

Введення також передбачає додавання рядка до файлу _lazy-lock.json_ для відстеження стану та наступних оновлень. Функцію файлу _lazy-lock.json_ буде описано у відповідному розділі нижче.

```json
  "workspaces.nvim": { "branch": "master", "commit": "dd9574c8a6fbd4910bf298fcd1175a0222e9a09d" },
```
## Видалення плагіна

Як і під час інсталяції, видалення плагіна з конфігурації також відбувається через ручне редагування файлу _custom/plugins.lua_. У цьому прикладі ми збираємося видалити плагін [TimUntersberger/neogit](https://github.com/TimUntersberger/neogit), цей плагін дозволяє керувати репозиторіями git безпосередньо з редактора.

!!! note "Примітка"

    Вибір плагіна є чисто випадковим. Плагін, використаний для прикладу, без проблем працює в NvChad.

Відкриваємо наш редактор і видаляємо плагін з конфігурації. Це зручно зробити, вибравши мишею чотири рядки, які потрібно видалити, а потім натиснувши <kbd>x</kbd>, щоб видалити їх, і <kbd>CTRL</kbd> + <kbd>s</kbd>, щоб зберегти файл.

![Видалити плагін](../images/remove_plugin_01.png)

Ми знову отримаємо сповіщення про зміну файлу _plugins.lua_, на яке ми відповімо "так", і коли ми відкриємо _Lazy_ наш плагін буде позначено як видалений. Видалення виконується натисканням клавіші <kbd>X</kbd>.

![Lazy Clean](../images/remove_plugin_02.png)

Видалення плагіна в основному складається з видалення папки, створеної під час встановлення.

## Оновлення плагінів

Після встановлення та налаштування плагінів ними незалежно керує _lazy.nvim_. Щоб перевірити наявність оновлень, просто відкрийте менеджер і введіть <kbd>C</kbd>. _Lazy_ перевірить сховища встановлених плагінів (_git fetch_), а потім надасть нам список оновлюваних додатків, які після позначення їх можна оновити одночасно за допомогою <kbd>U</kbd> або окремо, вибравши їх за допомогою <kbd>u</kbd>.

![Lazy Check](../images/lazy_check.png)

!!! note "Примітка"

    Навіть якщо їх немає на знімку екрана вище, якщо є плагіни з комітами, включаючи «небезпечні зміни», вони відображатимуться першими.

Існує також можливість запустити весь цикл оновлення лише за допомогою команди `Sync`. З інтерфейсу, ввівши <kbd>S</kbd> або команду `:Lazy sync`, ми викличемо функцію, яка складається з конкатенації `install` + `clean` + `update`.

Процес оновлення, окремо чи сукупно, також змінить файл _lazy-lock.json_. Зокрема, коміти будуть змінені для їх синхронізації зі станом репозиторію на GitHub.

## Додаткові можливості

Під час написання плагіна особливу увагу було приділено продуктивності та ефективності коду, а також щоб дати нам можливість оцінити час запуску різних плагінів. Нам надається _profiler_, який можна викликати командою `:Lazy profile` або клавішею <kbd>P</kbd> з інтерфейсу.

![Lazy Profiler](../images/lazy_profile.png)

Тут ми можемо побачити час завантаження різних плагінів, які можна сортувати за допомогою комбінації клавіш <knd>CTRL</kbd> + <kbd>s</kbd> за записом у конфігурації або за часом завантаження. У нас також є можливість здійснювати пошук за часом завантаження плагінів, встановлюючи мінімальний поріг у мілісекундах за допомогою комбінації <kbd>CTRL</kbd> + <kbd>f</kbd>.

Ця інформація може бути корисною для усунення несправностей, якщо редактор сповільнюється ненормально.

Додаток також надає відображення останніх операцій, виконаних у додатках, відображення, яке можна викликати за допомогою клавіші <kbd>L</kbd> з інтерфейсу або за допомогою команди `:Lazy log` від самого редактора.

![Lazy Log](../images/lazy_log.png)

Він також інтегрує функцію налагодження, яка дозволяє нам перевіряти активні обробники відкладеного завантаження та те, що знаходиться в кеші модуля. Щоб активувати його, ми можемо скористатися клавішею <kbd>D</kbd> в інтерфейсі або викликати його за допомогою команди `:Lazy debug`.

![Lazy Debug](../images/lazy_debug.png)

## Синхронізація

Lazy.nvim дозволяє синхронізувати всі встановлені плагіни, зберігаючи їх стан у файлі _json_. У ньому для кожного плагіна створюється рядок, який містить назву папки, що відповідає встановленому плагіну, знайденому в **~/.local/share/nvim/lazy/**, відповідну гілку та комміт, який використовується для синхронізації зі сховища GitHub. Для цієї мети використовується файл `lazy-lock.json`, розташований у кореневій папці **~/.config/nvim**. Нижче ми можемо побачити уривок файлу:

```json
{
  "Comment.nvim": { "branch": "master", "commit": "8d3aa5c22c2d45e788c7a5fe13ad77368b783c20" },
  "LuaSnip": { "branch": "master", "commit": "025886915e7a1442019f467e0ae2847a7cf6bf1a" },
  "base46": { "branch": "v2.0", "commit": "eea1c3155a188953008bbff031893aa8cb0610e9" },
  "better-escape.nvim": { "branch": "master", "commit": "426d29708064d5b1bfbb040424651c92af1f3f64" },
  "cmp-buffer": { "branch": "main", "commit": "3022dbc9166796b644a841a02de8dd1cc1d311fa" },
  "cmp-nvim-lsp": { "branch": "main", "commit": "0e6b2ed705ddcff9738ec4ea838141654f12eeef" },
  "cmp-nvim-lua": { "branch": "main", "commit": "f3491638d123cfd2c8048aefaf66d246ff250ca6" },
  "cmp-path": { "branch": "main", "commit": "91ff86cd9c29299a64f968ebb45846c485725f23" },
  "cmp_luasnip": { "branch": "master", "commit": "18095520391186d634a0045dacaa346291096566" },
...
```

Завдяки сховищу фіксації ми можемо точно бачити стан плагіна в репозиторії на момент встановлення чи оновлення. Це дозволяє нам за допомогою функції `restore` повернути його або повернути його до того самого стану також у редакторі. Функція, яку можна викликати за допомогою клавіші <kbd>R</kbd> з інтерфейсу або за допомогою `:Lazy restore`, оновлює всі додатки в редакторі до стану, визначеного в *файл lazy-lock.json*.

Копіюючи файл _lazy-lock.json_ зі стабільної конфігурації десь у безпечному місці, ми маємо можливість відновити редактор до такого стану, якщо оновлення викличе проблеми. Експортувавши його на іншу робочу станцію, ми можемо використовувати його для налаштування редактора з тією самою функціональністю.

Якщо натомість ми поставимо його під керування версіями, ми зможемо досягти синхронізації конфігурації між усіма робочими станціями, які ми використовуємо.

Тепер, проілюструвавши диспетчер плагінів, ми можемо перейти до аналізу інтерфейсу користувача.
