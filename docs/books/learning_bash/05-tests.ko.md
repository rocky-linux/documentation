---
title: Bash - 테스트
author: Antoine Le Morvan
contributors: Steven Spencer
tested_with: 8.5
tags:
  - 교육
  - bash 스크립팅
  - bash
---

# Bash - 테스트

****

**목적**: 이 문서에서는 다음을 수행하는 방법에 대해 알아볼 것 입니다:

:heavy_check_mark: 반환 코드 작업;  
:heavy_check_mark: 파일 테스트 및 비교;  
:heavy_check_mark: 테스트 변수, 문자열 및 정수;  
:heavy_check_mark: 숫자 정수로 작업을 수행.

:checkered_flag: **linux**, **스크립트**, **bash**, **변수**

**지식**: :star: :star:  
**복잡성**: :star: :star: :star:

**소요 시간**: 10 분

****

완료되면 셸에서 실행한 모든 명령은 **반환 코드**(**상태** 또는 **종료 코드**)</strong>를 반환합니다.

* 명령이 올바르게 실행된 경우 일반적으로 상태 코드는 **0**입니다.
* 명령 실행 중에 문제가 발생한 경우 상태 코드는 **non-zero 값**을 갖습니다. 여기에는 액세스 권한 부족, 파일 누락, 잘못된 입력 등 여러 가지 이유가 있습니다.

개발자가 제공하는 반환 코드의 다른 값을 알고 싶다면 `man 명령`의 매뉴얼을 참조해야 합니다.

반환 코드는 직접 볼 수 없지만 `$?`라는 특수 변수에 저장됩니다.

```
mkdir directory
echo $?
0
```

```
mkdir /directory
mkdir: unable to create directory
echo $?
1
```

```
command_that_does_not_exist
command_that_does_not_exist: command not found
echo $?
127
```


!!! 참고 사항

    `echo` 명령과 함께 `$?` 변수의 내용 표시는 평가하려는 명령 직후에 수행됩니다. 이 변수는 명령, 명령줄 또는 스크립트를 실행할 때마다 업데이트되기 때문입니다.

!!! 팁

    `$?`의 값은 명령어를 실행할 때마다 바뀌기 때문에 테스트나 메시지 출력을 위해 나중에 사용할 변수에 그 값을 넣어두는 것이 좋습니다.

    ```
    ls no_file
    ls: cannot access 'no_file': No such file or directory
    result=$?
    echo $?
    0
    echo $result
    2
    ```

스크립트에서 반환 코드를 생성하는 것도 가능합니다. 이렇게 하려면 `exit` 명령에 숫자 인수를 추가하기만 하면 됩니다.

```
bash # to avoid being disconnected after the "exit 2
exit 123
echo $?
123
```

명령의 올바른 실행 외에도 셸은 다양한 패턴에서 테스트를 실행할 수 있는 가능성을 제공합니다.

* **파일**: 존재, 유형, 권한, 비교;
* **문자열**: 길이, 비교;
* **숫자 정수**: 값, 비교.

테스트 결과:

* `$?=0` : 테스트가 올바르게 실행되었으며 참입니다.
* `$?=1` : 테스트가 올바르게 실행되었으며 거짓입니다.
* `$?=2` : 테스트가 올바르게 실행되지 않았습니다.

## 파일 유형 테스트

파일에 대한 `test` 명령 구문:

```
test [-d|-e|-f|-L] file
```

또는

```
[ -d|-e|-f|-L file ]
```

!!! 참고사항

    `[` 뒤와 `]` 앞에 공백이 있음에 유의하십시오.

파일에 대한 테스트 명령의 옵션:

| 옵션   | 관찰                                    |
| ---- | ------------------------------------- |
| `-e` | 파일이 존재하는지 테스트합니다.                     |
| `-f` | 파일이 존재하고 일반 유형인지 테스트합니다.              |
| `-d` | 파일이 존재하고 디렉토리 유형인지 확인합니다.             |
| `-L` | 파일이 존재하고 심볼릭 링크 유형인지 확인합니다.           |
| `-b` | 파일이 존재하고 특수 유형 블록 모드인지 확인합니다.         |
| `-c` | 파일이 존재하고 특수 유형 문자 모드인지 확인합니다.         |
| `-p` | 파일이 존재하고 튜브 유형인지 확인합니다.               |
| `-S` | 파일이 존재하고 소켓 유형인지 확인합니다.               |
| `-t` | 파일이 존재하고 터미널 유형인지 확인합니다.              |
| `-r` | 파일이 존재하고 읽을 수 있는지 확인                  |
| `-w` | 파일이 존재하고 쓰기 가능한지 확인합니다.               |
| `-x` | 파일이 존재하고 실행 가능한지 확인합니다.               |
| `-g` | 파일이 존재하고 SGID가 설정되어 있는지 확인합니다.        |
| `-u` | 파일이 존재하고 SUID가 설정되어 있는지 확인합니다.        |
| `-s` | 파일이 존재하고 비어 있지 않은지 테스트합니다(크기 > 0바이트). |

예시:

```
test -e /etc/passwd
echo $?
0
[ -w /etc/passwd ]
echo $?
1
```

더 현대적이고 외부 명령 `test`보다 더 많은 기능을 제공하는 일부 셸(bash 포함)에 대한 내부 명령이 생성되었습니다.

```
[[ -s /etc/passwd ]]
echo $?
1
```

!!! 참고사항

    따라서 이 장의 나머지 부분에서는 내부 명령을 사용합니다.

## 두 파일 비교

두 파일을 비교할 수도 있습니다.

```
[[ file1 -nt|-ot|-ef file2 ]]
```

| 옵션    | 관찰                              |
| ----- | ------------------------------- |
| `-nt` | 첫 번째 파일이 두 번째 파일보다 최신인지 테스트     |
| `-ot` | 첫 번째 파일이 두 번째 파일보다 오래된지 테스트합니다. |
| `-ef` | 첫 번째 파일이 두 번째 파일의 물리적 링크인지 테스트  |

## 테스트 변수

변수를 테스트할 수 있습니다.

```
[[ -z|-n $variable ]]
```

| 옵션   | 관찰                |
| ---- | ----------------- |
| `-z` | 변수가 비어 있는지 테스트    |
| `-n` | 변수가 비어 있지 않은지 테스트 |

## 문자열 테스트

두 문자열을 비교할 수도 있습니다.

```
[[ string1 =|!=|<|> string2 ]]
```

예시:

```
[[ "$var" = "Rocky rocks!" ]]
echo $?
0
```

| 옵션     | 관찰                                           |
| ------ | -------------------------------------------- |
| `=`    | 첫 번째 문자열이 두 번째 문자열과 같은지 테스트합니다.              |
| `!=`   | 첫 번째 문자열이 두 번째 문자열과 다른지 테스트합니다.              |
| `<` | ASCII 순서에서 첫 번째 문자열이 두 번째 문자열 앞에 있는지 테스트합니다. |
| `>` | 첫 번째 문자열이 ASCII 순서로 두 번째 문자열 뒤에 있는지 테스트합니다.  |

## 정수의 비교

정수 테스트 구문:

```
[[ "num1" -eq|-ne|-gt|-lt "num2" ]]
```

예시:

```
var=1
[[ "$var" -eq "1" ]]
echo $?
0
```

```
var=2
[[ "$var" -eq "1" ]]
echo $?
1
```

| 옵션    | 관찰                        |
| ----- | ------------------------- |
| `-eq` | 첫 번째 숫자가 두 번째 숫자와 같은지 테스트 |
| `-ne` | 첫 번째 숫자가 두 번째 숫자와 다른지 테스트 |
| `-gt` | 첫 번째 숫자가 두 번째 숫자보다 큰지 테스트 |
| `-lt` | 첫 번째 숫자가 두 번째보다 작은지 테스트   |

!!! 참고 사항

    숫자 값은 쉘에서 일반 문자(또는 문자열)로 처리되기 때문에 문자에 대한 테스트는 숫자로 처리되는지 여부에 관계없이 동일한 결과를 반환할 수 있습니다.

    ```
    test "1" = "1"
    echo $?
    0
    test "1" -eq "1"
    echo $?
    0
    ```


    그러나 테스트 결과는 동일한 의미를 갖지 않습니다.

    * 첫 번째 경우 두 문자가 ASCII 테이블에서 동일한 값을 갖는다는 의미입니다.
    * 두 번째 경우에는 두 숫자가 같음을 의미합니다.

## 결합된 테스트

테스트 조합을 사용하면 하나의 명령으로 여러 테스트를 수행할 수 있습니다. 동일한 인수(파일, 문자열 또는 숫자)를 여러 번 테스트하거나 다른 인수를 테스트할 수 있습니다.

```
[ option1 argument1 [-a|-o] option2 argument 2 ]
```

```
ls -lad /etc
drwxr-xr-x 142 root root 12288 sept. 20 09:25 /etc
[ -d /etc -a -x /etc ]
echo $?
0
```

| 옵션   | 관찰                               |
| ---- | -------------------------------- |
| `-a` | AND: 모든 패턴이 참이면 테스트가 참이 됩니다.     |
| `-o` | OR: 적어도 하나의 패턴이 참이면 테스트가 참이 됩니다. |


내부 명령을 사용하는 경우 다음 구문을 사용하는 것이 좋습니다.

```
[[ -d "/etc" && -x "/etc" ]]
```

테스트는 괄호 `(` `)`로 그룹화하여 우선 순위를 부여할 수 있습니다.

```
(TEST1 -a TEST2) -a TEST3
```

`!` 문자는 옵션에서 요청한 역 테스트를 수행하는 데 사용됩니다.

```
test -e /file # true if file exists
! test -e /file # true if file does not exist
```

## 수치 연산

`expr` 명령은 숫자 정수로 작업을 수행합니다.

```
expr num1 [+] [-] [\*] [/] [%] num2
```

예시:

```
expr 2 + 2
4
```

!!! 주의

    작업 표시를 공백으로 둘러싸도록 주의하십시오. 잊어버리면 오류 메시지가 표시됩니다.
    곱셈의 경우 잘못된 해석을 피하기 위해 와일드카드 문자 `*` 앞에 `\`가 옵니다.

| 옵션     | 관찰      |
| ------ | ------- |
| `+`    | 덧셈      |
| `-`    | 뺄셈      |
| `\*` | 곱셈      |
| `/`    | 나눗셈 몫   |
| `%`    | 나눗셈 모듈로 |


## `typeset` 명령

`typeset -i` 명령은 변수를 정수로 선언합니다.

예시:

```
typeset -i var1
var1=1+1
var2=1+1
echo $var1
2
echo $var2
1+1
```

## `let` 명령

`let` 명령은 문자가 숫자인지 테스트합니다.

예시:

```
var1="10"
var2="AA"
let $var1
echo $?
0
let $var2
echo $?
1
```

!!! 주의

    `let` 명령은 숫자 `0`을 평가할 때 일관된 반환 코드를 반환하지 않습니다.

    ```
    let 0
    echo $?
    1
    ```

`let` 명령을 사용하면 수학 연산도 수행할 수 있습니다.

```
let var=5+5
echo $var
10
```

`let`은 `$(( ))`로 대체될 수 있습니다.

```
echo $((5+2))
7
echo $((5*2))
10
var=$((5*3))
echo $var
15
```
