---
title: Запуск системи
---

# Запуск системи

У цьому розділі ви дізнаєтесь, як запускається система.

****
**Цілі**: у цьому розділі майбутні адміністратори Linux дізнаються про:

:heavy_check_mark: Різні етапи процесу завантаження;   
:heavy_check_mark: Як Rocky Linux підтримує це завантаження через GRUB2 і systemd;   
:heavy_check_mark: Як захистити GRUB2 від атаки;   
:heavy_check_mark: Як керувати послугами;   
:heavy_check_mark: Як отримати доступ до журналів з journald.

:checkered_flag: **користувачі**

**Знання**: :star: :star:   
**Складність**: :star: :star: :star:

**Час читання**: 20 хвилин
****

## Процес завантаження

Важливо розуміти процес завантаження Linux, щоб мати можливість вирішити проблеми, які можуть виникнути.

Процес завантаження включає:

### Запуск BIOS

**BIOS** (базова система вводу/виводу) виконує **POST** (самотестування при включенні), щоб виявити, протестувати та ініціалізувати апаратні компоненти системи.

Потім завантажується **MBR** (головний завантажувальний запис).

### Головний завантажувальний запис (MBR)

Головний завантажувальний запис — це перші 512 байт завантажувального диска. MBR виявляє завантажувальний пристрій і завантажує bootloader **GRUB2** у пам'ять і передає йому керування.

Наступні 64 байти містять таблицю розділів диска.

### GRUB2 bootloader

Bootloader за умовчанням для дистрибутива Rocky 8 є **GRUB2** (GRand Unified Bootloader). GRUB2 замінює старий завантажувач GRUB (також званий GRUB legacy).

Файл конфігурації GRUB 2 знаходиться під `/boot/grub2/grub.cfg`, але цей файл не слід редагувати безпосередньо.

Налаштування конфігурації меню GRUB2 розташовано в `/etc/default/grub` і використовуються для створення файлу `grub.cfg`.

```
# cat /etc/default/grub
GRUB_TIMEOUT=5
GRUB_DEFAULT=saved
GRUB_DISABLE_SUBMENU=true
GRUB_TERMINAL_OUTPUT="console"
GRUB_CMDLINE_LINUX="rd.lvm.lv=rhel/swap crashkernel=auto rd.lvm.lv=rhel/root rhgb quiet net.ifnames=0"
GRUB_DISABLE_RECOVERY="true"
```

Якщо внесено зміни до одного чи кількох із цих параметрів, необхідно запустити команду `grub2-mkconfig`, щоб повторно створити файл `/boot/grub2/grub.cfg`.

```
[root] # grub2-mkconfig –o /boot/grub2/grub.cfg
```

* GRUB2 шукає стислий образ ядра (файл `vmlinuz`) у каталозі `/boot`.
* GRUB2 завантажує образ ядра в пам’ять і витягує вміст файлу зображення `initramfs` у тимчасову папку в пам’яті за допомогою файлової системи `tmpfs`.

### Ядро

Ядро запускає процес `systemd` з PID 1.
```
root          1      0  0 02:10 ?        00:00:02 /usr/lib/systemd/systemd --switched-root --system --deserialize 23
```

### `systemd`

Systemd є батьківським для всіх системних процесів. Він зчитує посилання target-a `/etc/systemd/system/default.target` (наприклад, `/usr/lib/systemd/system/multi-user.target`) для визначення target системи за замовчуванням. Файл визначає служби, які потрібно запустити.

Потім Systemd переводить систему в стан target-defined, виконуючи наступні завдання ініціалізації:

1. Встановлення назви машини
2. Ініціалізація мережі
3. Ініціалізація SELinux
4. Відображення банера привітання
5. Ініціалізація апаратного забезпечення на основі аргументів, наданих ядру під час завантаження
6. Монтування файлових систем, включаючи віртуальні файлові системи, такі як /proc
7. Очищення каталогу в /var
8. Запуск віртуальної пам'яті (swap)

## Захист завантажувача GRUB2

Навіщо захищати завантажувач паролем?

1. Запобігання доступу до режиму *одного користувача* - якщо зловмисник може завантажитися в режимі одного користувача, він стає користувачем root.
2. Заборонити доступ до консолі GRUB. Якщо зловмиснику вдається скористатися консоллю GRUB, він може змінити її конфігурацію або зібрати інформацію про систему за допомогою команди `cat`.
3. Запобігання доступу до незахищених операційних систем. Якщо в системі є подвійне завантаження, зловмисник може вибрати під час завантаження операційну систему, наприклад DOS, яка ігнорує елементи керування доступом і дозволи на файли.

Щоб захистити паролем завантажувач GRUB2:

* Видаліть `-unrestricted` з основного оператора `CLASS=` у файлі `/etc/grub.d/10_linux`.

* Якщо користувача ще не налаштовано, скористайтеся командою `grub2-setpassword`, щоб надати пароль для користувача root:

```
# grub2-setpassword
```

Буде створено файл `/boot/grub2/user.cfg`, якщо його ще немає. Він містить хешований пароль GRUB2.

!!! Примітка

    Ця команда підтримує конфігурації лише з одним користувачем root.

```
[root]# cat /boot/grub2/user.cfg
GRUB2_PASSWORD=grub.pbkdf2.sha512.10000.CC6F56....A21
```

* Повторно створіть файл конфігурації за допомогою команди `grub2-mkconfig`:

```
[root]# grub2-mkconfig -o /boot/grub2/grub.cfg
Generating grub configuration file ...
Found linux image: /boot/vmlinuz-3.10.0-327.el7.x86_64
Found initrd image: /boot/initramfs-3.10.0-327.el7.x86_64.img
Found linux image: /boot/vmlinuz-0-rescue-f9725b0c842348ce9e0bc81968cf7181
Found initrd image: /boot/initramfs-0-rescue-f9725b0c842348ce9e0bc81968cf7181.img
done
```

* Перезапустіть сервер і перевірте.

Усі записи, визначені в меню GRUB, тепер вимагатимуть введення користувача та пароля під час кожного завантаження. Система не завантажить ядро без безпосереднього втручання користувача з консолі.

* Коли запитується користувач, введіть `root`;
* Коли запитується пароль, введіть пароль, наданий у команді `grub2-setpassword`.

Щоб захистити лише редагування пунктів меню GRUB і доступ до консолі, достатньо виконати команду `grub2-setpassword`. Можуть бути випадки, коли у вас є вагомі причини робити лише це. Це може бути особливо вірним у віддаленому центрі обробки даних, де введення пароля під час кожного перезавантаження сервера або важко, або неможливо.

## Systemd

*Systemd* — це менеджер служб для операційних систем Linux.

Він розроблений для:

* сумісництва зі старими сценаріями ініціалізації SysV,
* забезпечення багатьох функцій, наприклад, паралельний запуск системних служб під час запуску системи, активацію демонів на вимогу, підтримку моментальних знімків або керування залежностями між службами.

!!! Примітка

    Systemd є системою ініціалізації за замовчуванням, починаючи з RedHat/CentOS 7.

Systemd представляє концепцію системних одиниць.

| Тип          | Розширення файлу | Функціональність                              |
| ------------ | ---------------- | --------------------------------------------- |
| Service unit | `.service`       | Системний сервіс                              |
| Target unit  | `.target`        | Група системних одиниць                       |
| Mount unit   | `.automount`     | Автоматична точка монтування файлової системи |

!!! Важливо

    Існує багато типів юнітів (units): Device unit, Mount unit, Path unit, Scope unit, Slice unit, Snapshot unit, Socket unit, Swap unit, Timer unit.

* Systemd підтримує знімки стану системи та відновлення.

* Точки монтування можна налаштувати як systemd targets.

* Під час запуску systemd створює сокети прослуховування для всіх системних служб, які підтримують цей тип активації, і передає ці сокети цим службам, щойно вони запускаються. Це дає змогу перезапустити службу, не втрачаючи жодного повідомлення, надісланого до неї мережею під час її недоступності. Відповідний сокет залишається доступним, а всі повідомлення ставляться в чергу.

* Системні служби, які використовують D-BUS для зв’язку між процесами, можуть бути запущені на вимогу під час першого використання клієнтом.

* Systemd зупиняє або перезапускає лише запущені служби. Попередні версії (до RHEL7) намагалися зупинити служби напряму, не перевіряючи їх поточний статус.

* Системні служби не успадковують жодного контексту (наприклад, змінні середовища HOME та PATH). Кожна служба працює у власному контексті виконання.

Для всіх операцій сервісного блоку встановлено тайм-аут за замовчуванням у 5 хвилин, щоб запобігти зависанню системи через несправну службу.

### Управління системними службами

Службові блоки закінчуються розширенням файлу `.service` і мають подібне призначення до сценаріїв ініціалізації. Команда `systemctl` використовується для системних служб `display`, `start`, `stop`, `restart`:

| systemctl                                 | Опис                                         |
| ----------------------------------------- | -------------------------------------------- |
| systemctl start _name_.service            | Запускає службу                              |
| systemctl stop _name_.service             | Зупиняє служби                               |
| systemctl restart _name_.service          | Перезапускає службу                          |
| systemctl reload _name_.service           | Перезавантажує конфігурації                  |
| systemctl status _name_.service           | Перевіряє, чи працює служба                  |
| systemctl try-restart _name_.service      | Перезапускає служби, лише якщо вона запущена |
| systemctl list-units --type service --all | Відображає стан всіх послуг                  |

Команда `systemctl` також використовується для `ввімкнення (enable)` або `вимкнення (disable)` системної служби та відображення пов’язаних служб:

| systemctl                                | Опис                                                     |
| ---------------------------------------- | -------------------------------------------------------- |
| systemctl enable _name_.service          | Активує послуги                                          |
| systemctl disable _name_.service         | Вимикає служби                                           |
| systemctl list-unit-files --type service | Перелічує всі служби та перевіряє, чи вони запущені      |
| systemctl list-dependencies --after      | Перелічує служби, які починаються перед вказаним unit'om |
| systemctl list-dependencies --before     | Перелічує служби, які починаються після вказаного unit'a |

Приклади:

```
systemctl stop nfs-server.service
# or
systemctl stop nfs-server
```

Щоб отримати список усіх завантажених юнітів:

```
systemctl list-units --type service
```

Для перегляду списку усіх юнітів, щоб перевірити, чи вони активовані:

```
systemctl list-unit-files --type service
```

```
systemctl enable httpd.service
systemctl disable bluetooth.service
```

### Приклад файлу .service для служби postfix

```
postfix.service Unit File
Нижче наведено вміст файлу блоку /usr/lib/systemd/system/postfix.service, який зараз надається пакетом postfix:

[Unit]
Description=Postfix Mail Transport Agent
After=syslog.target network.target
Conflicts=sendmail.service exim.service

[Service]
Type=forking
PIDFile=/var/spool/postfix/pid/master.pid
EnvironmentFile=-/etc/sysconfig/network
ExecStartPre=-/usr/libexec/postfix/aliasesdb
ExecStartPre=-/usr/libexec/postfix/chroot-update
ExecStart=/usr/sbin/postfix start
ExecReload=/usr/sbin/postfix reload
ExecStop=/usr/sbin/postfix stop

[Install]
WantedBy=multi-user.target
```

### Використання системних таргетів (targets)

У Rocky8/RHEL8 концепцію рівнів запуску було замінено таргетами Systemd.

Таргети Systemd представлені target units. Target units закінчуються розширенням файлу `.target` і їхня єдина мета — групувати інші блоки Systemd у ланцюжок залежностей.

Наприклад, модуль `graphical.target`, який використовується для запуску графічного сеансу, запускає системні служби, такі як **менеджер відображення GNOME** (`gdm.service`) або **сервіс облікових записів** (`accounts-daemon.service`), а також активує блок `multi-user.target`.

Так само модуль `multi-user.target` запускає інші важливі системні служби, такі як **NetworkManager** (`NetworkManager.service`) або **D- Bus** (`dbus.service`) і активує іншу target unit під назвою `basic.target`.

| Target Units      | Опис                                                          |
| ----------------- | ------------------------------------------------------------- |
| poweroff.target   | Закриває систему та вимикає її                                |
| rescue.target     | Активує аварійну оболонку (rescue shell)                      |
| multi-user.target | Активує багатокористувацьку систему без графічного інтерфейсу |
| graphical.target  | Активує багатокористувацьку систему з графічним інтерфейсом   |
| reboot.target     | Вимикає та перезавантажує систему                             |

#### Target за умовчанням

Щоб визначити, який target використовується за замовчуванням:

```
systemctl get-default
```

Ця команда шукає target символічного посилання, розташованого за адресою `/etc/systemd/system/default.target`, і відображає результат.

```
$ systemctl get-default
graphical.target
```

Команда `systemctl` також може надати список доступних таргетів:

```
systemctl list-units --type target
UNIT                   LOAD   ACTIVE SUB    DESCRIPTION
basic.target           loaded active active Basic System
bluetooth.target       loaded active active Bluetooth
cryptsetup.target      loaded active active Encrypted Volumes
getty.target           loaded active active Login Prompts
graphical.target       loaded active active Graphical Interface
local-fs-pre.target    loaded active active Local File Systems (Pre)
local-fs.target        loaded active active Local File Systems
multi-user.target      loaded active active Multi-User System
network-online.target  loaded active active Network is Online
network.target         loaded active active Network
nss-user-lookup.target loaded active active User and Group Name Lookups
paths.target           loaded active active Paths
remote-fs.target       loaded active active Remote File Systems
slices.target          loaded active active Slices
sockets.target         loaded active active Sockets
sound.target           loaded active active Sound Card
swap.target            loaded active active Swap
sysinit.target         loaded active active System Initialization
timers.target          loaded active active Timers
```

Щоб налаштувати систему на використання іншого таргету за замовчуванням:

```
systemctl set-default name.target
```

Приклад:

```
# systemctl set-default multi-user.target
rm '/etc/systemd/system/default.target'
ln -s '/usr/lib/systemd/system/multi-user.target' '/etc/systemd/system/default.target'
```

Щоб переключитися на інший target unit в поточному сеансі:

```
systemctl isolate name.target
```

**Режим відновлення** забезпечує просте середовище для відновлення вашої системи у випадках, коли неможливо виконати нормальний процес завантаження.

У `режимі відновлення` система намагається змонтувати всі локальні файлові системи та запустити кілька важливих системних служб, але не вмикає мережевий інтерфейс і не дозволяє іншим користувачам підключатися до системи одночасно.

У Rocky 8 `режим порятунку` еквівалентний старому `режиму одного користувача` та потребує пароля root.

Щоб змінити поточний target і перейти в `режим відновлення` в поточному сеансі:

```
systemctl rescue
```

**Аварійний режим** забезпечує максимально мінімалістичне середовище та дозволяє відремонтувати систему навіть у ситуаціях, коли система не може перейти в режим відновлення. В аварійному режимі система монтує кореневу файлову систему лише для читання. Він не намагатиметься змонтувати будь-яку іншу локальну файлову систему, не активуватиме жодного мережевого інтерфейсу та запустить деякі важливі служби.

Щоб змінити поточний target і перейти в екстрений режим у поточному сеансі:

```
systemctl emergency
```

#### Вимкнення, призупинення та сплячий режим

Команда `systemctl` замінює кілька команд керування живленням, які використовувалися в попередніх версіях:

| Стара команда       | Нова команда             | Опис                                             |
| ------------------- | ------------------------ | ------------------------------------------------ |
| `halt`              | `systemctl halt`         | Призупиняє систему.                              |
| `poweroff`          | `systemctl poweroff`     | Вимикає систему.                                 |
| `reboot`            | `systemctl reboot`       | Перезавантажує систему.                          |
| `pm-suspend`        | `systemctl suspend`      | Призупиняє систему.                              |
| `pm-hibernate`      | `systemctl hibernate`    | Переводить систему в сплячий режим.              |
| `pm-suspend-hybrid` | `systemctl hybrid-sleep` | Переходить у сплячий режим і призупиняє систему. |

### Процес `journald`

Окрім `rsyslogd`, файлами журналу також може керувати демон `journald`, який є компонентом `systemd`.

Демон `journald` фіксує повідомлення системного журналу, повідомлення журналу ядра, повідомлення з початкового диска RAM і від початку завантаження, а також повідомлення, записані в стандартний вивід і стандартний вивід помилок усіх служб, а потім індексує їх і робить доступними для користувача.

Формат власного файлу журналу, який є структурованим і проіндексованим двійковим файлом, покращує пошук і забезпечує швидшу роботу, він також зберігає метадані, такі як мітки часу або ідентифікатори користувачів.

### Команда `journalctl`

Команда `journalctl` відображає файли журналу.

```
journalctl
```

Команда містить список усіх файлів журналу, згенерованих у системі. Структура цього виводу подібна до тієї, що використовується в `/var/log/messages/`, але пропонує деякі покращення:

* пріоритет записів позначається візуально;
* часові позначки перетворюються на місцевий часовий пояс вашої системи;
* відображаються всі зареєстровані дані, включаючи журнали, що обертаються;
* початок старту позначається спеціальною лінією.

#### Використання безперервного відображення

При постійному відображенні повідомлення журналу відображаються в режимі реального часу.

```
journalctl -f
```

Ця команда повертає список із десяти останніх рядків журналу. Потім утиліта journalctl продовжує працювати та чекає нових змін, перш ніж негайно їх відобразити.

#### Фільтрування повідомлень

Можна використовувати різні методи фільтрації для отримання інформації, яка відповідає різним потребам. Повідомлення журналу часто використовуються для відстеження помилкової поведінки в системі. Щоб переглянути записи з вибраним або вищим пріоритетом:

```
journalctl -p priority
```

Необхідно замінити пріоритет одним із таких ключових слів (або числом):

* debug (7),
* info (6),
* notice (5),
* warning (4),
* err (3),
* crit (2),
* alert (1),
* emerg (0).
