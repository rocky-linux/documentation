---
title: Впровадження мережі
---

# Впровадження мережі

У цьому розділі ви дізнаєтеся, як працювати з мережею та керувати нею.

****

**Цілі**: В цьому розділі ви дізнаєтеся як:

:heavy_check_mark: Налаштувати робочу станцію для використання DHCP;  
:heavy_check_mark: Налаштувати робочу станцію для використання статичної конфігурації;  
:heavy_check_mark: Налаштувати робочу станцію для використання шлюзу;  
:heavy_check_mark: Налаштувати робочу станцію для використання DNS-серверів;  
:heavy_check_mark: Виправлення неполадок мережі робочої станції.

:checkered_flag: **мережа**, **linux**, **ip**

**Знання**: :star: :star:  
**Складність**: :star: :star:

**Час читання**: 30 хвилин

****

## Загальні положення

Щоб проілюструвати цю главу, ми будемо використовувати наступну архітектуру.

![Ілюстрація архітектури нашої мережі](images/network-001.png)

Це дозволить нам розглянути:

* інтеграцію в LAN (локальна мережа);
* налаштування шлюзу для доступу до віддаленого сервера;
* конфігурацію DNS-сервера та реалізацію розпізнавання імен.

Мінімальні параметри, які необхідно визначити для машини:

* назва машини;
* iP адреса;
* маска підмережі.

Приклад:

* `pc-rocky`;
* `192.168.1.10`;
* `255.255.255.0`.

Все частіше зустрічається нотація під назвою CIDR: 192.168.1.10/24

IP-адреси використовуються для належної маршрутизації повідомлень (пакетів). Вони поділяються на дві частини:

* біт мережі - частина, пов'язана з послідовними «1» у двійковій масці підмережі
* біти хоста - частина, пов'язана з послідовними «0» у двійковій масці підмережі

```
                                            |<- host bits ->|
                  |<--    network bits  -->|
192.168.1.10  ==> 11000000.10101000.00000001.00001010
255.255.255.0 ==> 11111111.11111111.11111111.00000000
```

Маска підмережі використовується для визначення мережевих бітів і бітів хоста IP-адреси. Використовуючи маску підмережі, ми можемо визначити поточну IP-адресу:

* мережевої адреси (**NetID** або **SubnetID**), виконавши порозрядне логічне І між IP-адресою та маскою;
* адреси хоста (**HostID**), виконавши побітове логічне AND між IP-адресою та доповненням до маски.

```
192.168.1.10  ==> 11000000.10101000.00000001.00001010
255.255.255.0 ==> 11111111.11111111.11111111.00000000

NetID             11000000.10101000.00000001.00000000
                    192   . 168    . 1      . 0

HostID            00000000.00000000.00000000.00001010
                     0    .   0    .    0   . 10
```

**Законна маска підмережі** - Зліва направо послідовні 1 можна визначити як дійсні маски підмережі.

```
legitimate       11111111.11111111.11111111.00000000

illegitimate     11001001.11111111.11111111.00000000
```

!!! tip "Підказка"

    IP-адреса та маска підмережі повинні з'являтися парами, що визначається основними принципами мережевої комунікації.

У мережі також є конкретні адреси, які необхідно ідентифікувати. Перша адреса діапазону, а також остання мають певну роль:

* Перша адреса діапазону – це **адреса мережі**. Вона використовується для ідентифікації мереж і маршрутизації інформації з однієї мережі в іншу. Цю адресу можна отримати через Logic and Operations.

    ```
    192.168.1.10  ==> 11000000.10101000.00000001.00001010
    255.255.255.0 ==> 11111111.11111111.11111111.00000000

    network address   11000000.10101000.00000001.00000000
                        192   . 168    . 1      . 0
    ```

    **Logic and Operations** - Коли обидва значення є істинними (1), результат є істинним (1); в іншому випадку він є хибним (0)

* Остання адреса діапазону є **широкомовною адресою**. Вона використовується для трансляції інформації на всі машини в мережі. Збережіть біти мережі без змін і замініть всі біти хоста на 1, щоб отримати цю адресу.

    ```
    192.168.1.10  ==> 11000000.10101000.00000001.00001010
    255.255.255.0 ==> 11111111.11111111.11111111.00000000

    broadcast address 11000000.10101000.00000001.11111111
                        192   . 168    . 1      . 255
    ```

!!! tip "Підказка"

    Ці дві адреси, які відіграють особливу роль, **не можуть** бути призначені для використання термінальним пристроєм.

### MAC-адреса та IP-адреса

**MAC-адреса** – це фізичний ідентифікатор, записаний на заводі на пристрої. Це іноді називають апаратною адресою. Вона складається з 6 байтів, часто задаються у шістнадцятковій формі (наприклад, 5E:FF:56:A2:AF:15).

Ці 6 байтів відповідно представляють:

* Перші три байти представляють ідентифікатор виробника. Цей ідентифікатор називається OUI (унікальний ідентифікатор організації).
* Останні три байти містять серійний номер, призначений виробником.

!!! Warning "Увага"

    MAC-адреса жорстко закодована, коли обладнання залишає завод. Існує два основних способи його модифікації:

    * Модифікація на рівні прошивки (постійна): Потрібні розширені інструменти, які можуть безпосередньо перезаписувати MAC-адресу в ПЗП мережевої карти. Такі інструменти зазвичай доступні лише виробникам обладнання.
    * Програмне спуфінгування (тимчасове): змінює спосіб відображення MAC-адреси в операційній системі. Ці зміни зазвичай скидаються після перезавантаження системи. MAC-адреса віртуальної мережевої карти у віртуальному хості також підроблена.

Адреса Інтернет-протоколу (**IP**) — це ідентифікаційний номер, який постійно або тимчасово призначається кожному пристрою, підключеному до комп’ютерної мережі за допомогою Інтернет-протоколу. IP-адреса та маска підмережі повинні відображатися парами, що визначається основними принципами мережевого зв'язку. Через маску підмережі ми можемо дізнатися поточну IP-адресу:

* мережеві біти та біти хоста
* NetID або SubnetID
* HostID
* мережева адреса
* адреса розсилки

IP-адреси класифікуються на основі поля версії в пакеті наступним чином:

* **IPv4‌** - (4 біти, 0100). Доступний адресний простір IPv4 становить 2<sup>32</sup> (як зазначено в полях адрес джерела та призначення в пакетах IPv4). Зокрема, поділено на:

    * Адреса класу А. Його діапазон становить від **0.0.0.0** до **127.255.255.255**
    * Адреса класу B. Його діапазон становить від **128.0.0.0** до **191.255.255.255**
    * Адреса класу С. Його діапазон становить від **192.0.0.0** до **223.255.255.255**
    * Адреса класу D. Його діапазон становить від **224.0.0.0** до **239.255.255.255**
    * Адреса класу Е. Його діапазон становить від **240.0.0.0** до **255.255.255.255**

    Серед них адреси класу A, класу B та класу C мають власні приватні діапазони адрес. 0.0.0.0 – це зарезервована адреса, яка не призначається хосту. Адреси класу D використовуються для багатоадресного зв'язку та не призначаються хостам. Адреси класу E зарезервовані та не використовуються для звичайних мереж.

* **IPv6** - (4 біти, 0110). Доступна кількість IPv6 становить 2<sup>128</sup> (як зазначено в полях адрес джерела та призначення в пакетах IPv6). Зокрема, поділено на:

    * Одноадресна адреса. Включити адресу локальної одноадресної розсилки (LLA), унікальну локальну адресу (ULA), глобальну одноадресну адресу (GUA), адресу зворотного зв'язку, невизначену адресу
    * Адреса Anycast
    * Багатоадресна адреса

Опис формату запису для 128-бітного IPv6:

* Бажаний формат запису – **X:X:X:X:X:X:X:X:X**. У цьому форматі запису 128-бітні IPv6-адреси поділяються на вісім груп, кожна з яких представлена ​​чотирма шістнадцятковими значеннями (0-9, A-F), розділеними двокрапками (`:`) між групами. Кожен «X» представляє набір шістнадцяткових значень. Наприклад **2001:0db8:130F:0000:0000:09C0:876A:130B**.

    * Пропуск початкового 0 – Для зручності запису початковий «0» у кожній групі можна пропустити, щоб наведену вище адресу можна було скоротити як **2001:db8:130F:0:0:9C0:876A:130B**.
    * Використовуйте подвійну двокрапку – якщо адреса містить дві або більше послідовних груп, обидві з яких дорівнюють 0, можна використовувати подвійну двокрапку. Отже, вищевказану адресу можна скоротити як **2001:db8:130F::9C0:876A:130B**. Увага! Подвійна двокрапка може зустрічатися в IPv6-адресі лише один раз.

* Сумісний з форматами запису - **X:X:X:X:X:X:X:d.d.d.d**. У змішаному мережевому середовищі цей формат забезпечує сумісність між вузлами IPv6 та IPv4. Наприклад, **0:0:0:0:0:ffff:192.1.56.10** та **::ffff:192.1.56.10/96**.

У веб-адресі або URL-адресі (Uniform Resource Locator) IP-адреса може супроводжуватися двокрапкою та адресою порту (що вказує на програму, якій призначено дані). Також, щоб уникнути плутанини в URL-адресі, IPv6-адреса записується в квадратних дужках (наприклад, `[2001:db8:130F::9C0:876A:130B]:443`).

Як згадувалося раніше, маски підмережі поділяють IPv4-адреси на дві частини: мережеві біти та біти хоста. В IPv6 маски підмережі також мають ту саму функцію, але назва змінилася («n» позначає кількість бітів, зайнятих маскою підмережі):

* Мережевий префікс – еквівалент мережевих бітів в IPv4-адресі. Згідно з маскою підмережі, зайняти "n" бітів.
* Ідентифікатор інтерфейсу – еквівалентний бітам хоста в IPv4-адресі. Відповідно до маски підмережі, займайте "128-n" бітів.

Наприклад **2001:0db8:130F:0000:0000:09C0:876A:130B/64**：

```
    Network prefix
|<-    64 bits   ->|

                        Interface ID
                     |<-    64 bits    ->|
2001:0db8:130F:0000 : 0000:09C0:876A:130B
```

В одній мережі IP-адреси повинні бути унікальними, що є фундаментальним правилом мережевого зв'язку. В одній локальній мережі (LAN) MAC-адреса має бути унікальною.

### Структура IPv4-пакету

Пакети IPv4 містять як заголовок, так і дані:

![](./images/IPv4-packet.png)

**Версія**: Допомагає маршрутизаторам визначати версії протоколів. Для IPv4 значення тут дорівнює 0100 (двійкове число 0100 еквівалентне десятковій 4)

**IHL**: Поле, яке використовується для керування довжиною заголовка. Якщо поле «Параметри» не включено, мінімальне значення дорівнює 5 (а саме, двійкове число 0101). У цей час заголовок займає 20 байт. Максимальне значення становить 15 (а саме, двійкове число 1111), а заголовок має довжину 60 байт.

```
Фактична довжина заголовка IPv4 = значення поля IHL * 4
```

**Тип послуги**: Це поле використовується для визначення QoS (якості обслуговування) та пріоритету пакетів даних. Це поле зараз в основному використовується для DSCP (кодової точки диференційованих послуг) та ECN (явного сповіщення про перевантаження).

**Загальна довжина**: Представляє загальну довжину всієї дейтаграми IPv4 (пакета IPv4) у байтах.

!!! note "Примітка" 

    IP-пакет та IP-дейтаграма — це технічно різні терміни для одного й того ж поняття: одиниці даних, що передаються на мережевому рівні.

**Ідентифікація**: Ідентифікує всі фрагменти дейтаграми IPv4. Усі фрагменти з однієї й тієї ж оригінальної дейтаграми мають однакове значення ідентифікації для забезпечення правильної повторної збірки.

**Прапорці**: Використовується для керування поведінкою фрагментації датаграм IPv4. У порядку зліва направо:

* Перший біт - Не використовується, значення 0
* Другий біт – DF (Не фрагментувати). Якщо DF=1, дейтаграма IPv4 має бути передана повністю. Якщо значення MTU перевищує значення, його відкидають, і повертається помилка ICMP (наприклад, «Потрібна фрагментація»). Якщо DF=0, маршрутизатор розділяє датаграму IPv4 на кілька фрагментів, кожен з яких містить однакове значення поля ‌Ідентифікація‌.
* Третій біт - MF (More Fragment - Більше Фрагменту). Якщо MF=1, це означає, що поточний фрагмент не є останнім і є інші фрагменти; якщо MF=0, це означає, що це останній фрагмент.

**Зсув фрагмента**: Вказує відносне положення фрагмента в оригінальній дейтаграмі IPv4, в одиницях по 8 байтів. Це поле в основному використовується для повторного збірки фрагментів.

**TTL (час життя)**: це поле використовується для обмеження максимального часу життя або максимальної кількості переходів дейтаграм у мережі. Відправник встановлює початкове значення, і TTL зменшується на одиницю щоразу, коли він проходить через маршрутизатор. Коли TTL=0, дейтаграма відкидається.

**Протокол**: Вказує тип протоколу, який використовується даними, що передаються в цій дейтаграмі. Діапазон його значень становить від 0 до 255. Наприклад, номери протоколів для TCP, UDP та ICMP – це 6, 17 та 1 відповідно.

**Контрольна сума заголовка**: Це поле буде перераховуватися щоразу, коли дейтаграма проходить через маршрутизатор, головним чином через зменшення поля TTL, що призводить до змін у заголовку. Це поле перевіряє лише заголовок (за винятком частини з даними). Якщо інші поля залишаються незмінними, а змінюється лише значення TTL, контрольна сума буде оновлена ​​до нового значення (ненульового), щоб переконатися, що заголовок не був змінений або пошкоджений під час передачі.

**Адреса джерела**: IPv4-адреса відправника дейтаграми

**Адреса призначення**: IPv4-адреса одержувача дейтаграми

**Параметри**: Необов’язкове поле, довжина якого може змінюватися від 0 до 40 байт. Він використовується лише тоді, коли МГП перевищує 5. Довжина цього поля має бути цілим числом, кратним 4 байтам (якщо довжина менша за 4 байти, використовуйте поле **padding** для доповнення).

!!! tip "Підказка"

    Біт має два значення. В теорії інформації це стосується фундаментальної одиниці інформації, що представляє один бінарний вибір (0 або 1). В інформатиці це найменша одиниця зберігання даних; 8 бітів зазвичай дорівнюють 1 байту, якщо не зазначено інше.

### Структура IPv6-пакету

Датаграми IPv6 складаються з трьох частин:

* Базовий заголовок
* Заголовок розширення
* Блок даних протоколу верхнього рівня

У деяких книгах розширений заголовок та блок даних протоколу верхнього рівня разом називаються **корисним навантаженням**.

![](./images/IPv6-basic-header.png)

Фіксована довжина базового заголовка становить 40 байтів і містить 8 полів:

**Версія**: Допомагає маршрутизаторам визначати версії протоколів. Для IPv6 значення тут дорівнює 0110 (двійкове число 0110 еквівалентне десятковому числу 6).

**Клас трафіку**: Еквівалент поля TOS (тип послуги) в дейтаграмах IPv4. Це поле використовується для визначення QOS (якості обслуговування) та пріоритету пакетів даних.

**Мітка потоку**: Це нове поле IPv6 використовується для керування потоком пакетів. Ненульове значення в цьому полі вказує на те, що пакет слід обробляти особливим чином, тобто його не слід маршрутизувати різними шляхами для досягнення пункту призначення, а натомість використовувати той самий шлях. Перевагою цього є те, що одержувачу не потрібно повторно замовляти посилку, що пришвидшує процес. Це поле допомагає запобігти переупорядкуванню пакетів даних і спеціально розроблено для потокового медіа/медіа в реальному часі.

**Довжина корисного навантаження**: Вкажіть розмір корисного навантаження. Це поле може представляти лише корисне навантаження з максимальною довжиною 65535 байт. Якщо довжина корисного навантаження перевищує 65535 байт, поле довжини корисного навантаження встановлюється на 0, а в заголовку розширення опцій Hop-by-Hop використовується опція jumbo payload.

**Наступний заголовок**: Використовується для позначення типу заголовка пакета після базового заголовка. Якщо є перший заголовок розширення, він представляє тип першого заголовка розширення. В іншому випадку це означає тип протоколу, який використовується верхнім рівнем, наприклад, 6 (TCP) та 17 (UDP).

**Ліміт перехідного часу**: Це поле еквівалентне полю «Час життя» (TTL) у дейтаграмах IPv4.

**Адреса джерела**: Це поле відображає адресу відправника IPv6-дейтаграми.

**Адреса призначення**: Це поле відображає адресу одержувача дейтаграми IPv6.

![](.//images/IPv6-extension-header.png)

У дейтаграмах IPv4 заголовок IPv4 містить додаткові поля, такі як «Параметри», які включають «Безпека», «Мітка часу», «Маршрут запису» тощо. Ці параметри можуть збільшити довжину заголовка IPv4 з 20 до 60 байт. Під час пересилання обробка IPv4-дейтаграм, що містять ці опції, може споживати значні ресурси пристрою, тому вони рідко використовуються на практиці.

IPv6 видаляє ці параметри з базового заголовка IPv6 та поміщає їх у розширений заголовок, який розташований між базовим заголовком IPv6 та блоком даних протоколу верхнього рівня.

Пакет IPv6 може містити 0, 1 або кілька розширених заголовків, які додаються відправником лише тоді, коли пристрій або вузол призначення потребує спеціальної обробки.

На відміну від поля «Параметри IPv4» (яке може містити до 40 байтів і потребує безперервного зберігання), заголовок розширення IPv6 використовує ланцюгову структуру без обмеження фіксованої довжини, що робить його більш масштабованим у майбутньому. Його 8-байтовий механізм вирівнювання реалізовано через поле «Наступний заголовок», що забезпечує ефективну обробку та уникає накладних витрат на фрагментацію.

**Наступний заголовок**: Це поле має таку саму функцію, як і поле «Наступний заголовок» у базовому заголовку.

**Довжина заголовка розширення**: Вказує довжину заголовка розширення (без урахування наступного заголовка).

**Дані заголовка розширення**: Заголовок розширення складається з низки полів опцій та полів заповнення.

Наразі RFC визначає такі типи розширених заголовків:

* Заголовок Hop-by-Hop Options (значення поля наступного заголовка дорівнює 0) – має оброблятися всіма маршрутизаторами на шляху.
* Заголовок параметрів призначення (значення поля наступного заголовка – 60) – обробляється лише вузлом призначення.
* Заголовок маршрутизації (значення поля наступного заголовка – 43) – цей заголовок розширення схожий на параметри «Нещільне джерело» та «Маршрут запису» в IPv4.
* Заголовок фрагмента (значення поля наступного заголовка – 44) – як і у випадку з пакетами IPv4, довжина пакетів IPv6, що пересилаються, не може перевищувати максимальну одиницю передачі (MTU). Коли пакет перевищує MTU, його необхідно фрагментувати. В IPv6 заголовок Fragment використовується вузлом-джерелом IPv6 для надсилання пакета, розмір якого перевищує MTU.
* Заголовок автентифікації (значення наступного поля заголовка – 51) – IPSec використовує цей заголовок для забезпечення автентифікації походження даних, цілісності даних та захисту від повторного відтворення. Він також захищає деякі поля в базовому заголовку IPv6.
* Заголовок інкапсуляції корисного навантаження безпеки (значення поля наступного заголовка – 50) – цей заголовок виконує ті ж функції, що й заголовок автентифікації, а також шифрування пакетів IPv6.

RFC вказує, що коли в одній дейтаграмі використовується кілька розширених заголовків, рекомендується, щоб ці заголовки відображалися в такому порядку:

1. Базовий заголовок IPv6
2. Заголовок опцій по етапах
3. Заголовок параметрів призначення
4. Заголовок маршрутизації
5. Заголовок фрагмента
6. Заголовок автентифікації
7. Інкапсуляція заголовка Security Payload
8. Заголовок параметрів призначення
9. Заголовок протоколу верхнього рівня

За винятком заголовка Destination Option Header, який може з'являтися один або два рази (один раз перед заголовком Routing Extension та один раз перед заголовком Upper-layer protocol), усі інші заголовки розширення можуть зустрічатися лише один раз.

### Домен DNS

Клієнтські машини можуть бути частиною домену DNS (**система доменних імен**, наприклад, `mydomain.lan`).

Повне ім’я комп’ютера (**FQDN**) стає `pc-rocky.mydomain.lan`.

Набір комп’ютерів можна згрупувати в логічний набір із розпізнаванням імен, який називається доменом DNS. Домен DNS, звичайно, не обмежується однією фізичною мережею.

Щоб комп’ютер був частиною домену DNS, йому потрібно надати DNS-суфікс (тут `mydomain.lan`), а також сервери, до яких він може надсилати запити.

### Нагадування про модель OSI

!!! Note «Допоміжний засіб для запам'ятовування»

    Щоб запам’ятати порядок шарів моделі OSI, запам’ятайте таке речення: **Please Do Not Touch Steven's Pet Alligator**.

| Шар                      | Протоколи                                  |
| ------------------------ | ------------------------------------------ |
| 7 - Додаток              | POP, IMAP, SMTP, SSH, SNMP, HTTP, FTP, ... |
| 6 – Презентація          | ASCII, MIME, ...                           |
| 5 - Сеанс                | TLS, SSL, NetBIOS, ...                     |
| 4 - Транспорт            | TLS, SSL, TCP, UDP, ...                    |
| 3 - Мережа               | IPv4, IPv6, ARP, ...                       |
| 2 - Канал передачі даних | Ethernet, WiFi, Token Ring, ...            |
| 1 - Фізичний             | Кабелі, оптичні волокна, радіохвилі, ...   |

**Рівень 1** (фізичний) підтримує передачу через канал зв’язку (Wi-Fi, оптичне волокно, кабель RJ тощо). Одиниця: біт.

**Рівень 2** (канал даних) підтримує топологію мережі (токен-кільце, зірка, шина тощо), помилки поділу даних і передачі. Одиниця: фрейм.

**Рівень 3** (мережа) підтримує наскрізну передачу даних (IP-маршрутизація = шлюз). Одиниця: пакет.

**Рівень 4** (транспортний) підтримує тип служби (підключений або непідключений) шифрування та керування потоком. Одиниця: сегмент або дейтаграма.

**Рівень 5** (сеанс) підтримує зв’язок між двома комп’ютерами.

**Рівень 6** (Презентація) представляє область, яка не залежить від даних на прикладному рівні. По суті, цей рівень перетворює формати мережі та програми.

**Рівень 7** (додаток) представляє контакт із користувачем. Він надає послуги, які пропонує мережа: HTTP, DNS, FTP, IMAP, POP, SMTP тощо.

## Іменування інтерфейсів

*lo* — це інтерфейс "**loopback**", який дозволяє програмам TCP/IP спілкуватися одна з одною, не виходячи з локальної машини. Це дає змогу перевірити, чи **мережевий модуль системи працює належним чином**, а також дозволяє перевірити локальний хост. Усі пакети, які надходять через localhost, виходять через localhost. Отримані пакети – це надіслані пакети.

Ядро Linux призначає назви інтерфейсів із певним префіксом залежно від типу. Традиційно всі інтерфейси **Ethernet**, наприклад, починалися з **eth**. За префіксом йшло число, першим було 0 (eth0, eth1, eth2...). Інтерфейси Wi-Fi отримали префікс WLAN.

У дистрибутивах Rocky8 Linux systemd називатиме інтерфейси за новою такою політикою, де «X» означає число:

* `enoX`: бортові пристрої
* `ensX`: слот PCI Express для гарячого підключення
* `enpXsX`: фізичне/географічне розташування роз’єму обладнання
* ...

## Використання команди `ip`

Забудьте стару команду `ifconfig`! Є `ip`!

!!! Note "Примітка"

    Коментар для адміністраторів старих систем Linux:
    
    Історична команда керування мережею — `ifconfig`. Ця команда була замінена командою `ip`, яка вже добре відома адміністраторам мережі.
    
    Команда `ip` — це єдина команда для керування **IP-адресою, ARP, маршрутизацією тощо**.
    
    Команда `ifconfig` більше не встановлена за замовчуванням у Rocky8.
    
    Зараз важливо набути корисних звичок.

## Hostname

Команда `hostname` відображає або встановлює ім’я хоста системи

```bash
hostname [-f] [hostname]
```

| Опція | Опис                         |
| ----- | ---------------------------- |
| `-f`  | Відображає FQDN              |
| `-i`  | Відображає IP-адреси системи |

!!! Tip "Порада"

    Ця команда використовується різними мережевими програмами для ідентифікації машини.

Щоб призначити ім’я хоста, можна використати команду `hostname`, але зміни не будуть збережені під час наступного завантаження. Команда без аргументів відображає ім’я хоста.

Щоб установити ім’я хоста, потрібно змінити файл `/etc/sysconfig/network`:

```bash
NETWORKING=yes
HOSTNAME=pc-rocky.mondomaine.lan
```

Сценарій завантаження RedHat також звертається до файлу `/etc/hosts` для визначення імені хоста системи.

Коли система завантажується, Linux оцінює значення `HOSTNAME` у файлі `/etc/sysconfig/network`.

Потім він використовує файл `/etc/hosts` для оцінки основної IP-адреси сервера та імені його хоста. Він виводить доменне ім’я DNS.

Тому важливо заповнити ці два файли перед будь-яким налаштуванням мережевих служб.

!!! Tip "Порада"

    Щоб дізнатися, чи правильно виконано цю конфігурацію, команди `hostname` і `hostname -f` мають відповідати очікуваними значеннями.

## Файл /etc/hosts

Файл `/etc/hosts` — це статична таблиця зіставлення імен хостів, яка має такий формат:

```bash
@IP <hostname>  [alias]  [# comment]
```

Приклад файлу `/etc/hosts`:

```bash
127.0.0.1       localhost localhost.localdomain
::1             localhost localhost.localdomain
192.168.1.10    rockstar.rockylinux.lan rockstar
```

Файл `/etc/hosts` все ще використовується системою, особливо під час завантаження, коли визначається FQDN системи.

!!! Tip "Порада"

    Red Hat рекомендує заповнити принаймні один рядок із назвою системи.

Якщо служба **DNS** (**D**omain **N**ame **S**ervice) не працює, ви повинні заповнити всі імена у файлі hosts для кожної з ваших машин.

Файл `/etc/hosts` містить один рядок для кожного запису з IP-адресою, повним доменним ім’ям, потім іменем хоста (у такому порядку) та низкою псевдонімів (alias1, alias2 ...). Alias як опція.

## Файл `/etc/nsswitch.conf`

**NSS** (**N**ame **S**ervice **S**witch) дозволяє конфігураційні файли (наприклад, `/etc/ passwd`, `/etc/group`, `/etc/hosts`), щоб замінити одну або кілька централізованих баз даних.

Файл `/etc/nsswitch.conf` використовується для налаштування баз даних служби імен.

```bash
passwd: files
shadow: files
group: files

hosts: files dns
```

У цьому випадку Linux спочатку шукатиме відповідність імені хоста (рядок `hosts:`) у файлі `/etc/hosts` (значення `files`) перед запитом DNS (значення `dns`)! Цю поведінку можна просто змінити шляхом редагування файлу `/etc/nsswitch.conf`.

Звичайно, можна уявити запит до LDAP, MySQL або іншого сервера, налаштувавши службу імен для відповіді на системні запити для хостів, користувачів, груп тощо.

Роздільну здатність служби імен можна перевірити за допомогою команди `getent`, яку ми побачимо пізніше в цьому курсі.

## Файл `/etc/resolv.conf`

Файл `/etc/resolv.conf` містить конфігурацію розпізнавання імен DNS.

```bash
#Generated by NetworkManager
domain mondomaine.lan
search mondomaine.lan
nameserver 192.168.1.254
```

!!! Tip "Порада"

    Цей файл є історичним. Він більше не заповнюється безпосередньо!

Новіші покоління дистрибутивів зазвичай інтегрували службу `NetworkManager`. Ця послуга дозволяє більш ефективно керувати конфігурацією в графічному або консольному режимі.

Це дозволяє додавати DNS-сервери з файлу конфігурації мережевого інтерфейсу. Потім він динамічно заповнює файл `/etc/resolv.conf`, який ніколи не слід редагувати безпосередньо, інакше зміни конфігурації буде втрачено під час наступного запуску мережевої служби.

## Команда `ip`

Команда `ip` з пакету `iproute2` дозволяє налаштувати інтерфейс і його таблицю маршрутизації.

Відобразити інтерфейс:

```bash
[root]# ip link
```

Відображення інформації про інтерфейси:

```bash
[root]# ip addr show
```

Відображення інформації про інтерфейс:

```bash
[root]# ip addr show eth0
```

Відобразити таблицю ARP:

```bash
[root]# ip neigh
```

Усі історичні команди керування мережею згруповано під командою `ip`, яка добре відома адміністраторам мережі.

## Конфігурація DHCP

Протокол **DHCP** (**D**ynamic **H**ost **C**ontrol **P**rotocol) дозволяє отримати повну конфігурацію IP через мережу. Це стандартний режим конфігурації мережевого інтерфейсу в Rocky Linux, що пояснює, чому система, підключена до мережі Інтернет-маршрутизатора, може працювати без додаткового налаштування.

Конфігурація інтерфейсів у Rocky Linux виконується в папці `/etc/sysconfig/network-scripts/`.

Для кожного інтерфейсу Ethernet файл `ifcfg-ethX` дозволяє налаштувати відповідний інтерфейс.

```bash
DEVICE=eth0
ONBOOT=yes
BOOTPROTO=dhcp
HWADDR=00:0c:29:96:32:e3
```

* Назва інтерфейсу: (має бути в назві файлу)

```bash
DEVICE=eth0
```

* Автоматичний запуск інтерфейсу:

```bash
ONBOOT=yes
```

* Зробити запит DHCP під час запуску інтерфейсу:

```bash
BOOTPROTO=dhcp
```

* Вказати MAC-адресу (необов’язково, але корисно, коли є кілька інтерфейсів):

```bash
HWADDR=00:0c:29:96:32:e3
```

!!! Tip "Порада"

    Якщо встановлено NetworkManager, зміни враховуються автоматично. Якщо ні, потрібно перезапустити службу мережі.

* Перезапустити мережеву службу:

```bash
[root]# systemctl restart NetworkManager
```

## Статична конфігурація

Статична конфігурація вимагає принаймні:

```bash
DEVICE=eth0
ONBOOT=yes
BOOTPROTO=none
IPADDR=192.168.1.10
NETMASK=255.255.255.0
```

* Тут ми замінюємо «dhcp» на «none», що дорівнює статичній конфігурації:

```bash
BOOTPROTO=none
```

* IP-адреса:

```bash
IPADDR=192.168.1.10
```

* Маска підмережі:

```bash
NETMASK=255.255.255.0
```

* Маску можна вказати за допомогою префікса:

```bash
PREFIX=24
```

!!! Warning "Увага"

    Ви повинні використовувати МАСКУ МЕРЕЖІ АБО ПРЕФІКС – не обидва!

## Маршрутизація

![Архітектура мережі зі шлюзом](images/network-002.png)

```bash
DEVICE=eth0
ONBOOT=yes
BOOTPROTO=none
HWADDR=00:0c:29:96:32:e3
IPADDR=192.168.1.10
NETMASK=255.255.255.0
GATEWAY=192.168.1.254
```

Команда `ip route`:

```bash
[root]# ip route show
192.168.1.0/24 dev eth0 […] src 192.168.1.10 metric 1
default via 192.168.1.254 dev eth0 proto static
```

Варто знати, як читати таблицю маршрутизації, особливо в середовищі з кількома мережевими інтерфейсами.

* У наведеному прикладі мережа `192.168.1.0/24` доступна безпосередньо з пристрою `eth0`, тому є показник `1` (не проходить через маршрутизатор).

* Усі інші мережі, окрім попередньої, будуть доступні знову з пристрою `eth0`, але цього разу пакети будуть адресовані до шлюзу `192.168.1.254`. Протокол маршрутизації є статичним протоколом (хоча в Linux можна додати маршрут до динамічно призначеної адреси).

## Роздільна здатність імен

Система повинна вирішити:

* FQDN в IP-адреси

```bash
www.free.fr = 212.27.48.10
```

* IP-адреси в іменах

```bash
212.27.48.10 = www.free.fr
```

* або отримати інформацію про ділянку:

```bash
MX de free.fr = 10 mx1.free.fr + 20 mx2.free.fr
```

```bash
DEVICE=eth0
ONBOOT=yes
BOOTPROTO=none
HWADDR=00:0c:29:96:32:e3
IPADDR=192.168.1.10
NETMASK=255.255.255.0
GATEWAY=192.168.1.254
DNS1=172.16.1.2
DNS2=172.16.1.3
DOMAIN=rockylinux.lan
```

У цьому випадку, щоб отримати доступ до DNS, вам потрібно пройти через шлюз.

```bash
 #Generated by NetworkManager
 domain mondomaine.lan
 search mondomaine.lan
 nameserver 172.16.1.2
 nameserver 172.16.1.3
```

Файл оновлено за допомогою NetworkManager.

## Вирішення проблем

Команда `ping` надсилає дейтаграми на іншу машину та очікує на відповідь.

Це основна команда для тестування мережі, оскільки вона перевіряє зв’язок між вашим мережевим інтерфейсом та іншим.

Синтаксис команди `ping`:

```bash
ping [-c numerical] destination
```

Параметр `-c` (count) дозволяє зупинити команду після зворотного відліку за секунди.

Приклад:

```bash
[root]# ping –c 4 localhost
```

!!! Tip "Порада"

    Перевірте підключення від близького до далекого

1. Перевірте програмний рівень TCP/IP

    ```bash
    [root]# ping localhost
    ```

    «Пінгування» внутрішнього циклу не виявляє апаратну несправність мережевого інтерфейсу. Він просто визначає, чи правильна конфігурація програмного забезпечення IP.

2. Перевірте мережеву карту

    ```bash
    [root]# ping 192.168.1.10
    ```

    Щоб визначити функціональність мережевої карти, ми повинні перевірити її IP-адресу. Якщо мережевий кабель не підключений до мережевої карти, він повинен бути в стані «вимкнено».

    Якщо перевірка ping не працює, спочатку перевірте мережевий кабель до мережевого комутатора та повторно зберіть інтерфейс (див. команду `if up`), а потім перевірте сам інтерфейс.

3. Перевірте підключення шлюзу

    ```bash
    [root]# ping 192.168.1.254
    ```

4. Перевірте підключення віддаленого сервера

    ```bash
    [root]# ping 172.16.1.2
    ```

5. Перевірте службу DNS

    ```bash
    [root]# ping www.free.fr
    ```

### Команда `dig`

Команда `dig` використовується для запиту до сервера DNS.

Синтаксис команди `dig`:

```bash
dig [-t type] [+short] [name]
```

Приклади:

```bash
[root]# dig +short rockylinux.org
76.223.126.88
[root]# dig -t MX +short rockylinux.org                                                          ✔
5 alt1.aspmx.l.google.com.
...
```

Команда `dig` використовується для запиту до серверів DNS. За замовчуванням він багатослівний, але параметр `+short` може змінити цю поведінку.

Також можна вказати **тип запису** DNS для вирішення, наприклад **тип** MX, щоб отримати інформацію про обмінники поштою для домену.

### Команда `getent`

Команда `getent` (отримати запис) отримує запис NSSwitch (`hosts` + `dns`)

Синтаксис команди `getent`:

```bash
getent hosts name
```

Приклад:

```bash
[root]# getent hosts rockylinux.org
  76.223.126.88 rockylinux.org
```

Запит лише до DNS-сервера може повернути помилковий результат, який не враховує вміст файлу `hosts`, хоча сьогодні це має бути рідкістю.

Щоб врахувати файл `/etc/hosts`, потрібно надіслати запит до служби імен NSSwitch, яка подбає про будь-яке вирішення DNS.

### Команда `ipcalc`

Команда `ipcalc` (**IP-обчислення**) обчислює адресу мережі або широкомовлення на основі IP-адреси та маски.

Синтаксис команди `ipcalc`:

```bash
ipcalc  [options] IP <netmask>
```

Приклад:

```bash
[root]# ipcalc –b 172.16.66.203 255.255.240.0
BROADCAST=172.16.79.255
```

!!! Tip "Порада"

    Цікава ця команда, після якої слідує перенаправлення для автоматичного заповнення конфігураційних файлів ваших інтерфейсів:

    ```
    [root]# ipcalc –b 172.16.66.203 255.255.240.0 >> /etc/sysconfig/network-scripts/ifcfg-eth0
    ```

| Опція | Опис                                 |
| ----- | ------------------------------------ |
| `-b`  | Відображає широкомовну адресу.       |
| `-n`  | Відображає мережеву адресу та маску. |

`ipcalc` — це простий спосіб обчислення IP-інформації про хост. Параметри вказують, яку інформацію `ipcalc` має відображати на стандартному виводі. Ви можете вказати кілька варіантів. Ви повинні вказати IP-адресу для роботи. Для більшості операцій також потрібна маска мережі або префікс CIDR.

| Коротка опція | Довша опція   | Опис                                                                                                                                                                                                                                 |
| ------------- | ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `-b`          | `--broadcast` | Відображає широкомовну адресу заданої IP-адреси та маску мережі.                                                                                                                                                                     |
| `-h`          | `--hostname`  | Відображає ім’я хоста IP-адреси, наданої через DNS.                                                                                                                                                                                  |
| `-n`          | `--netmask`   | Обчислює маску мережі для заданої IP-адреси. Припускає, що IP-адреса є частиною повної мережі класу A, B або C. Багато мереж не використовують мережеві маски за замовчуванням, у цьому випадку буде повернено неправильне значення. |
| `-p`          | `--prefix`    | Вказує на префікс маски/IP-адреси.                                                                                                                                                                                                   |
| `-n`          | `--network`   | Вказує мережеву адресу заданої IP-адреси та маски.                                                                                                                                                                                   |
| `-s`          | `--silent`    | Не відображає жодних повідомлень про помилки.                                                                                                                                                                                        |

### Команда `ss`

Команда `ss` (**статистика сокета**) відображає прослуховувані порти в мережі.

Синтаксис команди `ss`:

```bash
ss [-tuna]
```

Приклад:

```bash
[root]# ss –tuna
tcp   LISTEN   0   128   *:22   *:*
```

Команди `ss` і `netstat` (для наступних) будуть дуже важливими для решти вашого життя Linux.

Під час впровадження мережевих служб зазвичай перевіряють одну з цих двох команд, що служба прослуховує очікувані порти.

### Команда `netstat`

!!! Warning "Увага"

    Команда `netstat` тепер застаріла та більше не встановлюється за замовчуванням у Rocky Linux. Ви все ще можете знайти деякі версії Linux, у яких він встановлений, але найкраще переходити до використання `ss` для всього, для чого ви використовували `netstat`.

Команда `netstat` (**статистика мережі**) відображає порти прослуховування в мережі.

Синтаксис команди `netstat`:

```bash
netstat -tapn
```

Приклад:

```bash
[root]# netstat –tapn
tcp  0  0  0.0.0.0:22  0.0.0.0:*  LISTEN 2161/sshd
```

### Конфлікти IP- або MAC-адрес

Неправильна конфігурація може спричинити використання однієї IP-адреси кількома інтерфейсами. Це може статися, якщо в мережі є кілька серверів DHCP або одна і та сама IP-адреса багато разів призначається вручну.

Якщо мережа не працює, і коли причиною може бути конфлікт IP-адрес, можна використати програмне забезпечення `arp-scan` (потрібне сховище EPEL):

```bash
dnf install arp-scan
```

Приклад:

```bash
$ arp-scan -I eth0 -l

172.16.1.104  00:01:02:03:04:05       3COM CORPORATION
172.16.1.107  00:0c:29:1b:eb:97       VMware, Inc.
172.16.1.250  00:26:ab:b1:b7:f6       (Unknown)
172.16.1.252  00:50:56:a9:6a:ed       VMWare, Inc.
172.16.1.253  00:50:56:b6:78:ec       VMWare, Inc.
172.16.1.253  00:50:56:b6:78:ec       VMWare, Inc. (DUP: 2)
172.16.1.253  00:50:56:b6:78:ec       VMWare, Inc. (DUP: 3)
172.16.1.253  00:50:56:b6:78:ec       VMWare, Inc. (DUP: 4)
172.16.1.232  88:51:fb:5e:fa:b3       (Unknown) (DUP: 2)
```

!!! Tip "Порада"

    Як показує наведений вище приклад, конфлікти MAC-адрес можливі! Технології віртуалізації та копіювання віртуальних машин викликають ці проблеми.

## Гаряча конфігурація

Команда `ip` може швидко додати IP-адресу до інтерфейсу.

```bash
ip addr add @IP dev DEVICE
```

Приклад:

```bash
[root]# ip addr add 192.168.2.10 dev eth1
```

Команда `ip` дозволяє активувати або деактивувати інтерфейс:

```bash
ip link set DEVICE up
ip link set DEVICE down
```

Приклад:

```bash
[root]# ip link set eth1 up
[root]# ip link set eth1 down
```

Команда `ip` додає маршрут:

```bash
ip route add [default|netaddr] via @IP [dev device]
```

Приклад:

```bash
[root]# ip route add default via 192.168.1.254
[root]# ip route add 192.168.100.0/24 via 192.168.2.254 dev eth1
```

## Коротко

У цьому розділі використовуються такі файли:

![Синтез файлів, реалізований в мережевій частині](images/network-003.png)

Повна конфігурація інтерфейсу може бути такою (файл `/etc/sysconfig/network-scripts/ifcfg-eth0`):

```bash
 DEVICE=eth0
 ONBOOT=yes
 BOOTPROTO=none
 HWADDR=00:0c:29:96:32:e3
 IPADDR=192.168.1.10
 NETMASK=255.255.255.0
 GATEWAY=192.168.1.254
 DNS1=172.16.1.1
 DNS2=172.16.1.2
 DOMAIN=rockylinux.lan
```

Метод усунення несправностей має йти від найближчого до найдальшого:

1. ping localhost (software test)
2. ping IP-address (hardware test)
3. ping gateway (connectivity test)
4. ping remote server (routing test)
5. DNS query (dig або ping)

![Спосіб усунення несправностей або перевірка мережі](images/network-004.png)
