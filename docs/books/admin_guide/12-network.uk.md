---
title: Впровадження мережі
---

# Впровадження мережі

У цьому розділі ви дізнаєтеся, як працювати з мережею та керувати нею.

****

**Цілі**: В цьому розділі ви дізнаєтеся як:

:heavy_check_mark: Налаштувати робочу станцію для використання DHCP;  
:heavy_check_mark: Налаштувати робочу станцію для використання статичної конфігурації;  
:heavy_check_mark: Налаштувати робочу станцію для використання шлюзу;  
:heavy_check_mark: Налаштувати робочу станцію для використання DNS-серверів;  
:heavy_check_mark: Виправлення неполадок мережі робочої станції.

:checkered_flag: **мережа**, **linux**, **ip**

**Знання**: :star: :star:  
**Складність**: :star: :star:

**Час читання**: 30 хвилин

****

## Загальні положення

Щоб проілюструвати цю главу, ми будемо використовувати наступну архітектуру.

![Ілюстрація архітектури нашої мережі](images/network-001.png)

Це дозволить нам розглянути:

* інтеграцію в LAN (локальна мережа);
* налаштування шлюзу для доступу до віддаленого сервера;
* конфігурацію DNS-сервера та реалізацію розпізнавання імен.

Мінімальні параметри, які необхідно визначити для машини:

* назва машини;
* iP адреса;
* маска підмережі.

Приклад:

* `pc-rocky`;
* `192.168.1.10`;
* `255.255.255.0`.

Все частіше зустрічається нотація під назвою CIDR: 192.168.1.10/24

IP-адреси використовуються для належної маршрутизації повідомлень (пакетів). Вони поділяються на дві частини:

* біт мережі - частина, пов'язана з послідовними «1» у двійковій масці підмережі
* біти хоста - частина, пов'язана з послідовними «0» у двійковій масці підмережі

```
                                            |<- host bits ->|
                  |<--    network bits  -->|
192.168.1.10  ==> 11000000.10101000.00000001.00001010
255.255.255.0 ==> 11111111.11111111.11111111.00000000
```

Маска підмережі використовується для визначення мережевих бітів і бітів хоста IP-адреси. Використовуючи маску підмережі, ми можемо визначити поточну IP-адресу:

* мережевої адреси (**NetID** або **SubnetID**), виконавши порозрядне логічне І між IP-адресою та маскою;
* адреси хоста (**HostID**), виконавши побітове логічне AND між IP-адресою та доповненням до маски.

```
192.168.1.10  ==> 11000000.10101000.00000001.00001010
255.255.255.0 ==> 11111111.11111111.11111111.00000000

NetID             11000000.10101000.00000001.00000000
                    192   . 168    . 1      . 0

HostID            00000000.00000000.00000000.00001010
                     0    .   0    .    0   . 10
```

**Законна маска підмережі** - Зліва направо послідовні 1 можна визначити як дійсні маски підмережі.

```
legitimate       11111111.11111111.11111111.00000000

illegitimate     11001001.11111111.11111111.00000000
```

!!! tip "Підказка"

    IP-адреса та маска підмережі повинні з'являтися парами, що визначається основними принципами мережевої комунікації.

У мережі також є конкретні адреси, які необхідно ідентифікувати. Перша адреса діапазону, а також остання мають певну роль:

* Перша адреса діапазону – це **адреса мережі**. Вона використовується для ідентифікації мереж і маршрутизації інформації з однієї мережі в іншу. Цю адресу можна отримати через Logic and Operations.

    ```
    192.168.1.10  ==> 11000000.10101000.00000001.00001010
    255.255.255.0 ==> 11111111.11111111.11111111.00000000

    network address   11000000.10101000.00000001.00000000
                        192   . 168    . 1      . 0
    ```

    **Logic and Operations** - Коли обидва значення є істинними (1), результат є істинним (1); в іншому випадку він є хибним (0)

* Остання адреса діапазону є **широкомовною адресою**. Вона використовується для трансляції інформації на всі машини в мережі. Збережіть біти мережі без змін і замініть всі біти хоста на 1, щоб отримати цю адресу.

    ```
    192.168.1.10  ==> 11000000.10101000.00000001.00001010
    255.255.255.0 ==> 11111111.11111111.11111111.00000000

    broadcast address 11000000.10101000.00000001.11111111
                        192   . 168    . 1      . 255
    ```

!!! tip "Підказка"

    Ці дві адреси, які відіграють особливу роль, **не можуть** бути призначені для використання термінальним пристроєм.

### MAC-адреса та IP-адреса

**MAC-адреса** – це фізичний ідентифікатор, записаний на заводі на пристрої. Це іноді називають апаратною адресою. Вона складається з 6 байтів, часто задаються у шістнадцятковій формі (наприклад, 5E:FF:56:A2:AF:15).

Ці 6 байтів відповідно представляють:

* Перші три байти представляють ідентифікатор виробника. Цей ідентифікатор називається OUI (унікальний ідентифікатор організації).
* Останні три байти містять серійний номер, призначений виробником.

!!! Warning "Увага"

    MAC-адреса жорстко закодована, коли обладнання залишає завод. Існує два основних способи його модифікації:

    * Модифікація на рівні прошивки (постійна): Потрібні розширені інструменти, які можуть безпосередньо перезаписувати MAC-адресу в ПЗП мережевої карти. Такі інструменти зазвичай доступні лише виробникам обладнання.
    * Програмне спуфінгування (тимчасове): змінює спосіб відображення MAC-адреси в операційній системі. Ці зміни зазвичай скидаються після перезавантаження системи. MAC-адреса віртуальної мережевої карти у віртуальному хості також підроблена.

Адреса Інтернет-протоколу (**IP**) — це ідентифікаційний номер, який постійно або тимчасово призначається кожному пристрою, підключеному до комп’ютерної мережі за допомогою Інтернет-протоколу. IP-адреса та маска підмережі повинні відображатися парами, що визначається основними принципами мережевого зв'язку. Через маску підмережі ми можемо дізнатися поточну IP-адресу:

* мережеві біти та біти хоста
* NetID або SubnetID
* HostID
* мережева адреса
* адреса розсилки

IP-адреси класифікуються на основі поля версії в пакеті наступним чином:

* **IPv4‌** - (4 біти, 0100). Доступний адресний простір IPv4 становить 2<sup>32</sup> (як зазначено в полях адрес джерела та призначення в пакетах IPv4). Зокрема, поділено на:

    * Адреса класу А. Його діапазон становить від **0.0.0.0** до **127.255.255.255**
    * Адреса класу B. Його діапазон становить від **128.0.0.0** до **191.255.255.255**
    * Адреса класу С. Його діапазон становить від **192.0.0.0** до **223.255.255.255**
    * Адреса класу D. Його діапазон становить від **224.0.0.0** до **239.255.255.255**
    * Адреса класу Е. Його діапазон становить від **240.0.0.0** до **255.255.255.255**

    Серед них адреси класу A, класу B та класу C мають власні приватні діапазони адрес. 0.0.0.0 – це зарезервована адреса, яка не призначається хосту. Адреси класу D використовуються для багатоадресного зв'язку та не призначаються хостам. Адреси класу E зарезервовані та не використовуються для звичайних мереж.

* **IPv6** - (4 біти, 0110). Доступна кількість IPv6 становить 2<sup>128</sup> (як зазначено в полях адрес джерела та призначення в пакетах IPv6). Зокрема, поділено на:

    * Одноадресна адреса. Включити адресу локальної одноадресної розсилки (LLA), унікальну локальну адресу (ULA), глобальну одноадресну адресу (GUA), адресу зворотного зв'язку, невизначену адресу
    * Адреса Anycast
    * Багатоадресна адреса

Опис формату запису для 128-бітного IPv6:

* Бажаний формат запису – **X:X:X:X:X:X:X:X:X**. У цьому форматі запису 128-бітні IPv6-адреси поділяються на вісім груп, кожна з яких представлена ​​чотирма шістнадцятковими значеннями (0-9, A-F), розділеними двокрапками (`:`) між групами. Кожен «X» представляє набір шістнадцяткових значень. Наприклад **2001:0db8:130F:0000:0000:09C0:876A:130B**.

    * Пропуск початкового 0 – Для зручності запису початковий «0» у кожній групі можна пропустити, щоб наведену вище адресу можна було скоротити як **2001:db8:130F:0:0:9C0:876A:130B**.
    * Використовуйте подвійну двокрапку – якщо адреса містить дві або більше послідовних груп, обидві з яких дорівнюють 0, можна використовувати подвійну двокрапку. Отже, вищевказану адресу можна скоротити як **2001:db8:130F::9C0:876A:130B**. Увага! Подвійна двокрапка може зустрічатися в IPv6-адресі лише один раз.

* Сумісний з форматами запису - **X:X:X:X:X:X:X:d.d.d.d**. У змішаному мережевому середовищі цей формат забезпечує сумісність між вузлами IPv6 та IPv4. Наприклад, **0:0:0:0:0:ffff:192.1.56.10** та **::ffff:192.1.56.10/96**.

У веб-адресі або URL-адресі (Uniform Resource Locator) IP-адреса може супроводжуватися двокрапкою та адресою порту (що вказує на програму, якій призначено дані). Також, щоб уникнути плутанини в URL-адресі, IPv6-адреса записується в квадратних дужках (наприклад, `[2001:db8:130F::9C0:876A:130B]:443`).

Як згадувалося раніше, маски підмережі поділяють IPv4-адреси на дві частини: мережеві біти та біти хоста. В IPv6 маски підмережі також мають ту саму функцію, але назва змінилася («n» позначає кількість бітів, зайнятих маскою підмережі):

* Мережевий префікс – еквівалент мережевих бітів в IPv4-адресі. Згідно з маскою підмережі, зайняти "n" бітів.
* Ідентифікатор інтерфейсу – еквівалентний бітам хоста в IPv4-адресі. Відповідно до маски підмережі, займайте "128-n" бітів.

Наприклад **2001:0db8:130F:0000:0000:09C0:876A:130B/64**:

```
    Network prefix
|<-    64 bits   ->|

                        Interface ID
                     |<-    64 bits    ->|
2001:0db8:130F:0000 : 0000:09C0:876A:130B
```

В одній мережі IP-адреси повинні бути унікальними, що є фундаментальним правилом мережевого зв'язку. В одній локальній мережі (LAN) MAC-адреса має бути унікальною.

### Структура IPv4-пакету

Пакети IPv4 містять як заголовок, так і дані:

![](./images/IPv4-packet.png)

**Версія**: Допомагає маршрутизаторам визначати версії протоколів. Для IPv4 значення тут дорівнює 0100 (двійкове число 0100 еквівалентне десятковій 4)

**IHL**: Поле, яке використовується для керування довжиною заголовка. Якщо поле «Параметри» не включено, мінімальне значення дорівнює 5 (а саме, двійкове число 0101). У цей час заголовок займає 20 байт. Максимальне значення становить 15 (а саме, двійкове число 1111), а заголовок має довжину 60 байт.

```
Фактична довжина заголовка IPv4 = значення поля IHL * 4
```

**Тип послуги**: Це поле використовується для визначення QoS (якості обслуговування) та пріоритету пакетів даних. Це поле зараз в основному використовується для DSCP (кодової точки диференційованих послуг) та ECN (явного сповіщення про перевантаження).

**Загальна довжина**: Представляє загальну довжину всієї дейтаграми IPv4 (пакета IPv4) у байтах.

!!! note "Примітка" 

    IP-пакет та IP-дейтаграма — це технічно різні терміни для одного й того ж поняття: одиниці даних, що передаються на мережевому рівні.

**Ідентифікація**: Ідентифікує всі фрагменти дейтаграми IPv4. Усі фрагменти з однієї й тієї ж оригінальної дейтаграми мають однакове значення ідентифікації для забезпечення правильної повторної збірки.

**Прапорці**: Використовується для керування поведінкою фрагментації датаграм IPv4. У порядку зліва направо:

* Перший біт - Не використовується, значення 0
* Другий біт – DF (Не фрагментувати). Якщо DF=1, дейтаграма IPv4 має бути передана повністю. Якщо значення MTU перевищує значення, його відкидають, і повертається помилка ICMP (наприклад, «Потрібна фрагментація»). Якщо DF=0, маршрутизатор розділяє датаграму IPv4 на кілька фрагментів, кожен з яких містить однакове значення поля ‌Ідентифікація‌.
* Третій біт - MF (More Fragment - Більше Фрагменту). Якщо MF=1, це означає, що поточний фрагмент не є останнім і є інші фрагменти; якщо MF=0, це означає, що це останній фрагмент.

**Зсув фрагмента**: Вказує відносне положення фрагмента в оригінальній дейтаграмі IPv4, в одиницях по 8 байтів. Це поле в основному використовується для повторного збірки фрагментів.

**TTL (час життя)**: це поле використовується для обмеження максимального часу життя або максимальної кількості переходів дейтаграм у мережі. Відправник встановлює початкове значення, і TTL зменшується на одиницю щоразу, коли він проходить через маршрутизатор. Коли TTL=0, дейтаграма відкидається.

**Протокол**: Вказує тип протоколу, який використовується даними, що передаються в цій дейтаграмі. Діапазон його значень становить від 0 до 255. Наприклад, номери протоколів для TCP, UDP та ICMP – це 6, 17 та 1 відповідно.

**Контрольна сума заголовка**: Це поле буде перераховуватися щоразу, коли дейтаграма проходить через маршрутизатор, головним чином через зменшення поля TTL, що призводить до змін у заголовку. Це поле перевіряє лише заголовок (за винятком частини з даними). Якщо інші поля залишаються незмінними, а змінюється лише значення TTL, контрольна сума буде оновлена ​​до нового значення (ненульового), щоб переконатися, що заголовок не був змінений або пошкоджений під час передачі.

**Адреса джерела**: IPv4-адреса відправника дейтаграми

**Адреса призначення**: IPv4-адреса одержувача дейтаграми

**Параметри**: Необов’язкове поле, довжина якого може змінюватися від 0 до 40 байт. Він використовується лише тоді, коли МГП перевищує 5. Довжина цього поля має бути цілим числом, кратним 4 байтам (якщо довжина менша за ціле число, кратне 4 байтам, використовуйте поле **padding** для доповнення).

!!! tip "Підказка"

    Біт має два значення. В теорії інформації це стосується фундаментальної одиниці інформації, що представляє один бінарний вибір (0 або 1). В інформатиці це найменша одиниця зберігання даних; 8 бітів зазвичай дорівнюють 1 байту, якщо не зазначено інше.

### Структура IPv6-пакету

Датаграми IPv6 складаються з трьох частин:

* Базовий заголовок
* Заголовок розширення
* Блок даних протоколу верхнього рівня

У деяких книгах розширений заголовок та блок даних протоколу верхнього рівня разом називаються **корисним навантаженням**.

![](./images/IPv6-basic-header.png)

Фіксована довжина базового заголовка становить 40 байтів і містить 8 полів:

**Версія**: Допомагає маршрутизаторам визначати версії протоколів. Для IPv6 значення тут дорівнює 0110 (двійкове число 0110 еквівалентне десятковому числу 6).

**Клас трафіку**: Еквівалент поля TOS (тип послуги) в дейтаграмах IPv4. Це поле використовується для визначення QOS (якості обслуговування) та пріоритету пакетів даних.

**Мітка потоку**: Це нове поле IPv6 використовується для керування потоком пакетів. Ненульове значення в цьому полі вказує на те, що пакет слід обробляти особливим чином, тобто його не слід маршрутизувати різними шляхами для досягнення пункту призначення, а натомість використовувати той самий шлях. Перевагою цього є те, що одержувачу не потрібно повторно замовляти посилку, що пришвидшує процес. Це поле допомагає запобігти переупорядкуванню пакетів даних і спеціально розроблено для потокового медіа/медіа в реальному часі.

**Довжина корисного навантаження**: Вкажіть розмір корисного навантаження. Це поле може представляти лише корисне навантаження з максимальною довжиною 65535 байт. Якщо довжина корисного навантаження перевищує 65535 байт, поле довжини корисного навантаження встановлюється на 0, а в заголовку розширення опцій Hop-by-Hop використовується опція jumbo payload.

**Наступний заголовок**: Використовується для позначення типу заголовка пакета після базового заголовка. Якщо є перший заголовок розширення, він представляє тип першого заголовка розширення. В іншому випадку це означає тип протоколу, який використовується верхнім рівнем, наприклад, 6 (TCP) та 17 (UDP).

**Ліміт перехідного часу**: Це поле еквівалентне полю «Час життя» (TTL) у дейтаграмах IPv4.

**Адреса джерела**: Це поле відображає адресу відправника IPv6-дейтаграми.

**Адреса призначення**: Це поле відображає адресу одержувача дейтаграми IPv6.

![](.//images/IPv6-extension-header.png)

У дейтаграмах IPv4 заголовок IPv4 містить додаткові поля, такі як «Параметри», які включають «Безпека», «Мітка часу», «Маршрут запису» тощо. Ці параметри можуть збільшити довжину заголовка IPv4 з 20 до 60 байт. Під час пересилання обробка IPv4-дейтаграм, що містять ці опції, може споживати значні ресурси пристрою, тому вони рідко використовуються на практиці.

IPv6 видаляє ці параметри з базового заголовка IPv6 та поміщає їх у розширений заголовок, який розташований між базовим заголовком IPv6 та блоком даних протоколу верхнього рівня.

Пакет IPv6 може містити 0, 1 або кілька розширених заголовків, які додаються відправником лише тоді, коли пристрій або вузол призначення потребує спеціальної обробки.

На відміну від поля «Параметри IPv4» (яке може містити до 40 байтів і потребує безперервного зберігання), заголовок розширення IPv6 використовує ланцюгову структуру без обмеження фіксованої довжини, що робить його більш масштабованим у майбутньому. Його 8-байтовий механізм вирівнювання реалізовано через поле «Наступний заголовок», що забезпечує ефективну обробку та уникає накладних витрат на фрагментацію.

**Наступний заголовок**: Це поле має таку саму функцію, як і поле «Наступний заголовок» у базовому заголовку.

**Довжина заголовка розширення**: Вказує довжину заголовка розширення (без урахування наступного заголовка).

**Дані заголовка розширення**: Заголовок розширення складається з низки полів опцій та полів заповнення.

Наразі RFC визначає такі типи розширених заголовків:

* Заголовок Hop-by-Hop Options (значення поля наступного заголовка дорівнює 0) – має оброблятися всіма маршрутизаторами на шляху.
* Заголовок параметрів призначення (значення поля наступного заголовка – 60) – обробляється лише вузлом призначення.
* Заголовок маршрутизації (значення поля наступного заголовка – 43) – цей заголовок розширення схожий на параметри «Нещільне джерело» та «Маршрут запису» в IPv4.
* Заголовок фрагмента (значення поля наступного заголовка – 44) – як і у випадку з пакетами IPv4, довжина пакетів IPv6, що пересилаються, не може перевищувати максимальну одиницю передачі (MTU). Коли пакет перевищує MTU, його необхідно фрагментувати. В IPv6 заголовок Fragment використовується вузлом-джерелом IPv6 для надсилання пакета, розмір якого перевищує MTU.
* Заголовок автентифікації (значення наступного поля заголовка – 51) – IPSec використовує цей заголовок для забезпечення автентифікації походження даних, цілісності даних та захисту від повторного відтворення. Він також захищає деякі поля в базовому заголовку IPv6.
* Заголовок інкапсуляції корисного навантаження безпеки (значення поля наступного заголовка – 50) – цей заголовок виконує ті ж функції, що й заголовок автентифікації, а також шифрування пакетів IPv6.

RFC вказує, що коли в одній дейтаграмі використовується кілька розширених заголовків, рекомендується, щоб ці заголовки відображалися в такому порядку:

1. Базовий заголовок IPv6
2. Заголовок опцій по етапах
3. Заголовок параметрів призначення
4. Заголовок маршрутизації
5. Заголовок фрагмента
6. Заголовок автентифікації
7. Інкапсуляція заголовка Security Payload
8. Заголовок параметрів призначення
9. Заголовок протоколу верхнього рівня

За винятком заголовка Destination Option Header, який може з'являтися один або два рази (один раз перед заголовком Routing Extension та один раз перед заголовком Upper-layer protocol), усі інші заголовки розширення можуть зустрічатися лише один раз.

### DNS

**DNS (система доменних імен)**: Сімейство протоколів TCP/IP надає можливість підключення до пристроїв через IP-адреси, але користувачам досить важко запам’ятати IP-адресу пристрою. Тому було спеціально розроблено механізм іменування хостів на основі рядків, де імена хостів відповідають IP-адресам. Потрібен механізм перетворення та запитів між IP-адресами та іменами хостів, і система, яка забезпечує цей механізм, — це система доменних імен (DNS). Процес «перетворення» доменного імені на IP-адресу називається **Розв’язання доменного імені**.

Зверніть увагу на різницю між іменем хоста та доменним іменем:

* Ім'я хоста – використовується для унікальної ідентифікації пристроїв у локальній мережі (LAN) або як частина доменного імені (наприклад, `docs`)
* Доменне ім'я – використовується для унікальної ідентифікації пристроїв у глобальній мережі (WAN). Наприклад, `docs.rockylinux.org`, де `rockylinux.org` – це доменне ім’я домену

!!! tip "Підказка"

    Домен не представляє певний хост

**З: Навіщо потрібен DNS?**

На зорі існування Інтернету, щоб запам'ятати відповідність між іменами хостів та IP-адресами, всю цю інформацію потрібно було записувати у файл, і користувачам доводилося підтримувати її вручну. Зі стрімким розвитком Інтернету основними проблемами, які необхідно вирішити, є:

* Один файл діє лише на тому комп'ютері, який використовується на даний момент
* Ручне обслуговування вмісту файлів стає дедалі складнішим

Щоб вирішити виниклі проблеми, люди розробили DNS, перевагами якого є:

* Розподілені – DNS-сервери доступні для користувачів з усього світу
* Ієрархічне управління – розділіть ієрархію для легшого управління. Як показано на наступному малюнку:

    ![](./images/domain.png)

Кореневий домен зазвичай називають таким, що має 13 серверів кореневого домену по всьому світу. Більш стандартизований вираз:

> Глобальна система кореневих серверів DNS логічно побудована навколо 13 канонічних кінцевих точок (від a.root-servers.net до m.root-servers.net), дизайн якої базується на історичних обмеженнях протоколу. Фізично ці кінцеві точки реалізовані через понад 1500 серверів з екземплярами Anycast, розподілених по всьому світу, якими керують 13 незалежних організацій за координації ICANN/IANA

Для `docs.rockylinux.org.`:

* **Корневий домен** – посилається на точку (`.`).
* **Домен першого рівня** – посилається на рядок `org`. Існує багато суперечок щодо поділу доменів першого рівня, наприклад, деякі документи класифікують `.org` або `org.` як домени першого рівня.
* **Домен другого рівня** – посилається на рядок `rockylinux`. Існує багато суперечок щодо поділу доменів другого рівня; наприклад, у деяких документах `rockylinux.org.` або `.rockylinux.org.` вказані як домени другого рівня.
* **hostname** – посилається на рядок `docs`.

**FQDN (повне доменне ім’я)**: повне доменне ім’я, що складається з імені хоста та різних рівнів доменів. Згідно зі стандартом RFC (RFC 1034, RFC 2181, RFC 8499), кореневий домен в кінці є галузевим стандартом (наприклад, `docs.rockylinux.org.`). У конфігураційних файлах деякого програмного забезпечення DNS необхідно ввести стандартне повне доменне ім'я (FQDN), але кореневий домен можна ігнорувати під час доступу до певних мережевих ресурсів (наприклад, коли користувач відвідує `https://docs.rockylinux.org`, браузер автоматично додасть крапку в кінці). **Доменне ім’я**: структура, яка з’єднує домени на всіх рівнях і починається з імені хоста. **Зона**: Представляє собою суміжну частину простору імен DNS, що керується певним авторитетним сервером, який зберігає всі записи розв'язання FQDN (наприклад, A, MX тощо) у межах цієї області.

!!! tip "Підказка"

    Загалом кажучи, «FQDN» ефективніше виражає значення авторського документа, ніж «доменне ім’я», оскільки читачі з різних галузей по-різному розуміють термін «доменне ім’я». Наприклад, деякі читачі можуть інтерпретувати `rockylinux.org` як доменне ім'я, але насправді це неправильно. Строго кажучи, це слід називати доменом (а не доменним іменем). Тому, для підвищення точності, читачів просять чітко розрізняти значення доменів та доменних імен.

### 7-рівнева теоретична модель ISO/OSI

**ISO (Міжнародна організація зі стандартизації)** – міжнародна організація, заснована в 1974 році, її основна роль полягає у встановленні глобальних стандартів у різних галузях. Для галузі Інтернету ISO запропонувала 7-рівневу теоретичну еталонну модель OSI.

**OSI (модель опорного з’єднання відкритих систем)** – ця модель пропонує стандартну структуру, яка намагається з’єднати різні комп’ютери в мережу по всьому світу.

| Шар                      | Опис                                                                                                                                                      |
| ------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 7 - Додаток              | Надає різні послуги запитів для програм або запитів користувачів                                                                                          |
| 6 – Презентація          | Кодування даних, перетворення форматів, шифрування даних                                                                                                  |
| 5 - Сеанс                | Створює, керує та підтримує сеанси.                                                                                                                       |
| 4 - Транспорт            | Передача даних, встановлення наскрізних з'єднань тощо.                                                                                                    |
| 3 - Мережа               | Керування мережевими з'єднаннями (встановлення, обслуговування та завершення), вибір маршруту маршрутизації, групування пакетів, керування трафіком тощо. |
| 2 - Канал передачі даних | Інкапсуляція та передача кадрів, керування трафіком та перевірка помилок тощо.                                                                            |
| 1 - Фізичний             | Управління середовищами передачі, специфікаціями фізичного інтерфейсу, перетворенням сигналів та передачею тощо.                                          |

!!! Note «Допоміжний засіб для запам'ятовування»

    Щоб запам'ятати порядок шарів моделі ISO/OSI, пам'ятайте наступне речення: **Здається, що всім людям потрібна обробка даних**.

**Ієрархічна структура моделі**: Вона втілює принцип модульної структури, тобто шляхом розкладання складних функцій мережевого зв'язку на незалежні рівні досягається функціональне розв'язання та стандартизована співпраця.

!!! note "Примітка"

    Слід зазначити, що 7-рівнева модель ISO/OSI не існує в реальній мережевій комунікації. Він лише забезпечує структуру дизайну та підхід до інтернет-комунікації.

**4-рівнева модель TCP/IP** – ієрархічна модель, що використовується у фактичному мережевому зв'язку (спрощує 7-рівневу модель ISO/OSI до 4-рівневої моделі). TCP/IP – це синонім набору протоколів, що включає багато протоколів і утворює набір протоколів TCP/IP. У середовищі аналізу протоколів або навчання її іноді неофіційно називають **5-рівневою моделлю TCP/IP**.

| Шар                     | Протоколи                                                                                                                                                                      | Апаратні пристрої, що працюють на цьому рівні                           |
|:----------------------- |:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |:----------------------------------------------------------------------- |
| 4 - Застосування        | HTTP, FTP, SMTP, DNS, DHCP ...                                                                                                                                                 | -                                                                       |
| 3 - Транспорт           | TCP, UDP                                                                                                                                                                       | Брандмауер і балансувальник навантаження                                |
| 2 - Інтернет            | IP, ICMP, ARP, RARP, IGMP                                                                                                                                                      | Маршрутизатор                                                           |
| 1 - Мережевий інтерфейс | Протокол Ethernet (IEEE 802.3), PPP (протокол точка-точка), PPPoE (протокол точка-точка через Ethernet), Wi-Fi (IEEE 802.11), ADSL (асиметрична цифрова абонентська лінія) ... | Мережева карта, комутатор, концентратор, ретранслятор, вита пара, модем |

* **Рівень додатків** – об’єднати рівень додатків, рівень представлення та рівень сеансу в теоретичній моделі в один рівень додатків.
* **Транспортний рівень** – транспортний рівень у теоретичній моделі.
* **Інтернет-рівень** – мережевий рівень у теоретичній моделі.
* **Рівень мережевого інтерфейсу** – інтеграція канального рівня та фізичного рівня з теоретичної моделі в один рівень.

!!! tip "Термінологічний вираз"

    Чотирирівнева модель TCP/IP, набір протоколів TCP/IP та стек протоколів TCP/IP – це різні вираження однієї й тієї ж концепції.

## Іменування інтерфейсів

*lo* — це інтерфейс "**loopback**", який дозволяє програмам TCP/IP спілкуватися одна з одною, не виходячи з локальної машини. Це дає змогу перевірити, чи **мережевий модуль системи працює належним чином**, а також дозволяє перевірити локальний хост. Усі пакети, які надходять через localhost, виходять через localhost. Отримані пакети – це надіслані пакети.

Менеджер пристроїв `udev` призначає інтерфейсам імена з певним префіксом залежно від типу. Традиційно всі інтерфейси **Ethernet**, наприклад, починалися з **eth**. За префіксом йшло число, першим було 0 (eth0, eth1, eth2...). Інтерфейси Wi-Fi отримали префікс WLAN.

У дистрибутивах Linux Rocky 8/9/10 диспетчер пристроїв `udev` іменуватиме інтерфейси за допомогою такої політики, де "X" позначає число:

* `enoX`: бортові пристрої
* `ensX`: слот PCI Express для гарячого підключення
* `enpXsX`: фізичне/географічне розташування роз’єму обладнання
* ...

!!! tip "Інтеграція та поглинання"

    У старіших дистрибутивах Linux udev був окремим компонентом, який виконувався як окремий процес. Тим не менш, сучасні основні дистрибутиви інтегрували код udev у проект systemd, що робить його основним компонентом пакету systemd.

## Налаштування, перегляд та тестування мережі

### Команда `ip`

Забудьте стару команду `ifconfig`! Є `ip`!

!!! Note "Примітка"

    Коментар для адміністраторів старих систем Linux:
    
    Історична команда керування мережею — `ifconfig`. Ця команда була замінена командою `ip`, яка вже добре відома адміністраторам мережі.
    
    Команда `ip` — це єдина команда для керування **IP-адресою, ARP, маршрутизацією тощо**.
    
    Rocky 8/9/10 більше не встановлює команду ifconfig за замовчуванням. Окрім команди `ip`, системні адміністратори можуть використовувати команди мережевого компонента [NetworkManager](https://www.networkmanager.dev/) для керування мережами; найпоширенішими є `nmtui` та `nmcli`.
    
    Зараз важливо набути корисних звичок.

Команда `ip` з пакету `iproute2` дозволяє налаштувати інтерфейс і його таблицю маршрутизації.

Відображення інтерфейсу:

```bash
[root]# ip link
```

Інформація про інтерфейс відображення:

```bash
[root]# ip addr show
```

Відобразити інформацію про інтерфейс:

```bash
[root]# ip addr show eth0
```

Відображення таблиці ARP:

```bash
[root]# ip neigh
```

### Команди `nmtui` та `nmcli`

[У цьому документі](../../gemstones/network/nmtui.md) описано використання команди `nmtui` та пов'язаних з нею файлів конфігурації.

[У цьому документі](../../gemstones/network/network_manager.md) описано використання команди `nmcli` та пов'язаних з нею файлів конфігурації.

### Команда `mtr`

`mtr` – це інструмент діагностики мережі, який використовується для виявлення проблем із мережею. Він замінює команди `ping` та `traceroute`. Що стосується продуктивності, команда `mtr` працює швидше.

Команда mtr детально описана в [цьому документі](../../gemstones/network/mtr.md)

### Команда `ss`

Ця команда замінює застарілу команду `netstat` і в основному використовується для перегляду стану портів і сокетів. Її використання таке:

```
ss [OPTIONS] [FILTER]
```

Поширені варіанти включають наступне:

| Опції | Пояснення                                    |
|:----- |:-------------------------------------------- |
| `-a`  | Відображає всі сокети                        |
| `-r`  | Визначає ім'я хоста                          |
| `-t`  | Відображає TCP-сокети                        |
| `-u`  | Відображає UDP-сокети                        |
| `-l`  | Відображає сокет прослуховування             |
| `-n`  | Відображає IP-адресу та номер порту          |
| `-p`  | Відображає процеси, що використовують сокети |

Відображення сокетів, які встановили з'єднання:

```bash
[root]# ss
```

Перегляд портів, які прослуховує локальна машина:

```bash
[root]# ss -tulnp
Netid  State   Recv-Q  Send-Q     Local Address:Port     Peer Address:Port    Process
udp    UNCONN  0       0              127.0.0.1:323           0.0.0.0:*        users:(("chronyd",pid=703,fd=5))
udp    UNCONN  0       0                  [::1]:323              [::]:*        users:(("chronyd",pid=703,fd=6))
tcp    LISTEN  0       128              0.0.0.0:22            0.0.0.0:*        users:(("sshd",pid=734,fd=3))
tcp    LISTEN  0       128                 [::]:22               [::]:*        users:(("sshd",pid=734,fd=4))
```

Перегляд всіх мережевих підключень на цьому пристрої:

```bash
[root]# ss -an
Netid State  Recv-Q Send-Q     Local Address:Port     Peer Address:Port  Process
nl    UNCONN 0      0                    0:695                 *
...
```

`ss -tulnp`: Відображає лише стан прослуховування TCP/UDP-з’єднань та включає інформацію про процес.

`ss -an`: Відображає всі типи з’єднань (включно з прослуховуванням та активністю)

Опис вихідного стовпця:

* Netid - Тип сокету та тип передачі
* State - Стан сокета. «ESTAB» означає встановлення з’єднання; «UNCONN» означає непідключені з’єднання; «LISTEN» означає прослуховуване з’єднання.
* Recv-Q – Розмір черги отримання сокета
* Send-Q – Розмір черги надсилання сокета
* Local Address:Port - Локальна IP-адреса та порт
* Peer Address:Port - IP-адреса та порт кінця з'єднання
* Process - Відповідна інформація про процес, включаючи ідентифікатор процесу, ім'я процесу та дескриптор файлу

Якщо вам потрібно дізнатися відповідність між портами за замовчуванням та службами, зверніться до файлу **/etc/services**.

### Перегляд властивостей мережевої карти

Часто використовуйте команду `ethtool` для перегляду властивостей мережевої карти (NIC). Її використання таке:

```
ethtool [option] DEVNAME
```

```bash
[root]# ethtool ens160
Settings for ens160:
        Supported ports: [ TP ]
        Supported link modes:   1000baseT/Full
                                10000baseT/Full
        Supported pause frame use: No
        Supports auto-negotiation: No
        Supported FEC modes: Not reported
        Advertised link modes:  Not reported
        Advertised pause frame use: No
        Advertised auto-negotiation: No
        Advertised FEC modes: Not reported
        Speed: 10000Mb/s
        Duplex: Full
        Auto-negotiation: off
        Port: Twisted Pair
        PHYAD: 0
        Transceiver: internal
        MDI-X: Unknown
        Supports Wake-on: uag
        Wake-on: d
        Link detected: yes
```

Важливий опис атрибута:

* Підтримує автоматичне узгодження
* Швидкість
* Двосторонній
* Порт – це стосується середовища для передачі даних, такого як «вита пара» та «оптичне волокно»
* Виявлено посилання

Якщо вам потрібно детальніше налаштувати атрибути мережевої карти, введіть команду `nmcli` в інтерактивному терміналі, наприклад:

```bash
[root]# nmcli connection show
NAME    UUID                                  TYPE      DEVICE
ens160  76999cf9-b99e-4a9d-a325-0c54224d9300  ethernet  ens160

[root]# nmcli connection edit ens160

nmcli> set 802-3-ethernet.
accept-all-mac-addresses   generate-mac-address-mask  port                       speed
auto-negotiate             mac-address                s390-nettype               wake-on-lan
cloned-mac-address         mac-address-blacklist      s390-options               wake-on-lan-password
duplex                     mtu                        s390-subchannels

nmcli> print

nmcli> save

nmcli> quit

[root]# nmcli connection down ens160

[root]# nmcli connection up ens160
```

### Тестування IPv6/IPv4

Запит IPv4/IPv6-адреси глобальної мережі цього комп'ютера:

```bash
[root]# curl -4 ifconfig.me
116.207.111.120

[root]# curl -6 ifconfig.me
240e:36a:8339:8500:20c:29ff:feb3:41fd
```

### Команда `ipcalc`

Команда `ipcalc` (**IP-обчислення**) обчислює адресу мережі або широкомовлення на основі IP-адреси та маски. Ця команда підтримує як IPv4-адреси, так і IPv6-адреси.

Синтаксис команди `ipcalc`:

```bash
ipcalc [OPTION]... <IP address>[/prefix] [netmask]
```

Приклад:

```bash
[root]# ipcalc -m -p -b -n 192.168.100.20/24
NETMASK=255.255.255.0
PREFIX=24
BROADCAST=192.168.100.255
NETWORK=192.168.100.0

[root]# ipcalc -h ::1
HOSTNAME=localhost
```

!!! Tip "Порада"

    Ця команда цікава, після чого виконується перенаправлення для автоматичного заповнення файлів конфігурації ваших інтерфейсів:

    ```
    [root]# ipcalc –b 172.16.66.203 255.255.240.0 >> /etc/sysconfig/network-scripts/ifcfg-eth0
    ```

|         Опція          |                     Опис                     |
|:----------------------:|:--------------------------------------------:|
| `-b` або `--broadcast` |        Відображає широкомовну адресу.        |
|  `-n` або `--network`  |          Відображає мережеву адресу          |
|  `-p` або `--prefix`   |          Відображає префікс мережі           |
|  `-m` або `--netmask`  |   Відображає мережеву маску для IP-адреси    |
|   `-s` або`--silent`   | Не відображає жодних повідомлень про помилки |
| `-h` або `--hostname`  |   Показує ім'я хоста, визначене через DNS    |

## Контент, пов'язаний з іменем хоста

### Встановлення та перегляд імені хоста

systemd — це не просто програма ініціалізації; це великий пакет програмного забезпечення, який керує багатьма системними компонентами. `hostnamectl` — це компонент systemd, який використовується для керування іменами хостів.

Команда `hostnamectl` є альтернативою команді `hostname`. Слід зазначити, що зміни, внесені командою `hostnamectl`, є **постійними**. Її використання таке:

```
hostnamectl [OPTIONS...] COMMAND ...
```

Запит відповідної інформації про ім'я хоста:

```bash
[root]# hostnamectl
   Static hostname: HOME01
         Icon name: computer-vm
           Chassis: vm
        Machine ID: dd5a13887a7b4325a8fa18bb730ff060
           Boot ID: 87e3adf2b2754ee28fe4497ee956064c
    Virtualization: vmware
  Operating System: Rocky Linux 8.10 (Green Obsidian)
       CPE OS Name: cpe:/o:rocky:rocky:8:GA
            Kernel: Linux 4.18.0-553.83.1.el8_10.x86_64
      Architecture: x86-64
```

Встановлення імені хоста машини та розташування хоста:

```bash
[root]# hostnamectl set-hostname HOME10

[root]# hostnamectl set-location "Vancouver, Canada"

[root]# hostnamectl
   Static hostname: HOME10
         Icon name: computer-vm
           Chassis: vm
          Location: Vancouver, Canada
        Machine ID: dd5a13887a7b4325a8fa18bb730ff060
           Boot ID: 87e3adf2b2754ee28fe4497ee956064c
    Virtualization: vmware
  Operating System: Rocky Linux 8.10 (Green Obsidian)
       CPE OS Name: cpe:/o:rocky:rocky:8:GA
            Kernel: Linux 4.18.0-553.83.1.el8_10.x86_64
      Architecture: x86-64
```

!!! Tip "Порада"

    У локальній мережі ім'я хоста ідентифікує пристрій у мережі. Звичайно, мати унікальне ім'я хоста недостатньо, і IP-адреса, що відповідає цьому імені хоста, також має бути унікальною. 
    У глобальній мережі повне доменне ім'я (FQDN), яке складається з імен хостів та різних рівнів доменів, унікально ідентифікує пристрої через ієрархічну систему DNS.

### файл /etc/hostname

Вміст цього файлу — це ім'я хоста поточної машини. Зазвичай не рекомендується безпосередньо змінювати вміст цього файлу.

## Контент, пов'язаний з DNS

Коли операційній системі потрібно визначити ім'я хоста, вона надсилатиме запити в такому порядку:

1. DNS-кеш
2. /etc/hosts
3. DNS-сервери

### Файл /etc/hosts

Під час запуску операційної системи файл **/etc/hosts** використовується для визначення повного доменного імені.

Файл **/etc/hosts** — це статична таблиця зіставлення імен хостів, і він буде використаний першим у таких ситуаціях:

* DNS-сервери недоступні
* Перш ніж надсилати запит до DNS-серверів

Формат цього файлу такий:

```bash
@IP         <hostname>     [alias]    [# comment]
 ↑              ↑             ↑             ↑    
required    required       optional     optional
```

Кожен рядок представляє одне відношення відображення. Вміст цього файлу не може бути порожнім і повинен містити принаймні одне відношення зіставлення.

Приклад файлу **/etc/hosts**:

```
127.0.0.1       localhost localhost.localdomain
::1             localhost localhost.localdomain
192.168.1.10    rockstar.rockylinux.lan rockstar
```

### Процес вирішення проблем DNS

Коли користувач вводить www.rockylinux.org у браузері, відбувається ось що:

1. **Етап локального вирішення**

> 1. Пошук у кеші браузера (кеші DNS). Якщо відповідний запис зіставлення знайдено, запит завершується. Якщо не знайдено, буде виконано наступний крок 
> 2. Пошук локального файлу Hosts (/etc/hosts). Якщо є відповідний запис зіставлення, запит завершується. В іншому випадку перейдіть до наступного кроку

2. **Рекурсивний етап запиту**

> 1. Ініціювати запит до DNS-сервера, налаштованого у /etc/resolv.conf (наприклад, 8.8.8.8). DNS-сервери, які користувачі налаштовують в операційній системі, також відомі як локальні DNS-сервери. Локальні DNS-сервери тут стосуються публічних DNS, наданих для загального користування, таких як 8.8.8.8 та 114.114.114. Якщо запит потрапляє в запис кешу локального DNS-сервера, запит завершується та повертає результат; в іншому випадку він переходить до ітеративного процесу запиту
> 2. Локальний DNS-сервер ініціює запит до кореневого сервера імен та отримує адресу домену .org. 
> 3. Сервер домену верхнього рівня (TLD) запитуватиме адресу rockylinux.org у сервера .org.
> 4. Сервер імен нарешті отримує точну IP-адресу www.rockylinux.org від сервера rockylinux.org

3. **Повернути результати парсингу користувачеві та кешувати результати локально**

> Локальний DNS-сервер повертає IP-адресу клієнту та кешує записи зіставлення локально (час кешування визначається TTL). Браузер користувача також кешував цей запис зіставлення.

### Файл /etc/resolv.conf

Файл **/etc/resolv.conf** містить конфігурацію розв’язання DNS-імен.

```bash
#Generated by NetworkManager
domain mondomaine.lan
search mondomaine.lan
nameserver 192.168.1.254
```

У Rocky Linux 8/9/10 вам не слід безпосередньо редагувати цей файл; натомість налаштуйте сервер імен за допомогою відповідних команд мережевого компонента `NetworkManager`.

```bash
[root]# nmcli connection modify ens160 ipv4.dns "114.114.114.114,8.8.8.8"

[root]# systemctl restart NetworkManager.service

[root]# nmcli connection show ens160
...
ipv4.dns:                               114.114.114.114,8.8.8.8
...

[root]# cat /etc/resolv.conf
# Generated by NetworkManager
nameserver 114.114.114.114
nameserver 8.8.8.8
```

### Пов'язані команди

Три команди, `host`, `nslookup` та `dig`, використовуються для перегляду інформації про результати парсингу, серед яких `dig` є рекомендованою командою.

```bash
[root]# host www.rockylinux.org
www.rockylinux.org is an alias for rockylinux.org.
rockylinux.org has address 76.223.126.88
rockylinux.org mail is handled by 5 alt2.aspmx.l.google.com.
rockylinux.org mail is handled by 10 alt4.aspmx.l.google.com.
rockylinux.org mail is handled by 1 aspmx.l.google.com.
rockylinux.org mail is handled by 5 alt1.aspmx.l.google.com.
rockylinux.org mail is handled by 10 alt3.aspmx.l.google.com.

[root]# nslookup docs.rockylinux.org
Server:         114.114.114.114
Address:        114.114.114.114#53

Non-authoritative answer:
docs.rockylinux.org     canonical name = f5612ab73a7647d2.vercel-dns-016.com.
Name:   f5612ab73a7647d2.vercel-dns-016.com
Address: 216.150.16.193
Name:   f5612ab73a7647d2.vercel-dns-016.com
Address: 216.150.1.193

[root]# dig wiki.rockylinux.org

; <<>> DiG 9.11.36-RedHat-9.11.36-16.el8_10.6 <<>> wiki.rockylinux.org
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 43671
;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 0

;; QUESTION SECTION:
;wiki.rockylinux.org.           IN      A

;; ANSWER SECTION:
wiki.rockylinux.org.    305     IN      CNAME   rockylinux.map.fastly.net.
rockylinux.map.fastly.net. 305  IN      A       151.101.42.132

;; Query time: 98 msec
;; SERVER: 114.114.114.114#53(114.114.114.114)
;; WHEN: Sun Nov 23 17:46:13 CST 2025
;; MSG SIZE  rcvd: 92
```

### Тип запису роздільної здатності DNS

* A – Перетворює доменне ім'я на вказану IPv4-адресу
* AAAA – Перетворює доменне ім'я на вказану IPv6-адресу
* NS – вказує певний DNS-сервер для керування конфігурацією розв’язання доменних імен
* CNAME – перетворює доменне ім'я на інше доменне ім'я.
* PTR – зіставляє IP-адреси з доменними іменами та перевіряє, чи відповідає IP-адреса певному доменному імені, за допомогою записів PTR. В основному використовується для зворотного розв'язання поштових серверів
* MX – вказує на поштовий сервер, що відповідає доменному імені. Це необхідно під час налаштування послуг, пов'язаних з електронною поштою
* SRV – використовується для позначення того, що сервер використовує певну послугу.
* TXT – використовується для ідентифікації та опису доменних імен. Записи TXT зазвичай використовуються для перевірки права власності на доменне ім'я, цифрових сертифікатів, записів SPF (Sender Policy Framework) та відновлення доменного імені.

## Файл /etc/nsswitch.conf

Цей файл визначає служби та порядок пошуку, що використовуються операційною системою під час пошуку різної інформації (наприклад, `/etc/passwd`, `/etc/group`, `/etc/hosts`). Цей файл використовує механізм під назвою NSS (перемикач служби імен) для виконання всього цього.

```bash
[root]# grep -v ^# /etc/nsswitch.conf
...
hosts:      files dns myhostname
...
```

Основний синтаксис для кожного рядка такий:

```
<Database Name>: <Method1> [Action1] <Methond2> [Action2] ...
    ↑               ↑          ↑
required        required    optional
```

Під час визначення імені хоста спочатку використовуйте локальний файл **/etc/hosts**, а потім локальний DNS-сервер. `myhostname` – це спеціальний метод, який в першу чергу забезпечує локальне розпізнавання імені хоста операційної системи.

У переважній більшості випадків немає потреби змінювати вміст цього файлу.

### Команда `getent`

Команда `getent` виходить з пакета glibc-common, тому вам може знадобитися виконати таку команду:

```bash
[root]# dnf -y install glibc-common
```

Команда `getent` (отримати запис) отримує запис NSSwitch (`hosts` + `dns`)

Синтаксис команди `getent`:

```
getent [OPTION...] database [key ...]
```

Приклад:

```bash
[root]# getent hosts rockylinux.org
76.223.126.88   rockylinux.org
```

Запит виключно до локального DNS-сервера може призвести до неправильних результатів розв'язання проблеми через неврахування записів файлу **/etc/hosts**, хоча це рідкість у сучасних системах.

Для правильного розв’язання файлів **/etc/hosts** зверніться до служби імен NSSwitch, яка займається розв’язанням DNS.

## Q & A

**З: Чи варто використовувати традиційні методи чи сучасний NetworkManager для керування файлами конфігурації мережевої карти Rocky Linux 8.x?**

У цій версії NetworkManager сумісний з традиційними файлами конфігурації мережевих карт, але автор рекомендує використовувати команди NetworkManager для керування ними. Таким чином, ви можете безперешкодно керувати мережами для наступних версій 9.x або 10.x.

**З: Які атрибути (ключі) можна налаштувати у файлі конфігурації мережевої карти, яким керує NetworkManager?**

Будь ласка, зверніться до вмісту файлів `man 5 nm-settings` та `man 5 NetworkManager.conf`.

**З: Як крок за кроком перевірити стан зв'язку мережі?**

Ви можете скористатися командою `mtr` або `ping`, щоб поступово перевіряти стан зв’язку мережі. Об'єктами інспекції є:

1. Програмний рівень TCP/IP. Наприклад, `mtr -c 4 localhost` або `ping -c 4 localhost`.
2. NIC (мережева плата). Наприклад, `mtr 192.168.100.20` або `ping 192.168.100.20`
3. Шлюз. Наприклад, `mtr 192.168.100.1` або `ping 192.168.100.1`
4. Віддалені сервери для глобальних мереж. Наприклад, `mtr 151.101.42.132` або `ping 151.101.42.132`
5. Локальний DNS-сервер. Наприклад, `mtr 1.1.1.1` або `ping 1.1.1.1`

!!! tip "Підказка"

    Під час тестування спочатку перевірте правильність з'єднань на схемі топології мережі та перевірте, чи не пошкоджені мережеві та оптоволоконні кабелі.

!!! note "пояснення термінології"

    Діаграма топології мережі: діаграма, яка графічно представляє фізичні або логічні зв'язки між мережевими пристроями

![Архітектура мережі зі шлюзом](images/network-002.png)

![Спосіб усунення несправностей або перевірка мережі](images/network-004.png)

**З: У поточній мережі існує конфлікт між IP-адресами або MAC-адресами. Як мені це вирішити?**

Неправильна конфігурація може призвести до того, що кілька інтерфейсів використовуватимуть одну й ту саму IP-адресу. Це може статися, якщо в мережі є кілька серверів DHCP або одна і та сама IP-адреса багато разів призначається вручну.

Якщо мережа не працює, і коли причиною може бути конфлікт IP-адрес, можна використати програмне забезпечення `arp-scan` (потрібне сховище EPEL):

```bash
dnf install arp-scan
```

Використання таке

```
arp-scan [options] [hosts...]
```

Приклад:

```bash
$ arp-scan -I eth0 -l

172.16.1.104  00:01:02:03:04:05       3COM CORPORATION
172.16.1.107  00:0c:29:1b:eb:97       VMware, Inc.
172.16.1.250  00:26:ab:b1:b7:f6       (Unknown)
172.16.1.252  00:50:56:a9:6a:ed       VMWare, Inc.
172.16.1.253  00:50:56:b6:78:ec       VMWare, Inc.
172.16.1.253  00:50:56:b6:78:ec       VMWare, Inc. (DUP: 2)
172.16.1.253  00:50:56:b6:78:ec       VMWare, Inc. (DUP: 3)
172.16.1.253  00:50:56:b6:78:ec       VMWare, Inc. (DUP: 4)
172.16.1.232  88:51:fb:5e:fa:b3       (Unknown) (DUP: 2)
```

Типові параметри команди `arp-scan`:

|     Опція      |                                              Опис                                               |
|:--------------:|:-----------------------------------------------------------------------------------------------:|
| `-I interface` |                       Вказує мережевий інтерфейс або мережеве підключення                       |
|   `-r count`   |        Встановлює частоту сканування для кожного хоста, зі значенням за замовчуванням 2         |
|      `-l`      |                 Генерує список адрес на основі вказаного мережевого інтерфейсу                  |
|      `-D`      |                        Відображає RTT (час передачі даних) пакетів даних                        |
|      `-g`      |                                 Не відображає дублікати пакетів                                 |
|  `-t timeout`  | Встановлює час очікування (у мілісекундах) для кожного хоста, зі значенням за замовчуванням 500 |


!!! Tip "Порада"

    Як показує наведений вище приклад, конфлікти MAC-адрес можливі! Технології віртуалізації та копіювання віртуальних машин викликають ці проблеми.

## Цей документ містить кілька файлів

* **/etc/hosts**
* **/etc/nsswitch.conf**
* **/etc/hostname**
* **/etc/resolv.conf**
* Файли конфігурації мережевої карти в каталозі **/etc/sysconfig/network-scripts/**
* Файли конфігурації мережевої карти в каталозі **/etc/NetworkManager/system-connections/**
