---
title: 네트워크 구현
---

# 네트워크 구현

이 문서에서는 네트워크 작업을 어떻게 다루고 관리하는지에 대해 알아보겠습니다.

****

**목적**: 이 문서에서는 다음을 수행하는 방법에 대해 알아봅니다:

:heavy_check_mark: 워크스테이션을 DHCP 사용으로 구성하는 방법 :heavy_check_mark: 워크스테이션을 정적 구성으로 설정하는 방법 :heavy_check_mark: 워크스테이션에 게이트웨이를 사용하는 방법 :heavy_check_mark: 워크스테이션에 DNS 서버를 사용하는 방법 :heavy_check_mark: 워크스테이션의 네트워크 문제 해결하기

:checkered_flag: **network**, **linux**, **ip**

**지식**: :star: :star:  
**복잡성**: :star: :star:

**소요 시간**: 30분

****

## 개요

이 장에서는 다음과 같은 아키텍처를 사용합니다.

![네트워크 아키텍처의 그림](images/network-001.png)

이를 통해 다음을 고려할 수 있습니다:

* 로컬 영역 네트워크 LAN(Local Area Network) 통합
* 원격 서버에 연결하기 위한 게이트웨이 설정
* DNS 서버 구성 및 이름 풀이의 구현

장치에 정의해야 하는 최소 매개변수는 다음과 같습니다.

* 컴퓨터 이름;
* IP 주소;
* 서브넷 마스크.

예시:

*   `pc-rocky`;
*   `192.168.1.10`;
*   `255.255.255.0`.

CIDR이라는 표기법이 점점 더 흔해지고 있습니다: 192.168.1.10/24

IP 주소는 메시지(패킷)의 적절한 라우팅에 사용됩니다. IP 주소는 두 부분으로 나뉘어집니다.

* 네트워크를 식별하는 고정 부분
* 네트워크 내 호스트의 식별자.

서브넷 마스크는 다음을 분리하기 위한 **4바이트** 세트입니다.

* 네트워크 주소(**NetID** 또는 **SubnetID**)는 IP 주소와 마스크 사이에 비트 논리 AND를 수행합니다.
* 호스트 주소(**HostID**)는 IP 주소와 마스크 보수 사이의 비트 단위 논리 AND를 수행합니다.

네트워크 내에서 특정 주소도 식별되어야 합니다. 범위의 첫 번째 주소와 마지막 주소는 특별한 역할을 가지고 있습니다:

* 범위의 첫 번째 주소는 **네트워크 주소**입니다. 네트워크를 식별하고 네트워크 간에 정보를 라우팅하는 데 사용됩니다.

* 범위의 마지막 주소는 **브로드캐스트 주소**입니다. 네트워크의 모든 장치에 정보를 브로드캐스트하는 데 사용됩니다.

### MAC 주소/ IP 주소

**MAC 주소**는 공장에서 기기에 기록된 물리적 식별자입니다. 이를 하드웨어 주소라고도 합니다. 이 주소는 일반적으로 16진수 형식으로 제공되는 6바이트로 구성됩니다(예: 5E:FF:56:A2:AF:15).제조업체 식별자 3바이트와 일련 번호 3바이트로 구성됩니다. 3바이트의 제조업체 식별자와 3바이트의 일련 번호로 구성됩니다.

!!! !!!

    이 마지막 설명은 오늘날의 가상화에서 사실이 아닌 부분도 있습니다. MAC 주소를 변경하기 위한 소프트웨어 솔루션도 있습니다.

인터넷 프로토콜(**IP**) 주소는 인터넷 프로토콜을 사용하여 컴퓨터 네트워크에 연결된 각 기기에 영구적으로 또는 일시적으로 할당되는 식별 번호입니다. 하나의 부분은 네트워크 주소(NetID 또는 SubnetID)를 정의하고, 다른 부분은 네트워크 내 호스트 주소(HostID)를 정의합니다. 각 부분의 상대적인 크기는 네트워크 (서브)마스크에 따라 다릅니다.

IPv4 주소는 4바이트로 구성된 주소를 정의합니다. 주소 공간이 거의 고갈되기 때문에 새로운 표준인 16바이트로 정의된 IPv6가 만들어졌습니다.

IPv6은 종종 콜론으로 구분된 8개의 2바이트 그룹으로 나타납니다. 무의미한 0은 생략할 수 있으며, 4개 이상의 연속된 0 그룹은 이중 콜론으로 대체할 수 있습니다.

서브넷 마스크는 0에서 128비트까지 가질 수 있습니다. (예: 21ac:0000:0000:0611:21e0:00ba:321b:54da/64 또는 21ac::611:21e0:ba:321b:54da/64)

웹 주소 또는 URL(Uniform Resource Locator)에서 IP 주소 뒤에 콜론과 포트 주소 (데이터가 목적지로 전송되는 응용 프로그램을 나타내는)가 올 수 있습니다. 또한 URL에서 혼동을 피하기 위해 IPv6 주소는 대괄호 [ ], 콜론, 포트 주소로 작성됩니다.

네트워크에서 IP와 MAC 주소는 고유해야 합니다!

### DNS-도메인

클라이언트 시스템은 DNS(**Domain Name System**, 예: `mydomain.lan`) 도메인의 일부일 수 있습니다.

완전히 정규화된 시스템 이름(**FQDN**)은 `pc-rocky.mydomain.lan`이 됩니다.

컴퓨터 집합은 DNS 도메인이라는 논리적인 이름-풀이 집합으로 그룹화할 수 있습니다. 물론, DNS 도메인은 단일 물리적 네트워크로 제한되지 않습니다.

컴퓨터가 DNS 도메인의 일부가 되려면 DNS 접미사(여기서는 `mydomain.lan`)와 쿼리할 수 있는 서버를  지정되어야 합니다.

### OSI 모델의 복습

!!! !!!

    OSI 모델의 계층 순서를 기억하려면 다음 문장을 기억하세요: __Please Do Not Touch Steven's Pet Alligator__.

| 계층                     | 프로토콜                                       |
| ---------------------- | ------------------------------------------ |
| 7 - Application (응용)   | POP, IMAP, SMTP, SSH, SNMP, HTTP, FTP, ... |
| 6 - Presentation (표현)  | ASCII, MIME, ...                           |
| 5 - Session (세션)       | TLS, SSL, NetBIOS, ...                     |
| 4 - Transport (전송)     | TLS, SSL, TCP, UDP, ...                    |
| 3 - Network (네트워크)     | IPv4, IPv6, ARP, ...                       |
| 2 - Data Link (데이터 링크) | 이더넷, WiFi, 토큰링, ...                        |
| 1 - Physical (물리)      | 케이블, 광섬유, 전파, ...                          |

**1계층**(물리 계층)은 통신 채널(Wifi, 광섬유, RJ 케이블 등)을 통한 전송을 지원합니다. 단위: 비트.

**2계층**(데이터 링크 계층)은 네트워크 토폴로지(token-ring, star, bus 등), 데이터 분할 및 전송 오류를 지원합니다. 단위: 프레임.

**3계층**(네트워크 계층)은 엔드 투 엔드 데이터 전송을 지원합니다(IP 라우팅 = 게이트웨이). 단위: 패킷.

**4계층**(전송 계층)은 서비스 유형(연결형 또는 비연결형), 암호화 및 흐름 제어를 지원합니다. 단위: 세그먼트 또는 데이터그램.

**5계층**(세션 계층)은 두 컴퓨터 간의 통신을 지원합니다.

**6계층**(표현 계층)은 애플리케이션 층에서 데이터와 독립적인 영역을 나타냅니다. 기본적으로 이 계층은 네트워크 형식에서 애플리케이션 형식으로 또는 애플리케이션  형식에서 네트워크 형식으로 변환됩니다.

**7계층**(응용 계층)은 사용자와의 접촉을 나타냅니다. http, dns, ftp, imap, pop, smtp 등 네트워크에서 제공하는 서비스를 제공합니다.

## 인터페이스의 이름 지정

*lo*는 "**loopback**" 인터페이스로 TCP/IP 프로그램이 로컬 컴퓨터를 떠나지 않고 서로 통신할 수 있습니다. 이를 통해 **시스템의 네트워크 모듈이 제대로 작동**는지 테스트할 수 있으며 localhost에 핑을 보낼 수도 있습니다. localhost를 통해 들어온 모든 패킷은 localhost를 통해 나갑니다. 수신한 패킷은 전송한 패킷과 동일합니다.

Linux 커널은 유형에 따라 특정 접두사로 인터페이스 이름을 할당합니다. 예를 들어 전통적으로 모든 **이더넷** 인터페이스는 **eth**로 시작되었습니다. 접두사 뒤에는 숫자가 붙는데 첫 번째 숫자는 0입니다(eth0, eth1, eth2...). Wi-Fi 인터페이스에는 wlan 접두사가 주어졌습니다.

Rocky8 Linux 배포판에서 systemd는 "X"가 숫자를 나타내는 다음과 같은 새로운 정책으로 인터페이스 이름을 지정합니다.

* `enoX`: 온보드 장치
* `ensX`: PCI Express hotplug 슬롯
* `enpXsX`: 하드웨어 커넥터의 물리적/지리적 위치
* ...

## `ip` 명령 사용

이전 `ifconfig` 명령은 잊어버리십시오! `ip`를 생각하세요!

!!! !!!

    이전 Linux 시스템의 관리자를 위한 설명:
    
    
    히스토리 네트워크 관리 명령은 `ifconfig`입니다. 이 명령은 네트워크 관리자에게 이미 잘 알려진 `ip` 명령으로 대체되었습니다.
    
    `ip` 명령은 **IP 주소, ARP, 라우팅 등**을  관리하기 위한 유일한 명령어입니다.
    
    `ifconfig` 명령은 더 이상 Rocky8에 기본적으로 설치되지 않습니다.
    
    지금 좋은 습관을 들이는 것이 중요합니다.

## hostname

`hostname` 명령은 시스템의 호스트 이름을 표시하거나 설정합니다.

```
hostname [-f] [hostname]
```

| 옵션   | 설명           |
| ---- | ------------ |
| `-f` | FQDN 표시      |
| `-i` | 시스템 IP 주소 표시 |

!!! !!!

    이 명령은 다양한 네트워크 프로그램에서 기기를 식별하는 데 사용됩니다.

호스트 이름을 할당하려면 `hostname` 명령을 사용할 수 있지만, 변경 사항은 다음 부팅 시 유지되지 않습니다. 인수 없이 실행하면 호스트 이름이 표시됩니다.

호스트 이름을 설정하려면 `/etc/sysconfig/network` 파일을 수정해야 합니다.

```
NETWORKING=yes
HOSTNAME=pc-rocky.mondomaine.lan
```

RedHat 부트 스크립트는 또한 시스템의 호스트 이름을 해결하기 위해 `/etc/hosts` 파일을 확인합니다.

시스템이 부팅되면 Linux는 `/etc/sysconfig/network` 파일의 `HOSTNAME` 값을 평가합니다.

그런 다음 `/etc/hosts` 파일을 사용하여 서버의 기본 IP 주소와 해당 호스트 이름을 평가합니다. DNS 도메인 이름을 추론합니다.

따라서 네트워크 서비스의 구성 이전에 이 두 파일을 채워 넣는 것이 중요합니다.

!!! !!!

    이 구성이 제대로 수행되었는지 확인하려면 `hostname` 및 `hostname -f` 명령어가 예상한 값으로 응답해야 합니다.

## /etc/hosts 파일

`/etc/hosts` 파일의 예:

```
@IP <hostname>  [alias]  [# comment]
```

`/etc/hosts` 파일은 정적인 호스트 이름 매핑 테이블로, 다음과 같은 형식을 따릅니다:

```
127.0.0.1       localhost localhost.localdomain
::1             localhost localhost.localdomain
192.168.1.10    rockstar.rockylinux.lan rockstar
```

`/etc/hosts` 파일은 여전히 시스템에서 사용되며, 특히 시스템 FQDN이 결정될 때 부팅 시간에 사용됩니다.

!!! !!!

    RedHat은 시스템 이름이 포함된 적어도 한 줄을 채우도록 권장합니다.

**DNS** 서비스(**D**omain **N** ame **S**ervice)가 구축되어 있지 않은 경우, 각 시스템의 호스트 파일에 모든 이름을 채워 넣어야 합니다.

`/etc/hosts` 파일은 각 항목마다 한 줄을 포함하며, IP 주소, FQDN, 그런 다음 호스트 이름 (순서대로) 및 일련의 별칭 (alias1 alias2 ...)이 포함됩니다. 별칭은 선택 사항입니다.

## `/etc/nsswitch.conf` 파일

**NSS**(**N**ame **S**ervice**S**witch)는 하나 이상의 중앙 집중식 데이터베이스를 대체하기 위해 설정 파일(예: `/etc/passwd`, `/etc/group`, `/etc/hosts`)를 구성할 수 있게 합니다.

`/etc/nsswitch.conf` 파일은 이름 서비스 데이터베이스를 구성하는 데 사용됩니다.

```
passwd: files
shadow: files
group: files
```

이 경우 Linux는 먼저 DNS(`dns` 값)를 쿼리하기 전에 먼저 `/etc/hosts` 파일(`files` 값)에서 일치하는 호스트 이름(`hosts:` 줄)을 찾습니다. 이 동작은 `/etc/nsswitch.conf` 파일을 편집하여 간단하게 변경할 수 있습니다.

물론 호스트, 사용자, 그룹 등에 대한 시스템 요청에 응답하도록 이름 서비스를 구성하여 LDAP, MySQL 또는 기타 서버를 쿼리하는 것을 상상할 수 있습니다.

이름 서비스의 해결은 나중에 뒷부분에서 보게 될 `getent` 명령으로 테스트할 수 있습니다.

## `/etc/resolv.conf` 파일

`/etc/resolv.conf` 파일에는 DNS 이름 확인 구성 정보를 포함합니다.

```
#NetworkManager에서 생성
domain mondomaine.lan
search mondomaine.lan
nameserver 192.168.1.254
```

!!! !!!

    이 파일은 과거 파일입니다. 현재는 직접 채워지지 않습니다!

최신 배포판은 일반적으로 `NetworkManager` 서비스를 통합하고 있습니다. 이 서비스를 사용하면 그래픽 또는 콘솔 모드에서 보다 효율적으로 구성을 관리할 수 있습니다.

네트워크 인터페이스의 구성 파일에서 DNS 서버를 추가할 수 있습니다. 그런 다음 직접 편집하면 안 되는 `/etc/resolv.conf` 파일을 동적으로 채웁니다. 그렇지 않으면 다음에 네트워크 서비스를 시작할 때 구성 변경 사항이 손실됩니다.

## `ip` 명령

`iproute2` 패키지의 `ip` 명령을 사용하면 인터페이스와 해당 라우팅 테이블을 구성할 수 있습니다.

인터페이스의 정보를 표시:

```
[root]# ip link
```

인터페이스 표시:

```
[root]# ip addr show
```

인터페이스 정보 표시:

```
[root]# ip addr show eth0
```

ARP 테이블을 표시:

```
[root]# ip neigh
```

모든 과거 네트워크 관리 명령은 네트워크 관리자에게 잘 알려진 `ip` 명령 아래에 그룹화되었습니다.

## DHCP 구성

**DHCP** 프로토콜(**D**ynamic **H**ost **C**ontrol **P**rotocol)을 사용하면 네트워크를 통해 완전한 IP 구성을 얻을 수 있습니다. 이것은 Rocky Linux에서 네트워크 인터페이스의 기본 구성 모드로, 인터넷 라우터의 네트워크에 연결된 시스템이 추가 구성 없이 작동할 수 있는 이유를 설명합니다.

Rocky Linux에서 인터페이스 구성은 `/etc/sysconfig/network-scripts/` 폴더에서 수행됩니다.

각 Ethernet 인터페이스에 대해 `ifcfg-ethX` 파일을 사용하여 관련된 인터페이스의 구성을 설정할 수 있습니다.

```
DEVICE=eth0
ONBOOT=yes
BOOTPROTO=dhcp
HWADDR=00:0c:29:96:32:e3
```

*  인터페이스 이름: (파일 이름에 포함되어야 함)

```
DEVICE=eth0
```

* 인터페이스 자동 시작:

```
ONBOOT=yes
```

* 인터페이스가 시작될 때 DHCP 요청을 수행:

```
BOOTPROTO=dhcp
```

* MAC 주소 지정(선택 사항이지만, 인터페이스가 여러 개인 경우 유용함).

```
HWADDR=00:0c:29:96:32:e3
```

!!! !!!

    NetworkManager가 설치된 경우 변경 사항이 자동으로 적용됩니다. 그렇지 않은 경우 네트워크 서비스를 다시 시작해야 합니다.

* 네트워크 서비스를 다시 시작:

```
[root]# systemctl restart NetworkManager
```

## 정적 구성

정적 구성에는 최소한 다음이 필요합니다.

```
DEVICE=eth0
ONBOOT=yes
BOOTPROTO=none
IPADDR=192.168.1.10
NETMASK=255.255.255.0
```

* 여기에서는 "dhcp"를 "none"으로 대체하여 정적 구성을 나타냅니다:

```
BOOTPROTO=none
```

* IP 주소:

```
IPADDR=192.168.1.10
```

* 서브넷 마스크:

```
NETMASK=255.255.255.0
```

* 마스크는 접두사로 지정할 수 있습니다.

```
PREFIX=24
```

!!! 주의

    NETMASK 또는 PREFIX 중 하나만 사용해야 합니다! 둘 다 사용하지 마세요!

## 라우팅

![게이트웨이가 있는 네트워크 아키텍처](images/network-002.png)

```
DEVICE=eth0
ONBOOT=yes
BOOTPROTO=none
HWADDR=00:0c:29:96:32:e3
IPADDR=192.168.1.10
NETMASK=255.255.255.0
GATEWAY=192.168.1.254
```

`ip route` 명령:

```
[root]# ip route show
192.168.1.0/24 dev eth0 […] src 192.168.1.10 metric 1
default via 192.168.1.254 dev eth0 proto static
```

여러 개의 네트워크 인터페이스가 있는 환경에서 라우팅 테이블을 읽는 방법을 알아두는 것이 좋습니다.

* 예제에서 보여지는 것처럼 `192.168.1.0/24` 네트워크는 `eth0` 장치에서 직접 연결할 수 있으므로  메트릭은 `1`입니다(라우터를 통과하지 않음).

* 이전 네트워크가 아닌 다른 모든 네트워크는 다시 `eth0` 장치에서 연결할 수 있지만 이번에는 패킷의 주소가 `192.168.1.254` 게이트웨이로 지정됩니다. 라우팅 프로토콜은 정적 프로토콜입니다(Linux에서는 동적으로 할당된 주소에 경로를 추가할 수 있음).

## 이름 풀이

시스템은 다음을 해결해야 합니다.

* FQDN을 IP 주소로 변환

```
www.free.fr = 212.27.48.10
```

* IP 주소를 이름으로 변환

```
212.27.48.10 = www.free.fr
```

* 또는 지역에 대한 정보를 얻으려면:

```
MX de free.fr = 10 mx1.free.fr + 20 mx2.free.fr
```

```
DEVICE=eth0
ONBOOT=yes
BOOTPROTO=none
HWADDR=00:0c:29:96:32:e3
IPADDR=192.168.1.10
NETMASK=255.255.255.0
GATEWAY=192.168.1.254
DNS1=172.16.1.2
DNS2=172.16.1.3
DOMAIN=rockylinux.lan
```

이 경우 DNS에 도달하려면 게이트웨이를 거쳐야 합니다.

```
 #NetworkManager에서 생성
 domain mondomaine.lan
 search mondomaine.lan
 nameserver 172.16.1.2
 nameserver 172.16.1.3
```

파일이 NetworkManager에 의해 업데이트되었습니다.

## 문제 해결

`ping` 명령은 데이터그램을 다른 컴퓨터로 보내고 응답을 기다립니다.

네트워크를 테스트하기 위한 기본 명령어로, 네트워크 인터페이스와 다른 컴퓨터 간의 연결 여부를 확인합니다.

`ping` 명령 구문:

```
ping [-c numerical] destination
```

`-c`(카운트) 옵션은 카운트다운 이후 명령어를 중지할 수 있게 해줍니다.

예시:

```
[root]# ping -c 4 localhost
```

!!! !!!

    가까운 곳에서 먼 곳까지 연결 확인

1) TCP/IP 소프트웨어 계층 검증

```
[root]# ping localhost
```

내부 루프의 "Ping"은 네트워크 인터페이스의 하드웨어 오류를 감지하지 않습니다. 이는 IP 소프트웨어 구성이 올바른지 여부만을 확인합니다.

2) 네트워크 카드의 유효성을 검사

```
[root]# ping 192.168.1.10
```

네트워크 카드의 기능을 확인하기 위해 IP 주소에 핑을 보내야 합니다. 네트워크 케이블이 연결되지 않은 경우, 네트워크 카드는 "down" 상태여야 합니다.

ping이  작동하지 않는 경우, 우선 네트워크 케이블을 네트워크 스위치에 연결하고 인터페이스를 다시 조립(`if up` 명령 참조)한 다음 인터페이스 자체를 확인하세요.

3) 게이트웨이 연결 여부 확인

```
[root]# ping 192.168.1.254
```

4) 원격 서버 연결 여부 확인

```
[root]# ping 172.16.1.2
```

5) DNS 서비스 유효성 검사

```
[root]# Ping www.free.fr
```

### `dig` 명령

`dig` 명령은 DNS 서버를 쿼리하는 데 사용됩니다.

`dig` 명령 구문:

```
dig [-t type] [+short] [name]
```

예시:

```
[root]# dig +short rockylinux.org
76.223.126.88
[root]# dig -t MX +short rockylinux.org                                                          ✔
5 alt1.aspmx.l.google.com.
...
```

`dig` 명령은 DNS 서버를 쿼리하는 데 사용됩니다. 기본적으로 매우 상세한 정보를 표시하지만, 이 동작은 `+short` 옵션으로 변경할 수 있습니다.

도메인의 메일 교환기에 대한 정보를 가져오는 MX **유형**과 같이 확인할 DNS **레코드 유형**을 지정할 수도 있습니다.

### `getent` 명령

`getent`(get entry) 명령은 NSSwitch 항목(`hosts` + `dns`)을 가져오는 데 사용됩니다.

`getent` 명령 구문:


```
getent hosts name
```

예시:

```
[root]# getent hosts rockylinux.org
  76.223.126.88 rockylinux.org
```

DNS 서버만 쿼리하면 `hosts`  파일의 내용을 고려하지 않고 잘못된 결과를 반환할 수 있지만, 이는 현재는 이런 경우가 거의 없습니다.

`/etc/hosts` 파일도 고려하려면 DNS 확인을 처리하는 NSSwitch 이름 서비스를 쿼리해야 합니다.

### `ipcalc` 명령

`ipcalc`(**ip 계산**) 명령은 IP 주소와 마스크로부터 네트워크나 브로드캐스트 주소를 계산하는 데 사용됩니다.

`ipcalc` 명령 구문:

```
ipcalc  [options] IP <netmask>
```

예시:

```
[root]# ipcalc –b 172.16.66.203 255.255.240.0
BROADCAST=172.16.79.255
```

!!! !!!

    이 명령은 인터페이스의 구성 파일을 자동으로 채우는 리디렉션 다음에 나오는 것입니다:

    ```
    [root]# ipcalc –b 172.16.66.203 255.255.240.0 >> /etc/sysconfig/network-scripts/ifcfg-eth0
    ```

| 옵션   | 설명                   |
| ---- | -------------------- |
| `-b` | 브로드캐스트 주소를 표시합니다.    |
| `-n` | 네트워크 주소와 마스크를 표시합니다. |

`ipcalc`는 호스트의 IP 정보를 계산하는 간단한 방법입니다. 다양한 옵션은 `ipcalc`가 표준 출력에 표시해야 하는 정보를 나타냅니다. 여러 옵션을 지정할 수 있습니다. 작업을 위해 IP 주소를 지정해야 합니다. 대부분의 작업은 네트워크 마스크 또는 CIDR 접두사도 필요합니다.

| 짧은 옵션 | 긴 옵션          | 설명                                                                                                                           |
| ----- | ------------- | ---------------------------------------------------------------------------------------------------------------------------- |
| `-b`  | `--broadcast` | 지정된 IP 주소와 네트워크 마스크의 브로드캐스트 주소를 표시합니다.                                                                                       |
| `-h`  | `--hostname`  | DNS를 통해 제공된 IP 주소의 호스트 이름을 표시합니다.                                                                                            |
| `-n`  | `--netmask`   | 지정된 IP 주소에 대한 네트워크 마스크를 계산합니다. IP 주소가 전체 클래스 A, B 또는 C 네트워크의 일부라고 가정합니다. 많은 네트워크는 기본 네트워크 마스크를 사용하지  않으므로 잘못된 값을 반환할 수 있습니다. |
| `-p`  | `--prefix`    | 마스크/IP 주소의 접두사를 나타냅니다.                                                                                                       |
| `-n`  | `--network`   | 주어진 IP 주소와 마스크의 네트워크 주소를 나타냅니다.                                                                                              |
| `-s`  | `--silent`    | 오류 메시지를 표시하지 않습니다.                                                                                                           |

### `ss` 명령

`ss`(**소켓 통계**) 명령은 네트워크에서 수신 대기 중인 포트를 표시합니다.

`ss` 명령 구문:

```
ss [-tuna]
```

예시:

```
[root]# ss –tuna
tcp   LISTEN   0   128   *:22   *:*
```

`ss` 및 `netstat`(다음) 명령은 나머지 Linux 수명 동안 매우 중요합니다.

네트워크 서비스를 구현할 때, 이 두 명령어 중 하나를 사용하여 서비스가 예상대로 지정한 포트에서 수신 대기 중인지 확인하는 것은 매우 일반적입니다.

### `netstat` 명령

!!! 주의

    `netstat` 명령은 이제 더 이상 사용되지 않으며 더 이상 Rocky Linux에 기본적으로 설치되지 않습니다. 여전히 설치된 일부 Linux 버전을 찾을 수 있지만 `netstat`를 사용했을 모든 항목에 대해 `ss`를 사용하는 것이 가장 좋습니다.

`netstat` 명령(**네트워크 통계**)은 네트워크에서 수신 대기 중인 포트를 표시합니다.

`netstat` 명령의 구문:

```
netstat -tapn
```

예시:

```
[root]# netstat –tapn
tcp  0  0  0.0.0.0:22  0.0.0.0:*  LISTEN 2161/sshd
```

### IP 또는 MAC 주소 충돌

구성 오류로 인해 여러 인터페이스가 동일한 IP 주소를 사용하는 경우가 있을 수 있습니다. 네트워크에 여러 DHCP 서버가 있는 경우 또는 동일한 IP 주소가 수동으로 여러 번 할당된 경우에 발생할 수 있습니다.

네트워크가 오작동하고 IP 주소 충돌이 원인일 수 있는 경우 `arp-scan` 소프트웨어를 사용할 수 있습니다(EPEL 리포지토리 필요).

```
$ dnf install arp-scan
```

예시:

```
172.16.1.104  00:01:02:03:04:05       3COM CORPORATION
172.16.1.107  00:0c:29:1b:eb:97       VMware, Inc. 172.16.1.250  00:26:ab:b1:b7:f6       (Unknown)
172.16.1.252  00:50:56:a9:6a:ed       VMWare, Inc. 172.16.1.253  00:50:56:b6:78:ec       VMWare, Inc. 172.16.1.253  00:50:56:b6:78:ec       VMWare, Inc. (DUP: 2)
172.16.1.253  00:50:56:b6:78:ec       VMWare, Inc. (DUP: 3)
172.16.1.253  00:50:56:b6:78:ec       VMWare, Inc. (DUP: 4)
172.16.1.232  88:51:fb:5e:fa:b3       (Unknown) (DUP: 2)
```

!!! 참고

    위의 예에서 볼 수 있듯이 MAC 주소 충돌이 있을 수도 있습니다! 이러한 문제는 가상화 기술과 가상 머신 복사로 인해 발생합니다.

## Hot 구성

`ip` 명령어를 사용하여 인터페이스에 IP 주소를 동적으로 추가할 수 있습니다.

```
ip addr add @IP dev DEVICE
```

예시:

```
[root]# addr ip add 192.168.2.10 dev eth1
```

`ip` 명령어를 사용하여 인터페이스를 활성화 또는 비활성화할 수 있습니다.

```
ip link set DEVICE up
ip link set DEVICE down
```

예시:

```
[root]# ip link set eth1 up
[root]# ip link set eth1 down
```

`ip` 명령어를 사용하여 경로를 추가할 수 있습니다.

```
ip route add [default|netaddr] via @IP [dev device]
```

예시:

```
[root]# ip route add default via 192.168.1.254
[root]# ip route add 192.168.100.0/24 via 192.168.2.254 dev eth1
```

## 요약

이 문서에서 사용되는 파일은 다음과 같습니다.

![네트워크 부분에 구현된 파일 합성](images/network-003.png)

전체 인터페이스 구성은 다음과 같을 수 있습니다(파일 `/etc/sysconfig/network-scripts/ifcfg-eth0`).

```
 DEVICE=eth0
 ONBOOT=yes
 BOOTPROTO=none
 HWADDR=00:0c:29:96:32:e3
 IPADDR=192.168.1.10
 NETMASK=255.255.255.0
 GATEWAY=192.168.1.254
 DNS1=172.16.1.1
 DNS2=172.16.1.2
 DOMAIN=rockylinux.lan
```

문제 해결 방법은 가장 가까운 곳에서 가장 먼 것으로 진행해야 합니다:

1. ping localhost(소프트웨어 테스트)
2. ping IP 주소(하드웨어 테스트)
3. ping 게이트웨이(연결 테스트)
4. ping 원격 서버(라우팅 테스트)
5. DNS 쿼리(dig 또는 ping)

![문제 해결 또는 네트워크 검증 방법](images/network-004.png)
