---
title: 네트워크 구현
---

# 네트워크 구현

이 장에서는 네트워크 작업 및 관리 방법을 배웁니다.

****

**목적**: 이 장에서는 다음을 수행하는 방법에 대해 알아봅니다:

:heavy_check_mark: DHCP를 사용하도록 워크스테이션을 구성합니다.  
:heavy_check_mark: 정적 구성을 사용하도록 워크스테이션을 구성합니다.   
:heavy_check_mark: 게이트웨이를 사용하도록 워크스테이션을 구성합니다.   
:heavy_check_mark: DNS 서버를 사용하도록 워크스테이션을 구성합니다.   
:heavy_check_mark: 워크스테이션의 네트워크 문제를 해결합니다.

:checkered_flag: **network**, **linux**, **ip**

**지식**: :star: :star:  
**복잡성**: :star: :star:

**소요 시간**: 30 분

****

## 개요

이 장을 설명하기 위해 다음 아키텍처를 사용합니다.

![네트워크 아키텍처의 그림](images/network-001.png)

이를 통해 다음을 고려할 수 있습니다:

* LAN(Local Area Network) 통합;
* 원격 서버에 도달하기 위한 게이트웨이 구성;
* DNS 서버 구성 및 이름 풀이의 구현.

장치에 정의할 최소 매개변수는 다음과 같습니다.

* 컴퓨터 이름;
* IP 주소;
* 서브넷 마스크.

예시:

*   `pc-rocky`;
*   `192.168.1.10`;
*   `255.255.255.0`.

CIDR이라는 표기법이 점점 더 자주 사용됩니다: 192.168.1.10/24

IP 주소는 메시지(패킷)의 적절한 라우팅에 사용됩니다. IP 주소는 두 부분으로 나뉩니다.

* 네트워크를 식별하는 고정 부분;
* 네트워크에서 호스트의 식별자.

서브넷 마스크는 다음을 분리하기 위한 **4바이트** 세트입니다.

* 네트워크 주소(**NetID** 또는 **SubnetID**)는 IP 주소와 마스크 사이에 비트 논리 AND를 수행합니다.
* 호스트 주소(**HostID**)는 IP 주소와 마스크 보수 사이의 비트 단위 논리 AND를 수행합니다.

또한 네트워크 내에 특정 주소가 있으며, 이 주소는 식별되어야 합니다. 범위의 첫 번째 주소와 마지막 주소에는 특정 역할이 있습니다.

* 범위의 첫 번째 주소는 **네트워크 주소**입니다. 네트워크를 식별하고 한 네트워크에서 다른 네트워크로 정보를 라우팅하는 데 사용됩니다.

* 범위의 마지막 주소는 **브로드캐스트 주소**입니다. 네트워크의 모든 장치에 정보를 브로드캐스트하는 데 사용됩니다.

### MAC 주소/ IP 주소

**MAC 주소**는 공장에서 기기에 기록된 물리적 식별자입니다. 이를 하드웨어 주소라고도 합니다. 보통 16진수 형식으로 제공되는 6바이트로 구성됩니다(예: 5E:FF:56:A2:AF:15). 3바이트의 제조업체 식별자와 3바이트의 일련 번호로 구성됩니다.

!!! 주의

    이 마지막 설명은 오늘날의 가상화에서 사실이 아닌 부분도 있습니다. MAC 주소를 변경하기 위한 소프트웨어 솔루션도 있습니다.

인터넷 프로토콜(**IP**) 주소는 인터넷 프로토콜을 사용하여 컴퓨터 네트워크에 연결된 각 장치에 영구적 또는 임시로 할당된 식별 번호입니다. 한 부분은 네트워크 주소(경우에 따라 NetID 또는 SubnetID)를 정의하고 다른 부분은 네트워크의 호스트 주소(HostID)를 정의합니다. 각 부분의 상대적 크기는 네트워크 (서브)마스크에 따라 다릅니다.

IPv4 주소는 4바이트로 주소를 정의합니다. 사용 가능한 주소의 수가 포화 상태에 가까워져 새로운 표준이 만들어졌으며 IPv6은 16바이트로 정의되었습니다.

IPv6은 종종 콜론으로 구분된 2바이트 그룹 8개로 표시됩니다. 중요하지 않은 0은 생략할 수 있으며 4개의 연속된 0으로 구성된 하나 이상의 그룹은 이중 콜론으로 대체될 수 있습니다.

서브넷 마스크는 0~128비트입니다. (예: 21ac:0000:0000:0611:21e0:00ba:321b:54da/64 또는 21ac::611:21e0:ba:321b:54da/64)

웹 주소 또는 URL(Uniform Resource Locator)에서 IP 주소 뒤에는 콜론과 포트 주소(데이터가 목적지인 애플리케이션을 나타냄)가 올 수 있습니다. 또한 URL의 혼동을 피하기 위해 IPv6 주소는 대괄호[ ], 콜론, 포트 주소로 표기합니다.

IP 및 MAC 주소는 네트워크에서 고유해야 합니다!

### DNS-도메인

클라이언트 시스템은 DNS(**Domain Name System**, 예: `mydomain.lan`) 도메인의 일부일 수 있습니다.

정규화된 시스템 이름(**FQDN**)은 `pc-rocky.mydomain.lan`이 됩니다.

컴퓨터 집합은 DNS 도메인이라는 논리적, 이름-풀이, 집합으로 그룹화할 수 있습니다. 물론, DNS 도메인은 단일 물리적 네트워크로 제한되지 않습니다.

컴퓨터가 DNS 도메인의 일부가 되려면 DNS 접미사(여기서는 `mydomain.lan`)와 쿼리할 수 있는 서버가 지정되어야 합니다.

### OSI 모델의 리마인더

!!! 참고 "메모리 보조"

    OSI 모델의 계층 순서를 기억하려면 다음 문장을 기억하십시오. __Please Do Not Touch Steven's Pet Alligator__.

| 계층                     | 프로토콜                                       |
| ---------------------- | ------------------------------------------ |
| 7 - Application (응용)   | POP, IMAP, SMTP, SSH, SNMP, HTTP, FTP, ... |
| 6 - Presentation (표현)  | ASCII, MIME, ...                           |
| 5 - Session (세션)       | TLS, SSL, NetBIOS, ...                     |
| 4 - Transport (전송)     | TLS, SSL, TCP, UDP, ...                    |
| 3 - Network (네트워크)     | IPv4, IPv6, ARP, ...                       |
| 2 - Data Link (데이터 링크) | 이더넷, WiFi, 토큰링, ...                        |
| 1 - Physical (물리)      | 케이블, 광섬유, 전파, ...                          |

**1계층**(물리 계층)은 통신 채널(Wifi, 광섬유, RJ 케이블 등)을 통한 전송을 지원합니다. 단위: 비트.

**2계층**(데이터 링크 계층)은 네트워크 토폴로지(token-ring, star, bus 등), 데이터 분할 및 전송 오류를 지원합니다. 단위: 프레임.

**3계층**(네트워크 계층)은 엔드 투 엔드 데이터 전송을 지원합니다(IP 라우팅 = 게이트웨이). 단위: 패킷.

**4계층**(전송 계층)은 서비스 유형(연결 또는 연결되지 않음) 암호화 및 흐름 제어를 지원합니다. 단위: 세그먼트 또는 데이터그램.

**5계층**(세션 계층)은 두 컴퓨터 간의 통신을 지원합니다.

**6계층**(표현 계층)은 애플리케이션 층에서 데이터와 독립적인 영역을 나타냅니다. 기본적으로 이 계층은 네트워크 형식에서 애플리케이션 형식으로 또는 애플리케이션  형식에서 네트워크 형식으로 변환됩니다.

**7계층**(응용 계층)은 사용자와의 접촉을 나타냅니다. http, dns, ftp, imap, pop, smtp 등 네트워크에서 제공하는 서비스를 제공합니다.

## 인터페이스의 이름 지정

*lo*는 "**loopback**" 인터페이스로 TCP/IP 프로그램이 로컬 컴퓨터를 떠나지 않고 서로 통신할 수 있습니다. 이렇게 하면 **시스템의 네트워크 모듈이 제대로 작동**하는지 테스트할 수 있으며 로컬 호스트에 ping을 실행할 수도 있습니다. 로컬 호스트를 통해 들어오는 모든 패킷은 로컬호스트를 통해 나갑니다. 수신된 패킷은 전송된 패킷입니다.

리눅스 커널은 유형에 따라 특정 접두사로 인터페이스 이름을 할당합니다. 예를 들어 전통적으로 모든 **이더넷** 인터페이스는 **eth**로 시작했습니다. 접두사 뒤에는 숫자가 붙는데 첫 번째 숫자는 0입니다(eth0, eth1, eth2...). Wi-Fi 인터페이스에는 wlan 접두사가 지정되었습니다.

Rocky8 Linux 배포판에서 systemd는 "X"가 숫자를 나타내는 다음과 같은 새로운 정책으로 인터페이스 이름을 지정합니다.

* `enoX`: 온보드 장치
* `ensX`: PCI Express hotplug 슬롯
* `enpXsX`: 하드웨어 커넥터의 물리적/지리적 위치
* ...

## `ip` 명령 사용

이전 `ifconfig` 명령은 잊어버리십시오! `ip`를 생각하세요!

!!! 참고

    이전 Linux 시스템 관리자를 위한 의견:
    
    히스토리 네트워크 관리 명령은 `ifconfig`입니다. 이 명령은 네트워크 관리자에게 이미 잘 알려진 `ip` 명령으로 대체되었습니다.
    
    `ip` 명령은 **IP 주소, ARP, 라우팅 등**을 관리하는 유일한 명령입니다.
    
    `ifconfig` 명령은 더 이상 Rocky8에 기본적으로 설치되지 않습니다.
    
    지금 좋은 습관을 들이는 것이 중요합니다.

## hostname

`hostname` 명령은 시스템의 호스트 이름을 표시하거나 설정합니다.

```
hostname [-f] [hostname]
```

| 옵션   | 설명           |
| ---- | ------------ |
| `-f` | FQDN 표시      |
| `-i` | 시스템 IP 주소 표시 |

!!! 팁

    이 명령은 다양한 네트워크 프로그램에서 기기를 식별하는 데 사용됩니다.

호스트 이름을 지정하려면 `hostname` 명령을 사용할 수 있지만 변경 사항은 다음 부팅 시 유지되지 않습니다. 인수가 없는 명령은 호스트 이름을 표시합니다.

호스트 이름을 설정하려면 `/etc/sysconfig/network` 파일을 수정해야 합니다.

```
NETWORKING=yes
HOSTNAME=pc-rocky.mondomaine.lan
```

RedHat 부트 스크립트는 또한 `/etc/hosts` 파일을 참조하여 시스템의 호스트 이름을 확인합니다.

시스템이 부팅되면 Linux는 `/etc/sysconfig/network` 파일의 `HOSTNAME` 값을 평가합니다.

그런 다음 `/etc/hosts` 파일을 사용하여 서버의 기본 IP 주소와 해당 호스트 이름을 평가합니다. DNS 도메인 이름을 추론합니다.

따라서 네트워크 서비스를 구성하기 전에 이 두 파일을 채우는 것이 중요합니다.

!!! 팁

    이 구성이 제대로 수행되었는지 확인하려면 `hostname` 및 `hostname -f` 명령이 예상 값으로 응답해야 합니다.

## /etc/hosts 파일

`/etc/hosts` 파일은 다음 형식을 따르는 정적 호스트 이름 매핑 테이블입니다.

```
@IP <hostname>  [alias]  [# comment]
```

`/etc/hosts` 파일의 예:

```
127.0.0.1       localhost localhost.localdomain
::1             localhost localhost.localdomain
192.168.1.10    rockstar.rockylinux.lan rockstar
```

`/etc/hosts` 파일은 특히 시스템 FQDN이 결정되는 부팅 시 시스템에서 여전히 사용됩니다.

!!! 팁

    RedHat은 시스템 이름을 포함하는 최소 한 줄을 채울 것을 권장합니다.

**DNS** 서비스(**D**omain **N** ame **S**ervice)가 없는 경우 각 시스템의 호스트 파일에 모든 이름을 입력해야 합니다.

`/etc/hosts` 파일에는 IP 주소, FQDN, 호스트 이름(순서대로) 및 일련의 별칭(alias1 alias2 ...)이 있는 항목당 한 줄씩 포함되어 있습니다. 별칭은 옵션입니다.

## `/etc/nsswitch.conf` 파일

**NSS**(**N**ame **S**ervice**S**witch)를 사용하면 구성 파일을(예: `/etc/passwd`, `/etc/group`, `/etc/hosts`) 하나 이상의 중앙 집중식 데이터베이스로 대체할 수 있습니다.

`/etc/nsswitch.conf` 파일은 이름 서비스 데이터베이스를 구성하는 데 사용됩니다.

```
passwd: files
shadow: files
group: files
```

이 경우 Linux는 먼저 DNS(`dns` 값)를 쿼리하기 전에 `/etc/hosts` 파일(`files` 값)에서 일치하는 호스트 이름(`hosts:` 줄)을 찾습니다. 이 동작은 `/etc/nsswitch.conf` 파일을 편집하여 간단하게 변경할 수 있습니다.

물론 호스트, 사용자, 그룹 등에 대한 시스템 요청에 응답하도록 이름 서비스를 구성하여 LDAP, MySQL 또는 기타 서버를 쿼리하는 것을 상상할 수 있습니다.

이름 서비스의 해결은 과정의 뒷부분에서 보게 될 `getent` 명령으로 테스트할 수 있습니다.

## `/etc/resolv.conf` 파일

`/etc/resolv.conf` 파일에는 DNS 이름 확인 구성이 포함되어 있습니다.

```
#NetworkManager에서 생성
domain mondomaine.lan
search mondomaine.lan
nameserver 192.168.1.254
```

!!! 팁

    이 파일은 과거 파일입니다. 더 이상 직접 채워지지 않습니다!

최신 배포판은 일반적으로 `NetworkManager` 서비스를 통합했습니다. 이 서비스를 사용하면 그래픽 또는 콘솔 모드에서 보다 효율적으로 구성을 관리할 수 있습니다.

네트워크 인터페이스의 구성 파일에서 DNS 서버를 추가할 수 있습니다. 그런 다음 직접 편집하면 안 되는 `/etc/resolv.conf` 파일을 동적으로 채웁니다. 그렇지 않으면 다음에 네트워크 서비스를 시작할 때 구성 변경 사항이 손실됩니다.

## `ip` 명령

`iproute2` 패키지의 `ip` 명령을 사용하면 인터페이스와 해당 라우팅 테이블을 구성할 수 있습니다.

인터페이스 표시:

```
[root]# ip link
```

인터페이스 정보 표시:

```
[root]# ip addr show
```

인터페이스의 정보를 표시:

```
[root]# ip addr show eth0
```

ARP 테이블을 표시:

```
[root]# ip neigh
```

모든 과거 네트워크 관리 명령은 네트워크 관리자에게 잘 알려진 `ip` 명령 아래에 그룹화되었습니다.

## DHCP 구성

**DHCP** 프로토콜(**D**ynamic **H**ost **C**ontrol **P**rotocol)을 사용하면 네트워크를 통해 완전한 IP 구성을 얻을 수 있습니다. 이것은 Rocky Linux에서 네트워크 인터페이스의 기본 구성 모드로, 인터넷 라우터의 네트워크에 연결된 시스템이 추가 구성 없이 작동할 수 있는 이유를 설명합니다.

Rocky Linux에서 인터페이스 구성은 `/etc/sysconfig/network-scripts/` 폴더에서 수행됩니다.

각 이더넷 인터페이스에 대해 `ifcfg-ethX` 파일은 관련 인터페이스의 구성을 허용합니다.

```
DEVICE=eth0
ONBOOT=yes
BOOTPROTO=dhcp
HWADDR=00:0c:29:96:32:e3
```

*  인터페이스 이름: (파일 이름에 있어야 함)

```
DEVICE=eth0
```

* 인터페이스 자동 시작:

```
ONBOOT=yes
```

* 인터페이스가 시작될 때 DHCP 요청을 수행합니다.

```
BOOTPROTO=dhcp
```

* MAC 주소를 지정합니다(선택 사항이지만 인터페이스가 여러 개인 경우 유용함).

```
HWADDR=00:0c:29:96:32:e3
```

!!! 팁

    NetworkManager가 설치된 경우 변경 사항이 자동으로 고려됩니다. 그렇지 않으면 네트워크 서비스를 다시 시작해야 합니다.

* 네트워크 서비스를 다시 시작:

```
[root]# systemctl restart NetworkManager
```

## 정적 구성

정적 구성에는 최소한 다음이 필요합니다.

```
DEVICE=eth0
ONBOOT=yes
BOOTPROTO=none
IPADDR=192.168.1.10
NETMASK=255.255.255.0
```

* 여기에서는 "dhcp"를 정적 구성과 동일한 "none"으로 바꿉니다.

```
BOOTPROTO=none
```

* IP 주소:

```
IPADDR=192.168.1.10
```

* 서브넷 마스크:

```
NETMASK=255.255.255.0
```

* 마스크는 접두사로 지정할 수 있습니다.

```
PREFIX=24
```

!!! 주의

    NETMASK 또는 PREFIX를 사용해야 합니다. 둘 다 사용할 수는 없습니다!

## 라우팅

![게이트웨이가 있는 네트워크 아키텍처](images/network-002.png)

```
DEVICE=eth0
ONBOOT=yes
BOOTPROTO=none
HWADDR=00:0c:29:96:32:e3
IPADDR=192.168.1.10
NETMASK=255.255.255.0
GATEWAY=192.168.1.254
```

`ip route` 명령:

```
[root]# ip route show
192.168.1.0/24 dev eth0 […] src 192.168.1.10 metric 1
default via 192.168.1.254 dev eth0 proto static
```

특히 다중 네트워크 인터페이스가 있는 환경에서 라우팅 테이블을 읽는 방법을 아는 것이 좋습니다.

* 표시된 예에서 `192.168.1.0/24` 네트워크는 `eth0` 장치에서 직접 연결할 수 있으므로 `1`에 메트릭이 있습니다(라우터를 통과하지 않음).

* 이전 네트워크가 아닌 다른 모든 네트워크는 다시 `eth0` 장치에서 연결할 수 있지만 이번에는 패킷의 주소가 `192.168.1.254` 게이트웨이로 지정됩니다. 라우팅 프로토콜은 정적 프로토콜입니다(Linux에서는 동적으로 할당된 주소에 경로를 추가할 수 있음).

## 이름 풀이

시스템은 다음을 해결해야 합니다.

* FQDN을 IP 주소로 변환

```
www.free.fr = 212.27.48.10
```

* IP 주소를 이름으로 변환

```
212.27.48.10 = www.free.fr
```

* 또는 지역에 대한 정보를 얻으려면:

```
MX de free.fr = 10 mx1.free.fr + 20 mx2.free.fr
```

```
DEVICE=eth0
ONBOOT=yes
BOOTPROTO=none
HWADDR=00:0c:29:96:32:e3
IPADDR=192.168.1.10
NETMASK=255.255.255.0
GATEWAY=192.168.1.254
DNS1=172.16.1.2
DNS2=172.16.1.3
DOMAIN=rockylinux.lan
```

이 경우 DNS에 도달하려면 게이트웨이를 거쳐야 합니다.

```
 #NetworkManager에서 생성
 domain mondomaine.lan
 search mondomaine.lan
 nameserver 172.16.1.2
 nameserver 172.16.1.3
```

파일이 NetworkManager에 의해 업데이트되었습니다.

## 문제 해결

`ping` 명령은 데이터그램을 다른 시스템으로 보내고 응답을 기다립니다.

네트워크 인터페이스와 다른 네트워크 인터페이스 간의 연결을 확인하기 때문에 네트워크 테스트를 위한 기본 명령입니다.

`ping` 명령 구문:

```
ping [-c numerical] destination
```

`-c`(카운트) 옵션을 사용하면 카운트다운(초) 후 명령을 중지할 수 있습니다.

예시:

```
[root]# ping -c 4 localhost
```

!!! 팁

    가까운 곳에서 먼 곳까지 연결 확인

1) TCP/IP 소프트웨어 계층 검증

```
[root]# ping localhost
```

내부 루프의 "Ping"은 네트워크 인터페이스에서 하드웨어 오류를 감지하지 않습니다. 단순히 IP 소프트웨어 구성이 올바른지 여부를 결정합니다.

2) 네트워크 카드의 유효성을 검사

```
[root]# ping 192.168.1.10
```

네트워크 카드가 작동하는지 확인하려면 이제 해당 IP 주소를 ping해야 합니다. 네트워크 케이블이 연결되지 않은 경우 네트워크 카드는 "다운" 상태여야 합니다.

ping이 작동하지 않으면 먼저 네트워크 스위치에 연결된 네트워크 케이블을 확인하고 인터페이스를 다시 조립한 다음(`if up` 명령 참조) 인터페이스 자체를 확인하십시오.

3) 게이트웨이 연결 확인

```
[root]# ping 192.168.1.254
```

4) 원격 서버 연결 확인

```
[root]# ping 172.16.1.2
```

5) DNS 서비스 유효성 검사

```
[root]# Ping www.free.fr
```

### `dig` 명령

`dig` 명령은 DNS 서버를 쿼리하는 데 사용됩니다.

`dig` 명령 구문:

```
dig [-t type] [+short] [name]
```

예시:

```
[root]# dig +short rockylinux.org
76.223.126.88
[root]# dig -t MX +short rockylinux.org                                                          ✔
5 alt1.aspmx.l.google.com.
...
```

`dig` 명령은 DNS 서버를 쿼리하는 데 사용됩니다. 기본적으로 매우 장황하지만 이 동작은 `+short` 옵션으로 변경할 수 있습니다.

도메인의 메일 교환기에 대한 정보를 가져오는 MX **유형**과 같이 확인할 DNS **레코드 유형**을 지정할 수도 있습니다.

### `getent` 명령

`getent`(항목 가져오기) 명령은 NSSwitch 항목(`hosts` + `dns`)을 가져오는 데 사용됩니다.

`getent` 명령 구문:


```
getent hosts name
```

예시:

```
[root]# getent hosts rockylinux.org
  76.223.126.88 rockylinux.org
```

DNS 서버만 쿼리하면 `hosts` 파일의 내용을 고려하지 않은 잘못된 결과가 반환될 수 있지만 요즘에는 이런 경우가 거의 없습니다.

`/etc/hosts` 파일도 고려하려면 DNS 확인을 처리하는 NSSwitch 이름 서비스를 쿼리해야 합니다.

### `ipcalc` 명령

`ipcalc`(**ip 계산**) 명령은 IP 주소와 마스크에서 네트워크 또는 브로드캐스트의 주소를 계산하는 데 사용됩니다.

`ipcalc` 명령 구문:

```
ipcalc  [options] IP <netmask>
```

예시:

```
[root]# ipcalc –b 172.16.66.203 255.255.240.0
BROADCAST=172.16.79.255
```

!!! 팁

    이 명령은 인터페이스의 구성 파일을 자동으로 채우는 리디렉션 다음에 나오는 것입니다:

    ```
    [root]# ipcalc –b 172.16.66.203 255.255.240.0 >> /etc/sysconfig/network-scripts/ifcfg-eth0
    ```

| 옵션   | 설명                   |
| ---- | -------------------- |
| `-b` | 브로드캐스트 주소를 표시합니다.    |
| `-n` | 네트워크 주소와 마스크를 표시합니다. |

`ipcalc`는 호스트의 IP 정보를 계산하는 간단한 방법입니다. 다양한 옵션은 `ipcalc`가 표준 출력에 표시해야 하는 정보를 나타냅니다. 여러 옵션을 지정할 수 있습니다. 작동할 IP 주소를 지정해야 합니다. 대부분의 작업에는 네트워크 마스크 또는 CIDR 접두사도 필요합니다.

| 짧은 옵션 | 긴 옵션          | 설명                                                                                                                         |
| ----- | ------------- | -------------------------------------------------------------------------------------------------------------------------- |
| `-b`  | `--broadcast` | 지정된 IP 주소와 네트워크 마스크의 브로드캐스트 주소를 표시합니다.                                                                                     |
| `-h`  | `--hostname`  | DNS를 통해 제공된 IP 주소의 호스트 이름을 표시합니다.                                                                                          |
| `-n`  | `--netmask`   | 주어진 IP 주소에 대한 네트워크 마스크를 계산합니다. IP 주소가 전체 클래스 A, B 또는 C 네트워크의 일부라고 가정합니다. 많은 네트워크는 기본 네트워크 마스크를 사용하지 않으며 이 경우 잘못된 값이 반환됩니다. |
| `-p`  | `--prefix`    | 마스크/IP 주소의 접두사를 나타냅니다.                                                                                                     |
| `-n`  | `--network`   | 주어진 IP 주소와 마스크의 네트워크 주소를 나타냅니다.                                                                                            |
| `-s`  | `--silent`    | 오류 메시지를 표시하지 않습니다.                                                                                                         |

### `ss` 명령

`ss`(**소켓 통계**) 명령은 네트워크의 수신 포트를 표시합니다.

`ss` 명령 구문:

```
ss [-tuna]
```

예시:

```
[root]# ss –tuna
tcp   LISTEN   0   128   *:22   *:*
```

`ss` 및 `netstat`(다음) 명령은 나머지 Linux 수명 동안 매우 중요합니다.

네트워크 서비스를 구현할 때 서비스가 예상 포트에서 수신 대기하고 있는지 이 두 명령 중 하나로 확인하는 것이 매우 일반적입니다.

### `netstat` 명령

!!! 주의

    `netstat` 명령은 이제 더 이상 사용되지 않으며 더 이상 Rocky Linux에 기본적으로 설치되지 않습니다. 여전히 설치된 일부 Linux 버전을 찾을 수 있지만 `netstat`를 사용했을 모든 항목에 대해 `ss`를 사용하는 것이 가장 좋습니다.

`netstat` 명령(**네트워크 통계**)은 네트워크의 수신 포트를 표시합니다.

`netstat` 명령의 구문:

```
netstat -tapn
```

예시:

```
[root]# netstat –tapn
tcp  0  0  0.0.0.0:22  0.0.0.0:*  LISTEN 2161/sshd
```

### IP 또는 MAC 주소 충돌

잘못된 구성으로 인해 여러 인터페이스가 동일한 IP 주소를 사용할 수 있습니다. 이는 네트워크에 여러 DHCP 서버가 있거나 동일한 IP 주소가 수동으로 여러 번 할당된 경우에 발생할 수 있습니다.

네트워크가 오작동하고 IP 주소 충돌이 원인일 수 있는 경우 `arp-scan` 소프트웨어를 사용할 수 있습니다(EPEL 리포지토리 필요).

```
$ dnf install arp-scan
```

예시:

```
172.16.1.104  00:01:02:03:04:05       3COM CORPORATION
172.16.1.107  00:0c:29:1b:eb:97       VMware, Inc.
172.16.1.250  00:26:ab:b1:b7:f6       (Unknown)
172.16.1.252  00:50:56:a9:6a:ed       VMWare, Inc.
172.16.1.253  00:50:56:b6:78:ec       VMWare, Inc.
172.16.1.253  00:50:56:b6:78:ec       VMWare, Inc. (DUP: 2)
172.16.1.253  00:50:56:b6:78:ec       VMWare, Inc. (DUP: 3)
172.16.1.253  00:50:56:b6:78:ec       VMWare, Inc. (DUP: 4)
172.16.1.232  88:51:fb:5e:fa:b3       (Unknown) (DUP: 2)
```

!!! 팁

    위의 예에서 볼 수 있듯이 MAC 주소 충돌이 있을 수도 있습니다! 이러한 문제는 가상화 기술과 가상 머신 복사로 인해 발생합니다.

## Hot 구성

`ip` 명령은 인터페이스에 IP 주소를 추가할 수 있습니다.

```
ip addr add @IP dev DEVICE
```

예시:

```
[root]# addr ip add 192.168.2.10 dev eth1
```

`ip` 명령은 인터페이스의 활성화 또는 비활성화를 허용합니다.

```
ip link set DEVICE up
ip link set DEVICE down
```

예시:

```
[root]# ip link set eth1 up
[root]# ip link set eth1 down
```

`ip` 명령은 경로를 추가하는 데 사용됩니다.

```
ip route add [default|netaddr] via @IP [dev device]
```

예시:

```
[root]# ip route add default via 192.168.1.254
[root]# ip route add 192.168.100.0/24 via 192.168.2.254 dev eth1
```

## 요약하면,

이 장에서 사용되는 파일은 다음과 같습니다.

![네트워크 부분에 구현된 파일 합성](images/network-003.png)

전체 인터페이스 구성은 다음과 같을 수 있습니다(파일 `/etc/sysconfig/network-scripts/ifcfg-eth0`).

```
 DEVICE=eth0
 ONBOOT=yes
 BOOTPROTO=none
 HWADDR=00:0c:29:96:32:e3
 IPADDR=192.168.1.10
 NETMASK=255.255.255.0
 GATEWAY=192.168.1.254
 DNS1=172.16.1.1
 DNS2=172.16.1.2
 DOMAIN=rockylinux.lan
```

문제 해결 방법은 가장 가까운 곳에서 가장 먼 곳으로 이동해야 합니다.

1. ping localhost(소프트웨어 테스트)
2. ping IP 주소(하드웨어 테스트)
3. ping 게이트웨이(연결 테스트)
4. ping 원격 서버(라우팅 테스트)
5. DNS 쿼리(dig 또는 ping)

![문제 해결 또는 네트워크 검증 방법](images/network-004.png)
