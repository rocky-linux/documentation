---
title: Менеджер процесів
---

# Менеджер процесів

У цьому розділі ви дізнаєтесь як працювати з процесами.

****

**Цілі**: у цьому розділі майбутні адміністратори Linux дізнаються, як:

:heavy_check_mark: Розпізнавати `PID` і `PPID` процесу;  
:heavy_check_mark: Перегляд і пошук процесів;  
:heavy_check_mark: Керування процесами.

:checkered_flag: **процес**, **linux**

**Знання**: :star: :star:  
**Складність**: :star:

**Час читання**: 20 хвилин

****

## Загальні положення

Операційна система складається з процесів. Ці процеси виконуються в певному порядку і пов’язані один з одним. Існує дві категорії процесів: зосереджені на середовищі користувача та зосереджені на апаратному середовищі.

Коли програма виконується, система створить процес, помістивши дані програми та код у пам’ять і створивши **стек часу виконання**. Таким чином, процес є екземпляром програми з асоційованим середовищем процесора (порядковий лічильник, регістри тощо) і середовищем пам’яті.

Кожен процес має:

* *PID*: ***P**rocess **ID**entifier*, унікальний ідентифікатор процесу
* *PPID*: ***P**arent **P**rocess **ID**entifier*, унікальний ідентифікатор батьківського процесу

Завдяки послідовним відгалуженням процес `init` є батьком усіх процесів.

* Процес завжди створюється батьківським процесом;
* Батьківський процес може мати кілька дочірніх процесів.

Між процесами існує зв’язок «батьківський/дочірній». Дочірній процес є результатом того, що батьківський процес викликає примітив *fork()* і дублює свій власний код для створення дочірнього. *PID* дочірнього процесу повертається до батьківського процесу, щоб він міг з ним спілкуватися. Кожен дочірній елемент має ідентифікатор свого батька, *PPID*.

Номер *PID* представляє процес під час виконання. Після завершення процесу номер знову доступний для іншого процесу. Виконання тієї самої команди кілька разів створюватиме різні *PID* щоразу.<!-- TODO !\[Parent/child relationship between processes\](images/FON-050-001.png) -->!!! Важливо

    Процеси не слід плутати з _потоками_. Кожен процес має власний контекст пам’яті (ресурси та адресний простір), тоді як _потоки_ того самого процесу спільно використовують той самий контекст.

## Перегляд процесів

Команда `ps` відображає стан запущених процесів.

```bash
ps [-e] [-f] [-u login]
```

Приклад:

```bash
# ps -fu root
```

| Опція      | Опис                               |
| ---------- | ---------------------------------- |
| `-e`       | Відображає всі процеси.            |
| `-f`       | Відображає повний список форматів. |
| `-u` login | Відображає процеси користувача.    |

Деякі додаткові опції:

| Опція                 | Опис                                               |
| --------------------- | -------------------------------------------------- |
| `-g`                  | Відображає процеси в групі.                        |
| `-t tty`              | Відображає процеси, запущені з терміналу.          |
| `-p PID`              | Відображає інформацію про процес.                  |
| `-H`                  | Відображає інформацію у вигляді дерева.            |
| `-l`                  | Відображення в довгому форматі.                    |
| `--sort COL`          | Сортує результат відповідно до стовпця.            |
| `--headers`           | Відображає заголовок на кожній сторінці терміналу. |
| `--format "%a %b %c"` | Налаштовує вихідний формат відображення.           |

Якщо параметр не вказано, команда `ps` відображає лише процеси, що виконуються з поточного терміналу.

Результат відображається в стовпцях:

```bash
# ps -ef
UID  PID PPID C STIME  TTY TIME      CMD
root 1   0    0 Jan01  ?   00:00/03  /sbin/init
```

| Колонка | Опис                                 |
| ------- | ------------------------------------ |
| `UID`   | Користувач-власник.                  |
| `PID`   | Ідентифікатор процесу.               |
| `PPID`  | Ідентифікатор батьківського процесу. |
| `C`     | Пріоритетність процесу.              |
| `STIME` | Дата і час виконання.                |
| `TTY`   | Термінал виконання.                  |
| `TIME`  | Тривалість обробки.                  |
| `CMD`   | Команда виконана.                    |

Поведінку елемента керування можна повністю налаштувати:

```bash
# ps -e --format "%P %p %c %n" --sort ppid --headers
 PPID   PID COMMAND          NI
    0     1 systemd           0
    0     2 kthreadd          0
    1   516 systemd-journal   0
    1   538 systemd-udevd     0
    1   598 lvmetad           0
    1   643 auditd           -4
    1   668 rtkit-daemon      1
    1   670 sssd              0
```

## Види процесів

Процес користувача:

* запускається з терміналу, пов’язаного з користувачем;
* отримує доступ до ресурсів через запити або демони.

Системний процес (*demon*):

* запускається системою;
* не пов’язаний з жодним терміналом і належить користувачеві системи (часто `root`);
* завантажується під час завантаження, знаходиться в пам'яті та очікує на виклик;
* зазвичай ідентифікується літерою `d`, пов’язаною з назвою процесу.

Тому системні процеси називаються демонами (***D**isk **A**nd **E**xecution **MON**itor*).

## Дозволи та права

Під час виконання команди облікові дані користувача передаються створеному процесу.

За замовчуванням фактичні `UID` та `GID` (процесу) ідентичні **фактичному** ` UID` і `GID` (`UID` і `GID` користувача, який виконав команду).

Якщо для команди встановлено `SUID` (та/або `SGID`), фактичний `UID` (та/або `GID`) стає власником (та/або групою власників) команди, а не користувачем або групою користувачів, які видали команду. Тому ефективні та реальні **UID** **різняються**.

Щоразу, коли здійснюється доступ до файлу, система перевіряє права процесу відповідно до його ефективних ідентифікаторів.

## Управління процесами

Процес не може виконуватися безкінечно, оскільки це зашкодить іншим запущеним процесам і завадить багатозадачності.

Таким чином, загальний доступний час обробки ділиться на невеликі діапазони, і кожен процес (з пріоритетом) звертається до процесора в послідовний спосіб. Процес займе кілька станів протягом свого життя серед станів:

* готовий: очікується доступність процесу;
* у виконанні: отримує доступ до процесора;
* призупинено: очікування на введення/виведення (введення/виведення);
* зупинено: очікування сигналу від іншого процесу;
* зомбі: запит на знищення;
* мертвий: батьківський процес завершує дочірній процес

Послідовність наприкінці процесу така:

1. Закриття відкритих файлів;
2. Звільнення використаної пам'яті;
3. Надсилання сигналу батьківському та дочірньому процесам.

Коли батьківський процес помирає, його дочірні процеси вважаються сиротами. Потім вони приймаються процесом `init`, який їх знищує.

### Пріоритет процесу

GNU/Linux належить до сімейства операційних систем із розподілом часу. Процесори працюють за принципом розподілу часу, і кожен процес займає певний час процесора. Процеси класифікуються за пріоритетністю:

* Процес у реальному часі: Алгоритм планування в реальному часі планує процес із пріоритетом **0-99**.
* Звичайні процеси: процеси з динамічними пріоритетами **100-139** плануються за допомогою абсолютно справедливого алгоритму планування.
* Відмінне значення: параметр, який використовується для налаштування пріоритету звичайного процесу. Діапазон **-20-19**.

Пріоритет процесу за замовченням становить **0**.

### Режими роботи

Процеси можуть запускатися двома способами:

* **синхронний**: користувач втрачає доступ до оболонки під час виконання команди. Після завершення виконання процесу знову з’являється командний рядок.
* **асинхронний**: процес обробляється у фоновому режимі. Командний рядок негайно відображається знову.

Обмеження асинхронного режиму:

* команда або сценарій не повинні чекати введення з клавіатури;
* команда чи сценарій не повинні повертати жодного результату на екран;
* вихід із оболонки завершує процес.

## Елементи керування процесом

### Команда `kill`

Команда `kill` надсилає процесу сигнал зупинки.

```bash
kill [-signal] PID
```

Приклад:

```bash
kill -9 1664
```

| Код  | Сигнал    | Опис                                                                                                             |
| ---- | --------- | ---------------------------------------------------------------------------------------------------------------- |
| `2`  | *SIGINT*  | Негайне припинення процесу                                                                                       |
| `9`  | *SIGKILL* | Перериває процес (++control+"d"++)                                                                               |
| `15` | *SIGTERM* | Чисте завершення процесу                                                                                         |
| `18` | *SIGCONT* | Відновлює процес. Процеси, які використовують сигнал SIGSTOP, можуть використовувати його для продовження роботи |
| `19` | *SIGSTOP* | Призупиняє процес (Зупиняє процес). Ефект цього сигналу еквівалентний ++ctrl+"z"++                               |

Сигнали є засобами зв'язку між процесами. Команда `kill` надсилає сигнал процесу.

!!! tip "Порада"

    Повний список сигналів, які враховує команда kill, становиться доступним після введення команди:

    ```
    $ man 7 signal
    ```

### Команда `nohup`

`nohup` дозволяє запускати процес незалежно від підключення.

```bash
nohup command
```

Приклад:

```bash
nohup myprogram.sh 0</dev/null &
```

`nohup` ігнорує сигнал `SIGHUP`, який надсилається, коли користувач виходить із системи.

!!! note "Примітка"

    `nohup` обробляє стандартний вихід і помилку, але не стандартний вхід, отже, перенаправлення цього введення до `/dev/null`.

### [Ctrl] + [z]

Синхронний процес тимчасово призупиняється одночасним натисканням клавіш ++control+"z"++. Доступ до підказки відновлюється після відображення номера щойно призупиненого процесу.

### Інструкція `&`

Інструкція `&` виконує команду асинхронно (тоді команда називається *job*) і відображає кількість *job*. Після цього доступ до підказки повертається.

Приклад:

```bash
$ time ls -lR / > list.ls 2> /dev/null &
[1] 15430
$
```

Номер *завдання* отримується під час обробки у фоновому режимі та відображається в квадратних дужках, а потім номер `PID`.

### Команди `fg` і `bg`

Команда `fg` виводить процес на передній план:

```bash
$ time ls -lR / > list.ls 2>/dev/null &
$ fg 1
time ls -lR / > list.ls 2/dev/null
```

тоді як команда `bg` поміщає його у фоновий режим:

```bash
[CTRL]+[Z]
^Z
[1]+ Stopped
$ bg 1
[1] 15430
$
```

Незалежно від того, чи був він у фоновому режимі під час створення за допомогою аргументу `&` чи пізніше за допомогою клавіш ++control+"z"++, процес можна повернути на передній план за допомогою `fg` та номер її завдання.

### Команда `jobs`

Команда `jobs` відображає список процесів, що виконуються у фоновому режимі, і вказує їхні номери завдань.

Приклад:

```bash
$ jobs
[1]- Running    sleep 1000
[2]+ Running    find / > arbo.txt
```

Стовпці представляють:

1. job номер;
2. порядок виконання процесів

   * a `+` : процес, вибраний за замовчуванням для команд `fg` і `bg`, коли не вказано номер завдання
   * a `-` : цей процес є наступним процесом `+`

3. *Запущено* (запущений процес) або *Зупинено* (призупинений процес)
4. команда

### Команди `nice` та `renice`

Команда `nice` дозволяє виконати команду, вказавши її пріоритет.

```bash
nice priority command
```

Приклад використання:

```bash
nice --adjustment=-5 find / -name "file"

nice -n -5 find / -name "file"

nice --5 find / -name "file"

nice -n 5 find / -name "file"

nice find / -name "file"
```

На відміну від `root`, звичайний користувач може лише зменшити пріоритет процесу, і прийматимуться лише значення від 0 до 19.

Як показано у прикладі вище, перші три команди вказують на встановлення значення Nice на "-5", тоді як друга команда є нашим рекомендованим використанням. Четверта команда вказує на встановлення значення Nice на «5». Для п’ятої команди відсутність параметрів означає, що значення Nice встановлено на «10».

!!! tip "Порада"

    «Nice» - це абревіатура від «niceness». 
    
    Безпосереднє введення команди `nice` поверне значення Nice поточної оболонки. 
    
    Ви можете зняти обмеження значення Nice для кожного користувача чи групи, змінивши файл `/etc/security/limits.conf`.

Команда `renice` дозволяє змінити пріоритет запущеного процесу.

```bash
renice priority [-g GID] [-p PID] [-u UID]
```

Приклад:

```bash
renice -n 15 -p 1664
```

| Опція | Опис                           |
| ----- | ------------------------------ |
| `-g`  | `GID` групи власників процесу. |
| `-p`  | `PID` процесу.                 |
| `-u`  | `UID` власника процесу.        |

Команда `renice` діє на вже запущені процеси. Таким чином, можна змінити пріоритет певного процесу та кількох процесів, що належать користувачеві чи групі.

!!! tip "Порада"

    Команда `pidof` у поєднанні з командою `xargs` (див. курс Advanced Commands) дозволяє застосувати новий пріоритет в одній команді:

    ```
    $ pidof sleep | xargs renice -n 20
    ```

Щоб адаптуватися до різних дистрибутивів, вам слід якомога частіше використовувати такі командні форми, як `nice -n 5` або `renice -n 6`.

### Команда `top`

Команда `top` відображає процеси та споживання ними ресурсів.

```bash
$ top
PID  USER PR NI ... %CPU %MEM  TIME+    COMMAND
2514 root 20 0       15    5.5 0:01.14   top
```

| Колонка   | Опис                        |
| --------- | --------------------------- |
| `PID`     | Ідентифікатор процесу.      |
| `USER`    | Користувач-власник.         |
| `PR`      | Пріоритет процесу.          |
| `NI`      | Значення пріоритету.        |
| `%CPU`    | Завантаження процесора.     |
| `%MEM`    | Навантаження на пам'ять.    |
| `TIME+`   | Час використання процесора. |
| `COMMAND` | Команда виконана.           |

Команда `top` дозволяє керувати процесами в реальному часі та в інтерактивному режимі.

### Команди `pgrep` і `pkill`

Команда `pgrep` шукає назву процесу в запущених процесах і відображає *PID*, що відповідає критеріям вибору, у стандартному виводі.

Команда `pkill` надішле кожному процесу вказаний сигнал (за замовчуванням *SIGTERM*).

```bash
pgrep process
pkill [option] [-signal] process
```

Приклади:

* Отримайте номер процесу з `sshd`:

  ```bash
  pgrep -u root sshd
  ```

* Закрийте всі процеси `tomcat`:

  ```bash
  pkill tomcat
  ```

!!! note "Примітка"

    Перш ніж вбивати процес, найкраще точно знати, для чого він призначений. Інакше це може призвести до системних збоїв або інших непередбачуваних проблем.

Окрім надсилання сигналів до відповідних процесів, команда `pkill` також може завершити сеанс підключення користувача відповідно до номера терміналу, наприклад:

```bash
pkill -t pts/1
```

### Команда `killall`

Функції цієї команди приблизно такі ж, як і команди `pkill`. Використання —`killall [option] [ -s SIGNAL | -SIGNAL ] NAME`. Стандартним сигналом є *SIGTERM*.

| Опції | Опис                                       |
|:----- |:------------------------------------------ |
| `-l`  | містить список усіх відомих назв сигналів  |
| `-i`  | просить підтвердження перед закінченням    |
| `-I`  | збіг імені процесу без урахування регістру |

Приклад:

```bash
killall tomcat
```

### Команда `pstree`

Ця команда відображає прогрес у стилі дерева, і її використання - `pstree [option]`.

| Опція | Опис                                     |
|:----- |:---------------------------------------- |
| `-p`  | Відображає PID процесу                   |
| `-n`  | сортує вихідні дані за PID               |
| `-h`  | висвітлює поточний процес і його предків |
| `-u`  | показує переходи uid                     |

```bash
$ pstree -pnhu
systemd(1)─┬─systemd-journal(595)
           ├─systemd-udevd(625)
           ├─auditd(671)───{auditd}(672)
           ├─dbus-daemon(714,dbus)
           ├─NetworkManager(715)─┬─{NetworkManager}(756)
           │                     └─{NetworkManager}(757)
           ├─systemd-logind(721)
           ├─chronyd(737,chrony)
           ├─sshd(758)───sshd(1398)───sshd(1410)───bash(1411)───pstree(1500)
           ├─tuned(759)─┬─{tuned}(1376)
           │            ├─{tuned}(1381)
           │            ├─{tuned}(1382)
           │            └─{tuned}(1384)
           ├─agetty(763)
           ├─crond(768)
           ├─polkitd(1375,polkitd)─┬─{polkitd}(1387)
           │                       ├─{polkitd}(1388)
           │                       ├─{polkitd}(1389)
           │                       ├─{polkitd}(1390)
           │                       └─{polkitd}(1392)
           └─systemd(1401)───(sd-pam)(1404)
```

### Сирітський процес і процес зомбі

**Процес-сирота**: коли батьківський процес помирає, їхні нащадки вважаються сиротами. Процес ініціалізації приймає ці унікальні процеси стану, і збір стану завершується, доки вони не будуть знищені. Концептуально процес сиротинства не несе жодної шкоди.

**зомбі-процес**: після того, як дочірній процес завершує свою роботу, його батьківський процес повинен викликати функцію обробки сигналу wait() або waitpid(), щоб отримати статус завершення дочірнього процесу. Якщо батьківський процес цього не робить, хоча дочірній процес уже завершив роботу, він усе ще зберігає деяку інформацію про статус виходу в системній таблиці процесів. Оскільки батьківський процес не може отримати інформацію про стан дочірнього процесу, ці процеси продовжуватимуть займати ресурси в таблиці процесів. Ми називаємо процеси в цьому стані зомбі.

Небезпека:

* Вони займають системні ресурси та спричиняють зниження продуктивності машини.
* Не вдалося створити нові дочірні процеси.

Як ми можемо перевірити наявність зомбі-процесів у поточній системі?

```bash
ps -lef | awk '{print $2}' | grep Z
```

Ці символи можуть з’являтися в цьому стовпці:

* **D** - безперервний сон (зазвичай IO)
* **I** - Неактивний потік ядра
* **R** - запущений або у черзі виконання
* **S** - переривчастий сон (очікування завершення події)
* **T** - зупинено сигналом керування
* **t** - зупинено налагоджувачем під час трасування
* **W** - сторінковий (недійсний з ядра 2.6.xx)
* **X** - мертвий (ніколи його не можна побачити)
* **Z** - неіснуючий ("зомбі") процес, припинений, але не пожнутий своїм батьком
