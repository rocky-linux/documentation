---
title: Менеджер процесів
---

# Менеджер процесів

У цьому розділі ви дізнаєтесь як працювати з процесами.

****

**Цілі**: у цьому розділі майбутні адміністратори Linux дізнаються, як:

:heavy_check_mark: Розпізнати `PID` і `PPID` процесу;   
:heavy_check_mark: Переглянути та шукати процеси;   
:heavy_check_mark: Керувати процесами.

:checkered_flag: **процес**, **linux**

**Знання**: :star: :star:   
**Складність**: :star:

**Час читання**: 20 хвилин

****

## Загальні положення

Операційна система складається з процесів. Ці процеси виконуються в певному порядку і пов’язані один з одним. Існує дві категорії процесів: зосереджені на середовищі користувача та зосереджені на апаратному середовищі.

Коли програма виконується, система створить процес, помістивши дані програми та код у пам’ять і створивши **стек часу виконання**. Таким чином, процес є екземпляром програми з асоційованим середовищем процесора (порядковий лічильник, регістри тощо) і середовищем пам’яті.

Кожен процес має:

* a _PID_: _**P**rocess **ID**entifier_, унікальний ідентифікатор процесу;
* a _PPID_: _**P**arent **P**process **ID**entifier_, унікальний ідентифікатор батьківського процесу.

Завдяки послідовним відгалуженням процес `init` є батьком усіх процесів.

* Процес завжди створюється батьківським процесом;
* Батьківський процес може мати кілька дочірніх процесів.

Між процесами існує зв’язок «батьківський/дочірній». Дочірній процес є результатом того, що батьківський процес викликає примітив _fork()_ і дублює свій власний код для створення дочірнього. _PID_ дочірнього процесу повертається до батьківського процесу, щоб він міг з ним спілкуватися. Кожен дочірній елемент має ідентифікатор свого батька, _PPID_.

Номер _PID_ представляє процес під час виконання. Після завершення процесу номер знову доступний для іншого процесу. Виконання тієї самої команди кілька разів створюватиме різні _PID_ щоразу.<!-- TODO !\[Parent/child relationship between processes\](images/FON-050-001.png) -->!!! Важливо

    Процеси не слід плутати з _потоками_. Кожен процес має власний контекст пам’яті (ресурси та адресний простір), тоді як _потоки_ того самого процесу спільно використовують той самий контекст.

## Перегляд процесів

Команда `ps` відображає стан запущених процесів.
```
ps [-e] [-f] [-u login]
```

Приклад:
```
# ps -fu root
```

| Опція      | Опис                             |
| ---------- | -------------------------------- |
| `-e`       | Відображає всі процеси.          |
| `-f`       | Відображає додаткову інформацію. |
| `-u` login | Відображає процеси користувача.  |

Деякі додаткові опції:

| Опція                 | Опис                                               |
| --------------------- | -------------------------------------------------- |
| `-g`                  | Відображає процеси в групі.                        |
| `-t tty`              | Відображає процеси, запущені з терміналу.          |
| `-p PID`              | Відображає інформацію про процес.                  |
| `-H`                  | Відображає інформацію у вигляді дерева.            |
| `-I`                  | Відображає додаткову інформацію.                   |
| `--sort COL`          | Сортує результат відповідно до стовпця.            |
| `--headers`           | Відображає заголовок на кожній сторінці терміналу. |
| `--format "%a %b %c"` | Налаштовує вихідний формат відображення.           |

Якщо параметр не вказано, команда `ps` відображає лише процеси, що виконуються з поточного терміналу.

Результат відображається в стовпцях:

```
# ps -ef
UID  PID PPID C STIME  TTY TIME      CMD
root 1   0    0 Jan01  ?   00:00/03  /sbin/init
```

| Колонка | Опис                                 |
| ------- | ------------------------------------ |
| `UID`   | Користувач-власник.                  |
| `PID`   | Ідентифікатор процесу.               |
| `PPID`  | Ідентифікатор батьківського процесу. |
| `C`     | Пріоритетність процесу.              |
| `STIME` | Дата і час виконання.                |
| `TTY`   | Термінал виконання.                  |
| `TIME`  | Тривалість обробки.                  |
| `CMD`   | Команда виконана.                    |

Поведінку елемента керування можна повністю налаштувати:

```
# ps -e --format "%P %p %c %n" --sort ppid --headers
 PPID   PID COMMAND          NI
    0     1 systemd           0
    0     2 kthreadd          0
    1   516 systemd-journal   0
    1   538 systemd-udevd     0
    1   598 lvmetad           0
    1   643 auditd           -4
    1   668 rtkit-daemon      1
    1   670 sssd              0
```

## Види процесів

Процес користувача:

* запускається з терміналу, пов’язаного з користувачем;
* отримує доступ до ресурсів через запити або демони.

Системний процес (_demon_):

* запускається системою;
* не пов’язаний з жодним терміналом і належить користувачеві системи (часто `root`);
* завантажується під час завантаження, знаходиться в пам'яті та очікує на виклик;
* зазвичай ідентифікується літерою `d`, пов’язаною з назвою процесу.

Тому системні процеси називаються демонами (_**D**isk **A**nd **E**xecution **MON**itor_).

## Дозволи та права

Під час виконання команди облікові дані користувача передаються створеному процесу.

За замовчуванням фактичні `UID` та `GID` (процесу) ідентичні **фактичному** ` UID` і `GID` (`UID` і `GID` користувача, який виконав команду).

Якщо для команди встановлено `SUID` (та/або `SGID`), фактичний `UID` (та/або `GID`) стає власником (та/або групою власників) команди, а не користувачем або групою користувачів, які видали команду. Тому ефективні та реальні **UID** **різняються**.

Щоразу, коли здійснюється доступ до файлу, система перевіряє права процесу відповідно до його ефективних ідентифікаторів.

## Управління процесами

Процес не може виконуватися безкінечно, оскільки це зашкодить іншим запущеним процесам і завадить багатозадачності.

Таким чином, загальний доступний час обробки ділиться на невеликі діапазони, і кожен процес (з пріоритетом) звертається до процесора в послідовний спосіб. Процес займе кілька станів протягом свого життя серед станів:

* готовий: очікується доступність процесу;
* у виконанні: отримує доступ до процесора;
* призупинено: очікування на введення/виведення (введення/виведення);
* зупинено: очікування сигналу від іншого процесу;
* зомбі: запит на знищення;
* мертвий: батьківський процес завершує дочірній процес

Послідовність наприкінці процесу така:

1. Закриття відкритих файлів;
2. Звільнення використаної пам'яті;
3. Надсилання сигналу батьківському та дочірньому процесам.

Коли батьківський процес помирає, його дочірні процеси вважаються сиротами. Потім вони приймаються процесом `init`, який їх знищує.

### Пріоритет процесу

Процесор працює в режимі розподілу часу, при цьому кожен процес займає певну кількість процесорного часу.

Процеси класифікуються за пріоритетом, значення якого змінюється від **-20** (найвищий пріоритет) до **+19** ( найнижчий пріоритет).

Пріоритет процесу за замовченням становить **0**.

### Режими роботи

Процеси можуть запускатися двома способами:

* **синхронний**: користувач втрачає доступ до оболонки під час виконання команди. Після завершення виконання процесу знову з’являється командний рядок.
* **асинхронний**: процес обробляється у фоновому режимі. Командний рядок негайно відображається знову.

Обмеження асинхронного режиму:

* команда або сценарій не повинні чекати введення з клавіатури;
* команда чи сценарій не повинні повертати жодного результату на екран;
* вихід із оболонки завершує процес.

## Елементи керування процесом

### Команда `kill`

Команда `kill` надсилає процесу сигнал зупинки.

```
kill [-signal] PID
```

Приклад:

```
$ kill -9 1664
```Перервати процес (<kbd>CTRL</kdb> + <kdb>D</kdb>)</td> </tr> 

<tr>
  <td>
    <code>15</code>
  </td>
  
  <td>
    <em x-id="4">SIGTERM</em>
  </td>
  
  <td>
    Чисте завершення процесу
  </td>
</tr>

<tr>
  <td>
    <code>18</code>
  </td>
  
  <td>
    <em x-id="4">SIGCONT</em>
  </td>
  
  <td>
    Відновлення процесу
  </td>
</tr>

<tr>
  <td>
    <code>19</code>
  </td>
  
  <td>
    <em x-id="4">SIGSTOP</em>
  </td>
  
  <td>
    Призупинення процесу
  </td>
</tr></tbody> </table> 

<p spaces-before="0">
  Сигнали є засобами зв'язку між процесами. Команда <code>kill</code> надсилає сигнал процесу.
</p>

<p spaces-before="0">
  !!! tip "Порада"
</p>

<pre><code>Повний список сигналів, які враховує команда kill, становиться доступним після введення команди:
</code></pre>

<pre><code>    $ man 7 signal
</code></pre>



<h3 spaces-before="0">
  Команда <code>nohup</code>
</h3>

<p spaces-before="0">
  <code>nohup</code> дозволяє запускати процес незалежно від підключення.
</p>

<pre><code>nohup command
</code></pre>

<p spaces-before="0">
  Приклад:
</p>

<pre><code>$ nohup myprogram.sh 0&lt;/dev/null &
</code></pre>

<p spaces-before="0">
  <code>nohup</code> ігнорує сигнал <code>SIGHUP</code>, який надсилається, коли користувач виходить із системи.
</p>

<p spaces-before="0">
  !!! Примітка
</p>

<pre><code>`nohup` обробляє стандартний вихід і помилку, але не стандартний вхід, отже, перенаправлення цього введення до `/dev/null`.
</code></pre>



<h3 spaces-before="0">
  [CTRL] + [Z]
</h3>

<p spaces-before="0">
  Якщо одночасно натиснути клавіші <kbd>CTRL</kbd> + <kbd>Z</kbd>, синхронний процес буде тимчасово призупинено. Доступ до підказки відновлюється після відображення номера щойно призупиненого процесу.
</p>



<h3 spaces-before="0">
  Інструкція <code>&</code>
</h3>

<p spaces-before="0">
  Інструкція <code>&</code> виконує команду асинхронно (тоді команда називається <em x-id="4">job</em>) і відображає кількість <em x-id="4 ">job</em>. Після цього доступ до підказки повертається.
</p>

<p spaces-before="0">
  Приклад:
</p>

<pre><code>$ time ls -lR / &gt; list.ls 2&gt; /dev/null &
[1] 15430
$
</code></pre>

<p spaces-before="0">
  Номер <em x-id="4">завдання</em> отримується під час обробки у фоновому режимі та відображається в квадратних дужках, а потім номер <code>PID</code>.
</p>



<h3 spaces-before="0">
  Команди <code>fg</code> і <code>bg</code>
</h3>

<p spaces-before="0">
  Команда <code>fg</code> виводить процес на передній план:
</p>

<pre><code>$ time ls -lR / &gt; list.ls 2&gt;/dev/null &
$ fg 1
time ls -lR / &gt; list.ls 2/dev/null
</code></pre>

<p spaces-before="0">
  тоді як команда <code>bg</code> поміщає його у фоновий режим:
</p>

<pre><code>[CTRL]+[Z]
^Z
[1]+ Stopped
$ bg 1
[1] 15430
$
</code></pre>

<p spaces-before="0">
  Незалежно від того, чи був він переведений у фоновий режим під час створення за допомогою аргументу <code>&</code> чи пізніше за допомогою клавіш <kbd>CTRL</kbd> +<kbd>Z</kbd>, процес можна повернути на передній план за допомогою команди <code>fg</code> і номера його завдання.
</p>



<h3 spaces-before="0">
  Команда <code>jobs</code>
</h3>

<p spaces-before="0">
  Команда <code>jobs</code> відображає список процесів, що виконуються у фоновому режимі, і вказує їхні номери завдань.
</p>

<p spaces-before="0">
  Приклад:
</p>

<pre><code>$ jobs
[1]- Running    sleep 1000
[2]+ Running    find / &gt; arbo.txt
</code></pre>

<p spaces-before="0">
  Стовпці представляють:
</p>

<ol start="1">
  <li>
    job номер;
  </li>
  
  <li>
    порядок виконання процесів
  </li>
</ol>

<ul>
  <li>
    a <code>+</code> : процес, вибраний за замовчуванням для команд <code>fg</code> і <code>bg</code>, коли не вказано номер завдання
  </li>
  <li>
    a <code>-</code> : цей процес є наступним процесом <code>+</code>
  </li>
</ul>

<ol start="3">
  <li>
    <em x-id="4">Запущено</em> (запущений процес) або <em x-id="4">Зупинено</em> (призупинений процес).  
  </li>
  
  <li>
    команда
  </li>
</ol>



<h3 spaces-before="0">
  Команди <code>nice</code> та <code>renice</code>
</h3>

<p spaces-before="0">
  Команда <code>nice</code> дозволяє виконати команду, вказавши її пріоритет.
</p>

<pre><code>nice priority command
</code></pre>

<p spaces-before="0">
  Приклад:
</p>

<pre><code>$ nice -n+15 find / -name "file"
</code></pre>

<p spaces-before="0">
  На відміну від <code>root</code>, звичайний користувач може лише зменшити пріоритет процесу. Приймаються лише значення від +0 до +19.
</p>

<p spaces-before="0">
  !!! tip "Порада"
</p>

<pre><code>Це останнє обмеження можна зняти для кожного користувача чи групи шляхом зміни файлу `/etc/security/limits.conf`.
</code></pre>

<p spaces-before="0">
  Команда <code>renice</code> дозволяє змінити пріоритет запущеного процесу.
</p>

<pre><code>renice priority [-g GID] [-p PID] [-u UID]
</code></pre>

<p spaces-before="0">
  Приклад:
</p>

<pre><code>$ renice +15 -p 1664
</code></pre>
<table spaces-before="0">
  <tr>
    <th>
      Опція
    </th>
    
    <th>
      Опис
    </th>
  </tr>
  
  <tr>
    <td>
      <code>-g</code>
    </td>
    
    <td>
      <code>GID</code> групи власників процесу.
    </td>
  </tr>
  
  <tr>
    <td>
      <code>-p</code>
    </td>
    
    <td>
      <code>PID</code> процесу.
    </td>
  </tr>
  
  <tr>
    <td>
      <code>-u</code>
    </td>
    
    <td>
      <code>UID</code> власника процесу.
    </td>
  </tr>
</table>

<p spaces-before="0">
  Команда <code>renice</code> діє на вже запущені процеси. Таким чином, можна змінити пріоритет окремого процесу, а також кількох процесів, що належать користувачеві чи групі.
</p>

<p spaces-before="0">
  !!! tip "Порада"
</p>

<pre><code>Команда `pidof` у поєднанні з командою `xargs` (див. курс Advanced Commands) дозволяє застосувати новий пріоритет в одній команді:
</code></pre>

<pre><code>    $ pidof sleep | xargs renice 20
</code></pre>



<h3 spaces-before="0">
  Команда <code>top</code>
</h3>

<p spaces-before="0">
  Команда <code>top</code> відображає процеси та споживання ними ресурсів.
</p>

<pre><code>$ top
PID  USER PR NI ... %CPU %MEM  TIME+    COMMAND
2514 root 20 0       15    5.5 0:01.14   top
</code></pre>

<table spaces-before="0">
  <tr>
    <th>
      Колонка
    </th>
    
    <th>
      Опис
    </th>
  </tr>
  
  <tr>
    <td>
      <code>PID</code>
    </td>
    
    <td>
      Ідентифікатор процесу.
    </td>
  </tr>
  
  <tr>
    <td>
      <code>USER</code>
    </td>
    
    <td>
      Користувач-власник.
    </td>
  </tr>
  
  <tr>
    <td>
      <code>PR</code>
    </td>
    
    <td>
      Пріоритет процесу.
    </td>
  </tr>
  
  <tr>
    <td>
      <code>NI</code>
    </td>
    
    <td>
      Значення пріоритету.
    </td>
  </tr>
  
  <tr>
    <td>
      <code>%CPU</code>
    </td>
    
    <td>
      Завантаження процесора.
    </td>
  </tr>
  
  <tr>
    <td>
      <code>%MEM</code>
    </td>
    
    <td>
      Навантаження на пам'ять.
    </td>
  </tr>
  
  <tr>
    <td>
      <code>TIME+</code>
    </td>
    
    <td>
      Час використання процесора.
    </td>
  </tr>
  
  <tr>
    <td>
      <code>COMMAND</code>
    </td>
    
    <td>
      Команда виконана.
    </td>
  </tr>
</table>

<p spaces-before="0">
  Команда <code>top</code> дозволяє керувати процесами в реальному часі та в інтерактивному режимі.
</p>



<h3 spaces-before="0">
  Команди <code>pgrep</code> і <code>pkill</code>
</h3>

<p spaces-before="0">
  Команда <code>pgrep</code> шукає назву процесу в запущених процесах і відображає <em x-id="4">PID</em>, що відповідає критеріям вибору, у стандартному виводі.
</p>

<p spaces-before="0">
  Команда <code>pkill</code> надішле вказаний сигнал (за умовчанням <em x-id="4">SIGTERM</em>) до кожного процесу.
</p>

<pre><code>pgrep process
pkill [-signal] process
</code></pre>

<p spaces-before="0">
  Приклади:
</p>

<ul>
  <li>
    Отримати номер процесу з <code>sshd</code>:
  </li>
</ul>

<pre><code>$ pgrep -u root sshd
</code></pre>

<ul>
  <li>
    Закрити всі процеси <code>tomcat</code>:
  </li>
</ul>

<pre><code>$ pkill tomcat
</code></pre>
