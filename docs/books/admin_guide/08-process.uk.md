---
title: Менеджер процесів
---

# Менеджер процесів

У цьому розділі ви дізнаєтесь як працювати з процесами.

****

**Цілі**: у цьому розділі майбутні адміністратори Linux дізнаються, як:

:heavy_check_mark: Розпізнати `PID` і `PPID` процесу;   
:heavy_check_mark: Переглянути та шукати процеси;   
:heavy_check_mark: Керувати процесами.

:checkered_flag: **процес**, **linux**

**Знання**: :star: :star:   
**Складність**: :star:

**Час читання**: 20 хвилин

****

## Загальні положення

Операційна система складається з процесів. Ці процеси виконуються в певному порядку і пов’язані один з одним. Існує дві категорії процесів: зосереджені на середовищі користувача та зосереджені на апаратному середовищі.

Коли програма виконується, система створить процес, помістивши дані програми та код у пам’ять і створивши **стек часу виконання**. Таким чином, процес є екземпляром програми з асоційованим середовищем процесора (порядковий лічильник, регістри тощо) і середовищем пам’яті.

Кожен процес має:

* a _PID_: _**P**rocess **ID**entifier_, унікальний ідентифікатор процесу;
* a _PPID_: _**P**arent **P**process **ID**entifier_, унікальний ідентифікатор батьківського процесу.

Завдяки послідовним відгалуженням процес `init` є батьком усіх процесів.

* Процес завжди створюється батьківським процесом;
* Батьківський процес може мати кілька дочірніх процесів.

Між процесами існує зв’язок «батьківський/дочірній». Дочірній процес є результатом того, що батьківський процес викликає примітив _fork()_ і дублює свій власний код для створення дочірнього. _PID_ дочірнього процесу повертається до батьківського процесу, щоб він міг з ним спілкуватися. Кожен дочірній елемент має ідентифікатор свого батька, _PPID_.

Номер _PID_ представляє процес під час виконання. Після завершення процесу номер знову доступний для іншого процесу. Виконання тієї самої команди кілька разів створюватиме різні _PID_ щоразу.<!-- TODO !\[Parent/child relationship between processes\](images/FON-050-001.png) -->!!! Важливо

    Процеси не слід плутати з _потоками_. Кожен процес має власний контекст пам’яті (ресурси та адресний простір), тоді як _потоки_ того самого процесу спільно використовують той самий контекст.

## Перегляд процесів

Команда `ps` відображає стан запущених процесів.
```
ps [-e] [-f] [-u login]
```

Приклад:
```
# ps -fu root
```

| Опція      | Опис                             |
| ---------- | -------------------------------- |
| `-e`       | Відображає всі процеси.          |
| `-f`       | Відображає додаткову інформацію. |
| `-u` login | Відображає процеси користувача.  |

Деякі додаткові опції:

| Опція                 | Опис                                               |
| --------------------- | -------------------------------------------------- |
| `-g`                  | Відображає процеси в групі.                        |
| `-t tty`              | Відображає процеси, запущені з терміналу.          |
| `-p PID`              | Відображає інформацію про процес.                  |
| `-H`                  | Відображає інформацію у вигляді дерева.            |
| `-I`                  | Відображає додаткову інформацію.                   |
| `--sort COL`          | Сортує результат відповідно до стовпця.            |
| `--headers`           | Відображає заголовок на кожній сторінці терміналу. |
| `--format "%a %b %c"` | Налаштовує вихідний формат відображення.           |

Якщо параметр не вказано, команда `ps` відображає лише процеси, що виконуються з поточного терміналу.

Результат відображається в стовпцях:

```
# ps -ef
UID  PID PPID C STIME  TTY TIME      CMD
root 1   0    0 Jan01  ?   00:00/03  /sbin/init
```

| Колонка | Опис                                 |
| ------- | ------------------------------------ |
| `UID`   | Користувач-власник.                  |
| `PID`   | Ідентифікатор процесу.               |
| `PPID`  | Ідентифікатор батьківського процесу. |
| `C`     | Пріоритетність процесу.              |
| `STIME` | Дата і час виконання.                |
| `TTY`   | Термінал виконання.                  |
| `TIME`  | Тривалість обробки.                  |
| `CMD`   | Команда виконана.                    |

Поведінку елемента керування можна повністю налаштувати:

```
# ps -e --format "%P %p %c %n" --sort ppid --headers
 PPID   PID COMMAND          NI
    0     1 systemd           0
    0     2 kthreadd          0
    1   516 systemd-journal   0
    1   538 systemd-udevd     0
    1   598 lvmetad           0
    1   643 auditd           -4
    1   668 rtkit-daemon      1
    1   670 sssd              0
```

## Види процесів

Процес користувача:

* запускається з терміналу, пов’язаного з користувачем;
* отримує доступ до ресурсів через запити або демони.

Системний процес (_demon_):

* запускається системою;
* не пов’язаний з жодним терміналом і належить користувачеві системи (часто `root`);
* завантажується під час завантаження, знаходиться в пам'яті та очікує на виклик;
* зазвичай ідентифікується літерою `d`, пов’язаною з назвою процесу.

Тому системні процеси називаються демонами (_**D**isk **A**nd **E**xecution **MON**itor_).

## Дозволи та права

Під час виконання команди облікові дані користувача передаються створеному процесу.

За замовчуванням фактичні `UID` та `GID` (процесу) ідентичні **фактичному** ` UID` і `GID` (`UID` і `GID` користувача, який виконав команду).

Якщо для команди встановлено `SUID` (та/або `SGID`), фактичний `UID` (та/або `GID`) стає власником (та/або групою власників) команди, а не користувачем або групою користувачів, які видали команду. Тому ефективні та реальні **UID** **різняються**.

Щоразу, коли здійснюється доступ до файлу, система перевіряє права процесу відповідно до його ефективних ідентифікаторів.

## Управління процесами

Процес не може виконуватися безкінечно, оскільки це зашкодить іншим запущеним процесам і завадить багатозадачності.

Таким чином, загальний доступний час обробки ділиться на невеликі діапазони, і кожен процес (з пріоритетом) звертається до процесора в послідовний спосіб. Процес займе кілька станів протягом свого життя серед станів:

* готовий: очікується доступність процесу;
* у виконанні: отримує доступ до процесора;
* призупинено: очікування на введення/виведення (введення/виведення);
* зупинено: очікування сигналу від іншого процесу;
* зомбі: запит на знищення;
* мертвий: батьківський процес завершує дочірній процес

Послідовність наприкінці процесу така:

1. Закриття відкритих файлів;
2. Звільнення використаної пам'яті;
3. Надсилання сигналу батьківському та дочірньому процесам.

Коли батьківський процес помирає, його дочірні процеси вважаються сиротами. Потім вони приймаються процесом `init`, який їх знищує.

### Пріоритет процесу

GNU/Linux належить до сімейства операційних систем із розподілом часу. Процесори працюють за принципом розподілу часу, і кожен процес займає певний час процесора. Процеси класифікуються за пріоритетністю:

* Процес у реальному часі: Алгоритм планування в реальному часі планує процес із пріоритетом **0-99**.
* Звичайні процеси: процеси з динамічними пріоритетами **100-139** плануються за допомогою абсолютно справедливого алгоритму планування.
* Відмінне значення: параметр, який використовується для налаштування пріоритету звичайного процесу. Діапазон **-20-19**.

Пріоритет процесу за замовченням становить **0**.

### Режими роботи

Процеси можуть запускатися двома способами:

* **синхронний**: користувач втрачає доступ до оболонки під час виконання команди. Після завершення виконання процесу знову з’являється командний рядок.
* **асинхронний**: процес обробляється у фоновому режимі. Командний рядок негайно відображається знову.

Обмеження асинхронного режиму:

* команда або сценарій не повинні чекати введення з клавіатури;
* команда чи сценарій не повинні повертати жодного результату на екран;
* вихід із оболонки завершує процес.

## Елементи керування процесом

### Команда `kill`

Команда `kill` надсилає процесу сигнал зупинки.

```
kill [-signal] PID
```

Приклад:

```
$ kill -9 1664
```

| Код  | Сигнал    | Опис                                              |
| ---- | --------- | ------------------------------------------------- |
| `2`  | _SIGINT_  | Негайне припинення процесу                        |
| `9`  | _SIGKILL_ | Перервати процес (<kbd>CTRL</kbd> + <kbd>D</kbd>) |
| `15` | _SIGTERM_ | Чисте завершення процесу                          |
| `18` | _SIGCONT_ | Відновлення процесу                               |
| `19` | _SIGSTOP_ | Призупинення процесу                              |

Сигнали є засобами зв'язку між процесами. Команда `kill` надсилає сигнал процесу.

!!! tip "Порада"

    Повний список сигналів, які враховує команда kill, становиться доступним після введення команди:

    ```
    $ man 7 signal
    ```

### Команда `nohup`

`nohup` дозволяє запускати процес незалежно від підключення.

```
nohup command
```

Приклад:

```
$ nohup myprogram.sh 0</dev/null &
```

`nohup` ігнорує сигнал `SIGHUP`, який надсилається, коли користувач виходить із системи.

!!! note "Примітка"

    `nohup` обробляє стандартний вихід і помилку, але не стандартний вхід, отже, перенаправлення цього введення до `/dev/null`.

### [CTRL] + [Z]

Якщо одночасно натиснути клавіші <kbd>CTRL</kbd> + <kbd>Z</kbd>, синхронний процес буде тимчасово призупинено. Доступ до підказки відновлюється після відображення номера щойно призупиненого процесу.

### Інструкція `&`

Інструкція `&` виконує команду асинхронно (тоді команда називається _job_) і відображає кількість *job*. Після цього доступ до підказки повертається.

Приклад:

```
$ time ls -lR / > list.ls 2> /dev/null &
[1] 15430
$
```

Номер _завдання_ отримується під час обробки у фоновому режимі та відображається в квадратних дужках, а потім номер `PID`.

### Команди `fg` і `bg`

Команда `fg` виводить процес на передній план:

```
$ time ls -lR / > list.ls 2>/dev/null &
$ fg 1
time ls -lR / > list.ls 2/dev/null
```

тоді як команда `bg` поміщає його у фоновий режим:

```
[CTRL]+[Z]
^Z
[1]+ Stopped
$ bg 1
[1] 15430
$
```

Незалежно від того, чи був він переведений у фоновий режим під час створення за допомогою аргументу `&` чи пізніше за допомогою клавіш <kbd>CTRL</kbd> +<kbd>Z</kbd>, процес можна повернути на передній план за допомогою команди `fg` і номера його завдання.

### Команда `jobs`

Команда `jobs` відображає список процесів, що виконуються у фоновому режимі, і вказує їхні номери завдань.

Приклад:

```
$ jobs
[1]- Running    sleep 1000
[2]+ Running    find / > arbo.txt
```

Стовпці представляють:

1. job номер;
2. порядок виконання процесів
- a `+` : процес, вибраний за замовчуванням для команд `fg` і `bg`, коли не вказано номер завдання
- a `-` : цей процес є наступним процесом `+`
3.  _Запущено_ (запущений процес) або _Зупинено_ (призупинений процес).
4. команда

### Команди `nice` та `renice`

Команда `nice` дозволяє виконати команду, вказавши її пріоритет.

```
nice priority command
```

Приклад:

```
$ nice -n+15 find / -name "file"
```

На відміну від `root`, звичайний користувач може лише зменшити пріоритет процесу. Приймаються лише значення від +0 до +19.

!!! tip "Порада"

    Це останнє обмеження можна зняти для кожного користувача чи групи шляхом зміни файлу `/etc/security/limits.conf`.

Команда `renice` дозволяє змінити пріоритет запущеного процесу.

```
renice priority [-g GID] [-p PID] [-u UID]
```

Приклад:

```
$ renice +15 -p 1664
```
| Опція | Опис                           |
| ----- | ------------------------------ |
| `-g`  | `GID` групи власників процесу. |
| `-p`  | `PID` процесу.                 |
| `-u`  | `UID` власника процесу.        |

Команда `renice` діє на вже запущені процеси. Таким чином, можна змінити пріоритет окремого процесу, а також кількох процесів, що належать користувачеві чи групі.

!!! tip "Порада"

    Команда `pidof` у поєднанні з командою `xargs` (див. курс Advanced Commands) дозволяє застосувати новий пріоритет в одній команді:

    ```
    $ pidof sleep | xargs renice 20
    ```

### Команда `top`

Команда `top` відображає процеси та споживання ними ресурсів.

```
$ top
PID  USER PR NI ... %CPU %MEM  TIME+    COMMAND
2514 root 20 0       15    5.5 0:01.14   top
```

| Колонка   | Опис                        |
| --------- | --------------------------- |
| `PID`     | Ідентифікатор процесу.      |
| `USER`    | Користувач-власник.         |
| `PR`      | Пріоритет процесу.          |
| `NI`      | Значення пріоритету.        |
| `%CPU`    | Завантаження процесора.     |
| `%MEM`    | Навантаження на пам'ять.    |
| `TIME+`   | Час використання процесора. |
| `COMMAND` | Команда виконана.           |

Команда `top` дозволяє керувати процесами в реальному часі та в інтерактивному режимі.

### Команди `pgrep` і `pkill`

Команда `pgrep` шукає назву процесу в запущених процесах і відображає _PID_, що відповідає критеріям вибору, у стандартному виводі.

Команда `pkill` надішле вказаний сигнал (за умовчанням _SIGTERM_) до кожного процесу.

```
pgrep process
pkill [option] [-signal] process
```

Приклади:

* Отримайте номер процесу з `sshd`:

  ```
  $ pgrep -u root sshd
  ```

* Закрийте всі процеси `tomcat`:

  ```
  $ pkill tomcat
  ```

!!! note "Примітка"

    Перш ніж вбивати процес, найкраще точно знати, для чого він призначений. Інакше це може призвести до системних збоїв або інших непередбачуваних проблем.

Окрім надсилання сигналів до відповідних процесів, команда `pkill` також може завершити сеанс підключення користувача відповідно до номера терміналу, наприклад:

```
$ pkill -t pts/1
```

### Команда `killall`

Функції цієї команди приблизно такі ж, як і команди `pkill`. Використовується як - `killall [option] [ -s SIGNAL | -SIGNAL ] NAME`. Стандартним сигналом є _SIGTERM_.

| Опції | Опис                                       |
|:----- |:------------------------------------------ |
| `-l`  | містить список усіх відомих назв сигналів  |
| `-i`  | просить підтвердження перед закінченням    |
| `-I`  | збіг імені процесу без урахування регістру |

Приклад:

```
$ killall tomcat
```

### Команда `pstree`

Ця команда відображає прогрес у стилі дерева, і її використання - `pstree [option]`.

| Опція | Опис                                     |
|:----- |:---------------------------------------- |
| `-p`  | Відображає PID процесу                   |
| `-n`  | сортує вихідні дані за PID               |
| `-h`  | висвітлює поточний процес і його предків |
| `-u`  | показує переходи uid                     |

```bash
$ pstree -pnhu
systemd(1)─┬─systemd-journal(595)
           ├─systemd-udevd(625)
           ├─auditd(671)───{auditd}(672)
           ├─dbus-daemon(714,dbus)
           ├─NetworkManager(715)─┬─{NetworkManager}(756)
           │                     └─{NetworkManager}(757)
           ├─systemd-logind(721)
           ├─chronyd(737,chrony)
           ├─sshd(758)───sshd(1398)───sshd(1410)───bash(1411)───pstree(1500)
           ├─tuned(759)─┬─{tuned}(1376)
           │            ├─{tuned}(1381)
           │            ├─{tuned}(1382)
           │            └─{tuned}(1384)
           ├─agetty(763)
           ├─crond(768)
           ├─polkitd(1375,polkitd)─┬─{polkitd}(1387)
           │                       ├─{polkitd}(1388)
           │                       ├─{polkitd}(1389)
           │                       ├─{polkitd}(1390)
           │                       └─{polkitd}(1392)
           └─systemd(1401)───(sd-pam)(1404)
```

### Сирітський процес і процес зомбі

**Процес-сирота**: коли батьківський процес помирає, їхні нащадки вважаються сиротами. Процес ініціалізації приймає ці унікальні процеси стану, і збір стану завершується, доки вони не будуть знищені. Концептуально процес сиротинства не несе жодної шкоди.

**зомбі-процес**: після того, як дочірній процес завершує свою роботу, його батьківський процес повинен викликати функцію обробки сигналу wait() або waitpid(), щоб отримати статус завершення дочірнього процесу. Якщо батьківський процес цього не робить, хоча дочірній процес уже завершив роботу, він усе ще зберігає деяку інформацію про статус виходу в системній таблиці процесів. Оскільки батьківський процес не може отримати інформацію про стан дочірнього процесу, ці процеси продовжуватимуть займати ресурси в таблиці процесів. Ми називаємо процеси в цьому стані зомбі.

Небезпека:

* Вони займають системні ресурси та спричиняють зниження продуктивності машини.
* Не вдалося створити нові дочірні процеси.

Як ми можемо перевірити наявність зомбі-процесів у поточній системі?

```
$ ps -lef | awk '{print $2}' | grep Z
```

Ці символи можуть з’являтися в цьому стовпці:

* **D** - безперервний сон (зазвичай IO)
* **I** - Неактивний потік ядра
* **R** - запущений або у черзі виконання
* **S** - переривчастий сон (очікування завершення події)
* **T** - зупинено сигналом керування
* **t** - зупинено налагоджувачем під час трасування
* **W** - сторінковий (недійсний з ядра 2.6.xx)
* **X** - мертвий (ніколи його не можна побачити)
* **Z** - неіснуючий ("зомбі") процес, припинений, але не пожнутий своїм батьком
