---
title: Менеджер процесів
---

# Менеджер процесів

У цьому розділі ви дізнаєтесь як працювати з процесами.

****

**Цілі**: у цьому розділі майбутні адміністратори Linux дізнаються, як:

:heavy_check_mark: Розпізнавати `PID` і `PPID` процесу;  
:heavy_check_mark: Перегляд і пошук процесів;  
:heavy_check_mark: Керування процесами.

:checkered_flag: **процес**, **linux**

**Знання**: :star: :star:  
**Складність**: :star:

**Час читання**: 20 хвилин

****

## Загальні положення

Операційна система складається з процесів. Ці процеси виконуються в певному порядку і пов’язані один з одним. Існує дві категорії процесів: зосереджені на середовищі користувача та зосереджені на апаратному середовищі.

Під час виконання програми система створює процес, розміщуючи дані та код програми в пам'яті та створюючи **стек виконання**. Процес — це екземпляр програми з пов'язаним процесорним середовищем (порядковий лічильник, регістри тощо) та середовище пам'яті.

Кожен процес має:

- _PID_: _**P**rocess **ID**entifier_, унікальний ідентифікатор процесу
- _PPID_: _**P**arent **P**rocess **ID**entifier_, унікальний ідентифікатор батьківського процесу

Завдяки послідовним відгалуженням процес `init` є батьком усіх процесів.

- Процес завжди створюється батьківським процесом;
- Батьківський процес може мати кілька дочірніх процесів.

Між процесами існує зв’язок «батьківський/дочірній». Дочірній процес виникає в результаті виклику батьківським процесом примітиву _fork()_ та дублювання його коду для створення дочірнього процесу. _PID_ дочірнього процесу повертається батьківському процесу, щоб той міг з ним взаємодіяти. Кожна дитина має ідентифікатор свого батька, _PPID_.

Номер _PID_ представляє процес на момент виконання. Після завершення процесу номер знову доступний для іншого процесу. Якщо виконати ту саму команду кілька разів, щоразу буде генеруватися різний _PID_.

<!-- TODO ![Parent/child relationship between processes](images/FON-050-001.png) -->

!!! Note "Примітка"

    ```
    Процеси не слід плутати з _потоками_. Кожен процес має свій контекст пам'яті (ресурси та адресний простір), тоді як _потоки_ з одного процесу використовують цей контекст.
    ```

## Перегляд процесів

Приклад:

```bash
ps [-e] [-f] [-u login]
```

Приклад:

```bash
# ps -fu root
```

| Опція      | Опис                                               |
| ---------- | -------------------------------------------------- |
| `-e`       | Відображає всі процеси.            |
| `-f`       | Відображає повний список форматів. |
| `-u` login | Відображає процеси користувача.    |

Деякі додаткові опції:

| Опція                 | Опис                                                               |
| --------------------- | ------------------------------------------------------------------ |
| `-g`                  | Відображає процеси в групі.                        |
| `-t tty`              | Відображає процеси, запущені з терміналу.          |
| `-p PID`              | Відображає інформацію про процес.                  |
| `-H`                  | Відображає інформацію у вигляді дерева.            |
| `-l`                  | Відображення в довгому форматі.                    |
| `--sort COL`          | Сортує результат відповідно до стовпця.            |
| `--headers`           | Відображає заголовок на кожній сторінці терміналу. |
| `--format "%a %b %c"` | Налаштовує вихідний формат відображення.           |

Якщо не вказано опцію, команда `ps` відображає лише процеси, що працюють з поточного терміналу.

Результат відображається в стовпцях:

```bash
# ps -ef
UID  PID PPID C STIME  TTY TIME      CMD
root 1   0    0 Jan01  ?   00:00/03  /sbin/init
```

| Колонка | Опис                                                 |
| ------- | ---------------------------------------------------- |
| `UID`   | Користувач-власник.                  |
| `PID`   | Ідентифікатор процесу.               |
| `PPID`  | Ідентифікатор батьківського процесу. |
| `C`     | Пріоритетність процесу.              |
| `STIME` | Дата і час виконання.                |
| `TTY`   | Термінал виконання.                  |
| `TIME`  | Тривалість обробки.                  |
| `CMD`   | Команда виконана.                    |

Поведінку елемента керування можна повністю налаштувати:

```bash
# ps -e --format "%P %p %c %n" --sort ppid --headers
 PPID   PID COMMAND          NI
    0     1 systemd           0
    0     2 kthreadd          0
    1   516 systemd-journal   0
    1   538 systemd-udevd     0
    1   598 lvmetad           0
    1   643 auditd           -4
    1   668 rtkit-daemon      1
    1   670 sssd              0
```

## Види процесів

Процес користувача:

- запускається з терміналу, пов’язаного з користувачем;
- отримує доступ до ресурсів через запити або демони.

Системний процес (_демон_):

- запускається системою;
- не пов'язаний з жодним терміналом і належить системному користувачеві (часто `root`)
- завантажується під час завантаження, знаходиться в пам'яті та очікує на виклик;
- зазвичай позначається літерою `d`, пов'язаною з назвою процесу

Тому системні процеси називаються демонами (\*\*\*Диск \*\*та \*_Монітор виконання_).

## Дозволи та права

Під час виконання команди облікові дані користувача передаються створеному процесу.

За замовчуванням фактичні `UID` та `GID` процесу (самого процесу) ідентичні **фактичним** `UID` та `GID` (`UID` та `GID` користувача, який виконав команду).

Коли для команди встановлено `SUID` (та/або `SGID`), фактичний `UID` (та/або `GID`) стає ідентифікатором власника (та/або групи власників) команди, а не користувача або групи користувачів, які видали команду. Таким чином, ефективні та реальні **UID** **різні**.

Щоразу, коли здійснюється доступ до файлу, система перевіряє права процесу відповідно до його ефективних ідентифікаторів.

## Управління процесами

Процес не може виконуватися безкінечно, оскільки це зашкодить іншим запущеним процесам і завадить багатозадачності.

Таким чином, загальний доступний час обробки ділиться на невеликі діапазони, і кожен процес (з пріоритетом) звертається до процесора в послідовний спосіб. Процес займе кілька станів протягом свого життя серед станів:

- готовий: очікується доступність процесу;
- у виконанні: отримує доступ до процесора;
- призупинено: очікування на введення/виведення (введення/виведення);
- зупинено: очікування сигналу від іншого процесу;
- зомбі: запит на знищення;
- мертвий: батьківський процес завершує дочірній процес

Послідовність наприкінці процесу така:

1. Закриття відкритих файлів;
2. Звільнення використаної пам'яті;
3. Надсилання сигналу батьківському та дочірньому процесам.

Коли батьківський процес помирає, його дочірні процеси вважаються сиротами. Потім вони приймаються процесом `init`, який знищує їх.

### Пріоритет процесу

GNU/Linux належить до сімейства операційних систем із розподілом часу. Процесори працюють за принципом розподілу часу, і кожен процес займає певний час процесора. Процеси класифікуються за пріоритетністю:

- Процес реального часу: процес з пріоритетом **0-99** планується алгоритмом планування реального часу.
- Звичайні процеси: процеси з динамічними пріоритетами **100-139** плануються за допомогою повністю справедливого алгоритму планування.
- Відмінне значення: параметр, який використовується для налаштування пріоритету звичайного процесу. Діапазон **-20-19**.

Пріоритет процесу за замовчуванням — **0**.

### Режими роботи

Процеси можуть запускатися двома способами:

- **синхронний**: користувач втрачає доступ до оболонки під час виконання команди. Після завершення виконання процесу знову з’являється командний рядок.
- **асинхронний**: процес обробляється у фоновому режимі. Командний рядок негайно відображається знову.

Обмеження асинхронного режиму:

- команда або сценарій не повинні чекати введення з клавіатури;
- команда чи сценарій не повинні повертати жодного результату на екран;
- вихід із оболонки завершує процес.

## Елементи керування процесом

### Команда `kill`

Приклад:

```bash
kill [-signal] PID
```

Приклад:

```bash
kill -9 1664
```

| Код  | Сигнал    | Опис                                                                                                                             |
| ---- | --------- | -------------------------------------------------------------------------------------------------------------------------------- |
| `2`  | _SIGINT_  | Негайне припинення процесу                                                                                                       |
| `9`  | _SIGKILL_ | Перериває процес (++control+"d"++)                                                                            |
| `15` | _SIGTERM_ | Чисте завершення процесу                                                                                                         |
| `18` | _SIGCONT_ | Відновлює процес. Процеси, які використовують сигнал SIGSTOP, можуть використовувати його для продовження роботи |
| `19` | _SIGSTOP_ | Призупиняє процес (Зупиняє процес). Ефект цього сигналу еквівалентний ++ctrl+"z"++            |

Сигнали є засобами зв'язку між процесами. Команда `kill` надсилає сигнал процесу.

!!! Tip "Порада"

    ````
    Повний список сигналів, що враховуються командою `kill`, можна отримати, ввівши команду:
    
    ```
    $ man 7 signal
    ```
    ````

### Команда `nohup`

`nohup` дозволяє запускати процес незалежно від з'єднання.

```bash
nohup command
```

Приклад:

```bash
nohup myprogram.sh 0</dev/null &
```

`nohup` ігнорує сигнал `SIGHUP`, що надсилається під час виходу користувача з системи.

!!! Note "Примітка"

    ```
    `nohup` обробляє стандартний вихід і помилку, але не стандартний вхід, отже, перенаправлення цього введення до `/dev/null`.
    ```

### [Ctrl] + [z]

Синхронний процес тимчасово призупиняється одночасним натисканням клавіш ++control+"z"++. Доступ до підказки відновлюється після відображення номера щойно призупиненого процесу.

### Інструкція `&`

Оператор `&` виконує команду асинхронно (команда тоді називається _job_) та відображає кількість _job_. Після цього доступ до підказки повертається.

Приклад:

```bash
$ time ls -lR / > list.ls 2> /dev/null &
[1] 15430
$
```

Номер _завдання_ отримується під час фонової обробки та відображається у квадратних дужках, а потім номер `PID`.

### Команди `fg` та `bg`

Команда `fg` переводить процес на передній план:

```bash
$ time ls -lR / > list.ls 2>/dev/null &
$ fg 1
time ls -lR / > list.ls 2/dev/null
```

тоді як команда `bg` розміщує його у фоновому режимі:

```bash
[CTRL]+[Z]
^Z
[1]+ Stopped
$ bg 1
[1] 15430
$
```

Незалежно від того, чи був процес переведений у фоновий режим під час створення за допомогою аргументу `&`, чи пізніше за допомогою клавіш ++control+"z"++, його можна повернути на передній план за допомогою команди `fg` та його номера завдання.

### Команда `jobs`

Команда `jobs` відображає список процесів, що працюють у фоновому режимі, та вказує номер їхнього завдання.

Приклад:

```bash
$ jobs
[1]- Running    sleep 1000
[2]+ Running    find / > arbo.txt
```

Стовпці представляють:

1. job номер;
2. порядок виконання процесів

   - a `+`: Процес, вибраний за замовчуванням для команд `fg` та `bg`, коли не вказано номер завдання
   - a `-`: Цей процес є наступним процесом, який приймає `+`
3. _Запущено_ (процес, що виконується) або _Зупинено_ (процес, що призупинено)
4. команда

### Команди `nice` та `renice`

Команда `nice` дозволяє виконання команди, вказуючи її пріоритет.

```bash
nice priority command
```

Приклад використання:

```bash
nice --adjustment=-5 find / -name "file"

nice -n -5 find / -name "file"

nice --5 find / -name "file"

nice -n 5 find / -name "file"

nice find / -name "file"
```

На відміну від користувача `root`, звичайний користувач може лише знизити пріоритет процесу, і прийматимуться лише значення від 0 до 19.

Як показано у прикладі вище, перші три команди вказують на встановлення значення Nice на "-5", тоді як друга команда є нашим рекомендованим використанням. Четверта команда вказує на встановлення значення Nice на «5». Для п’ятої команди відсутність параметрів означає, що значення Nice встановлено на «10».

!!! Tip "Порада"

    ```
    "Nice" – це абревіатура від "niceness". 
    
    Безпосереднє введення команди `nice` поверне значення Nice поточної оболонки. 
    
    Ви можете зняти обмеження значень Nice для кожного користувача або групи, змінивши файл `/etc/security/limits.conf`.
    ```

Команда `renice` дозволяє змінити пріоритет запущеного процесу.

```bash
renice priority [-g GID] [-p PID] [-u UID]
```

Приклад:

```bash
renice -n 15 -p 1664
```

| Опція | Опис                                           |
| ----- | ---------------------------------------------- |
| `-g`  | `GID` групи власників процесу. |
| `-p`  | `PID` процесу.                 |
| `-u`  | `UID` власника процесу.        |

Команда `renice` діє на існуючі процеси. Таким чином, можна змінити пріоритет певного процесу та кількох процесів, що належать користувачеві чи групі.

!!! Tip "Порада"

    ````
    Команда `pidof` разом з командою `xargs` (див. курс «Додаткові команди») дозволяє застосувати новий пріоритет за допомогою однієї команди:
    
    ```
    $ pidof sleep | xargs renice -n 20
    ```
    ````

Щоб адаптуватися до різних дистрибутивів, слід намагатися якомога частіше використовувати такі форми команд, як `nice -n 5` або `renice -n 6`.

### Команда `top`

Команда `top` відображає процеси та споживання ними ресурсів.

```bash
$ top
PID  USER PR NI ... %CPU %MEM  TIME+    COMMAND
2514 root 20 0       15    5.5 0:01.14   top
```

| Колонка   | Опис                                        |
| --------- | ------------------------------------------- |
| `PID`     | Ідентифікатор процесу.      |
| `USER`    | Користувач-власник.         |
| `PR`      | Пріоритет процесу.          |
| `NI`      | Значення пріоритету.        |
| `%CPU`    | Завантаження процесора.     |
| `%MEM`    | Навантаження на пам'ять.    |
| `TIME+`   | Час використання процесора. |
| `COMMAND` | Команда виконана.           |

Команда `top` дозволяє керувати процесами в режимі реального часу та в інтерактивному режимі.

### Команди `pgrep` та `pkill`

Команда `pgrep` шукає ім'я процесу серед запущених процесів та відображає _PID_, що відповідає критеріям вибору, на стандартному виводі.

Команда `pkill` надсилатиме кожному процесу вказаний сигнал (за замовчуванням _SIGTERM_).

```bash
pgrep process
pkill [option] [-signal] process
```

Приклади:

- Отримати номер процесу з `sshd`:

  ```bash
  pgrep -u root sshd
  ```

- Завершіть усі процеси `tomcat`:

  ```bash
  pkill tomcat
  ```

!!! note

    Перш ніж вбивати процес, найкраще точно знати, для чого він призначений. Інакше це може призвести до системних збоїв або інших непередбачуваних проблем.

Окрім надсилання сигналів відповідним процесам, команда `pkill` також може завершити сеанс підключення користувача відповідно до номера терміналу, наприклад:

```bash
pkill -t pts/1
```

### Команда `killall`

Функція цієї команди приблизно така ж, як і у команди `pkill`. Використання таке —`killall [option] [ -s SIGNAL | -SIGNAL ] NAME`. Сигналом за замовчуванням є _SIGTERM_.

| Опції | Опис                                       |
| :---- | :----------------------------------------- |
| `-l`  | містить список усіх відомих назв сигналів  |
| `-i`  | просить підтвердження перед закінченням    |
| `-I`  | збіг імені процесу без урахування регістру |

Приклад:

```bash
killall tomcat
```

### Команда `pstree`

Ця команда відображає прогрес у вигляді дерева, а її використання — `pstree [option]`.

| Опція | Опис                                     |
| :---- | :--------------------------------------- |
| `-p`  | Відображає PID процесу                   |
| `-n`  | сортує вихідні дані за PID               |
| `-h`  | висвітлює поточний процес і його предків |
| `-u`  | показує переходи uid                     |

```bash
$ pstree -pnhu
systemd(1)─┬─systemd-journal(595)
           ├─systemd-udevd(625)
           ├─auditd(671)───{auditd}(672)
           ├─dbus-daemon(714,dbus)
           ├─NetworkManager(715)─┬─{NetworkManager}(756)
           │                     └─{NetworkManager}(757)
           ├─systemd-logind(721)
           ├─chronyd(737,chrony)
           ├─sshd(758)───sshd(1398)───sshd(1410)───bash(1411)───pstree(1500)
           ├─tuned(759)─┬─{tuned}(1376)
           │            ├─{tuned}(1381)
           │            ├─{tuned}(1382)
           │            └─{tuned}(1384)
           ├─agetty(763)
           ├─crond(768)
           ├─polkitd(1375,polkitd)─┬─{polkitd}(1387)
           │                       ├─{polkitd}(1388)
           │                       ├─{polkitd}(1389)
           │                       ├─{polkitd}(1390)
           │                       └─{polkitd}(1392)
           └─systemd(1401)───(sd-pam)(1404)
```

### Сирітський процес і процес зомбі

**процес-сирота**: Коли батьківський процес завершує свою роботу, його дочірні процеси вважаються сиротами. Процес ініціалізації приймає ці унікальні процеси стану, і збір стану завершується, доки вони не будуть знищені. Концептуально процес сиротинства не несе жодної шкоди.

**зомбі-процес**: Після того, як дочірній процес завершує свою роботу та завершується, його батьківський процес повинен викликати функцію обробки сигналів wait() або waitpid(), щоб отримати статус завершення дочірнього процесу. Якщо батьківський процес цього не робить, хоча дочірній процес уже завершив роботу, він усе ще зберігає деяку інформацію про статус виходу в системній таблиці процесів. Оскільки батьківський процес не може отримати інформацію про стан дочірнього процесу, ці процеси продовжуватимуть займати ресурси в таблиці процесів. Ми називаємо процеси в цьому стані зомбі.

Небезпека:

- Вони займають системні ресурси та спричиняють зниження продуктивності машини.
- Не вдалося створити нові дочірні процеси.

Як ми можемо перевірити наявність зомбі-процесів у поточній системі?

```bash
ps -lef | awk '{print $2}' | grep Z
```

Ці символи можуть з’являтися в цьому стовпці:

- **D** – безперервний сон (зазвичай IO)
- **I** – Неактивний потік ядра
- **R** – запущено або доступно для виконання (у черзі виконання)
- **S** – переривчастий сон (очікування завершення події)
- **T** – зупинено сигналом керування завданням
- **t** - зупинено налагоджувачем під час трасування
- **W** - підкачка сторінок (недійсна з версії ядра 2.6.xx)
- **X** - мертвий (ніколи не повинен бути показаний)
- **Z** – нефункціонуючий («зомбі») процес, завершений, але не завантажений батьківським процесом
