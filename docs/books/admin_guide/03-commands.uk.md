---
title: Команди Linux
author: Antoine Le Morvan
contributors: Steven Spencer, Aditya Putta, tianci li, Grammaresque, Ganna Zhyrnova
---

# Команди для користувачів Linux

У цьому розділі ви дізнаєтеся про команди Linux і про те, як ними користуватися.

****

**Цілі**: у цьому розділі майбутні адміністратори Linux дізнаються, як:

:heavy_check_mark: **Робити переміщення** в системному дереві.   
:heavy_check_mark: **Створювати** текстовий файл, **відображати** його вміст і ** змінювати** його.   
:heavy_check_mark: **Використовувати** найкорисніші команди Linux.

:checkered_flag: **команди користувача**, **linux**

**Знання**: :star:   
**Складність**: :star:

**Час для читання**: 40 хвилин

****

## Загальні положення

Сучасні системи Linux мають графічні утиліти, призначені для роботи адміністратора. Однак важливо мати можливість використовувати інтерфейс у режимі командного рядка з кількох причин:

* Більшість системних команд є спільними для всіх дистрибутивів Linux, чого не можна сказати про графічні інструменти.
* Може статися так, що система не запускається належним чином, але резервний інтерпретатор команд залишається доступним.
* Віддалене адміністрування здійснюється через командний рядок за допомогою терміналу SSH.
* З метою збереження ресурсів сервера графічний інтерфейс або не встановлюється, або запускається за вимогою.
* Адміністрування здійснюється за допомогою скриптів.

Вивчення цих команд дозволяє адміністратору підключатися до терміналу Linux, керувати його ресурсами та файлами, ідентифікувати станцію, термінал і підключених користувачів тощо.

### Користувачі

Користувача системи Linux буде визначено у файлі `/etc/passwd` за допомогою:

* **Ім'я для входу**, яке частіше називають "логін", без пробілів.
* Цифровий ідентифікатор: **UID** (ідентифікатор користувача).
* Ідентифікатор групи: **GID** (ідентифікатор групи).
* **Інтерпретатор команд**, наприклад, оболонка, яка може відрізнятися для різних користувачів.
* **Каталог підключення**, наприклад, __домашній каталог__.

В інших файлах користувача буде визначено:

* **Паролем**, який шифрується перед збереженням (`/etc/shadow`).
* **Командним рядком** або __запитом__ для входу, який позначається `#` для адміністратора та `$` для інших користувачів (`/etc/profile`).

Залежно від політики безпеки, реалізованої в системі, пароль потребуватиме певної кількості символів і відповідатиме певним вимогам до складності.

Серед існуючих інтерпретаторів команд найбільш часто використовується **оболонка Bourne-Again** (`/bin/bash`). Вона призначається за замочуванням новим користувачам. З різних причин досвідчені користувачі Linux можуть вибрати альтернативні оболонки, такі як Korn Shell (`ksh`), C Shell (`csh`) тощо.

Каталог входу користувача за замовченням зберігається в каталозі `/home` робочої станції. Він міститиме персональні дані користувача та конфігураційні файли його програм. За замовчуванням під час входу поточним каталогом обирається каталог входу.

Інсталяція типу робочої станції (з графічним інтерфейсом) запускає цей інтерфейс на терміналі 1. Оскільки Linux є багатокористувацьким, можна підключити кількох користувачів кілька разів на різних **фізичних терміналах** (TTY) або **віртуальних терміналах ** (PTS). Віртуальні термінали доступні в графічному середовищі. Користувач перемикається з одного фізичного терміналу на інший за допомогою <kbd>Alt</kbd> + <kbd>Fx</kbd> із командного рядка або за допомогою <kbd>CTRL</kbd> + <kbd>Alt</kbd> + <kbd>Fx</kbd>.

### Оболонка

Після підключення користувача до консолі оболонка відображає **командний рядок**. Потім оболонка поводиться як нескінченний цикл, повторюючи той самий шаблон з кожним введеним оператором:

* Відображає командний рядок.
* Читає команду.
* Аналізує синтаксис.
* Замінює спеціальні символи.
* Виконує команду.
* Відображає командний рядок.
* Тощо.

Послідовність клавіш <kbd>CTRL</kbd> + <kbd>C</kbd> використовується для переривання виконання команди.

Зазвичай команда використовується в такій послідовності:

```bash
command [option(s)] [argument(s)]
```

Назва команди часто у **нижньому регістрі**.

Кожен елемент відокремлено пробілом.

**Короткі варіанти** починаються з тире (`-l`), тоді як **довгі параметри** починаються з двох тире (`--list`). Подвійне тире (`--`) вказує на кінець списку параметрів.

Можна групувати кілька коротких опцій разом:

```bash
$ ls -l -i -a
```

еквівалентно до:

```bash
$ ls -lia
```

Після параметра може бути кілька аргументів:

```bash
$ ls -lia /etc /home /var
```

У літературі термін «опція» еквівалентний терміну «параметр», який частіше використовується в програмуванні. Необов’язкова сторона параметра або аргументу позначається у квадратних дужках `[` і `]`. Якщо можливий більше ніж один варіант, вертикальна смуга, яка називається "канал", розділяє їх `[a|e|i]`.

## Загальні команди

### Команди `apropos`, `whatis` і `man`

Адміністратор будь-якого рівня не може детально знати всі команди та параметри. Для всіх встановлених команд зазвичай доступний посібник.

#### Команда `apropos`

Команда `apropos` дозволяє здійснювати пошук за ключовими словами на цих довідкових сторінках:

| Параметри                                | Опис                                                                   |
| ---------------------------------------- | ---------------------------------------------------------------------- |
| `-s`, `--список розділів` або `--розділ` | Обмежено ручними розділами.                                            |
| `-a` або `--and`                         | Відображає тільки елемент, що відповідає всім наданим ключовим словам. |

Наприклад:

```bash
$ apropos очищати
(1) - очистити термінальний екран
clear_console (1) - очистити консоль
clearenv (3) - очистити навколишнє середовище
clearerr (3) - перевірити і скинути статус трансляції
clearerr_unlocked (3) - неблокуючі функції stdio
feclearexcept (3) - floating-point засновування та обробка проблеми
fwup_clear_status (3) - для підтримки управління системними прошивками оновленнями
klogctl (3) - читати та/або очистити ядро повідомлення буфери; встановити рівень console_loglevel
sgt-samegame (6) - block-clearing задач
syslog (2) - читання та/або очищення кільцевого буфера повідомлень ядра; встановити console_loglevel
timerclear (3) - часові операції
XClearArea (3) - очистити область або вікно
XClearWindow (3) - очистити область або вікно
XSelectionClearEvent (3) - SelectionClear структуру подій
```

Щоб знайти команду, яка дозволить змінити пароль облікового запису:

```bash
$ apropos --exact пароль -a change
chage (1) - змінити інформацію про закінчення терміну дії пароля
passwd (1) - змінити пароль користувача
```

#### Команда `whatis`

Команда `whatis` відображає опис команди переданого аргументу:

```bash
whatis clear
```

Наприклад:

```bash
$ whatis
clear (1) - очистити екран терміналу
```

#### Команда `man`

Після того, як воно було знайдено за допомогою `apropos` або `whatis`, інструкція прочитується за допомогою `man` ("Man - це твій друг"). Цей набір посібників поділено на 8 розділів, згрупованих за темами, стандартним розділом є 1:

1. Виконувані програми або команди.
2. Системні виклики (функції, надані ядром).
3. Виклики бібліотеки (функції, надані бібліотекою).
4. Спеціальні файли (які, як правило, зустрічаються в /dev).
5. Формати файлів і правила (файли конфігурації, такі як etc/passwd).
6. Ігри (наприклад, програми на основі персонажів).
7. Різне (наприклад, man (7)).
8. Системні команди адміністрування (зазвичай лише для root).
9. Процедура ядра (не стандартна).

Інформацію про кожен розділ можна отримати шляхом введення `man x Intro`, де `x` - це номер розділу.

Команда:

```bash
man passwd
```

розповість адміністратору про команду passwd, її параметри тощо. Як :

```bash
$ man 5 passwd
```

повідомить його про файли, пов'язані з командою.

Переміщуйтеся в посібнику за допомогою стрілок <kbd>↑</kbd> та <kbd>↓</kbd>. Для виходу з посібника натисніть клавішу <kbd>q</kbd>.

### Команда `shutdown`

Команда `shutdown` дозволяє вам **електронно вимкнути** сервер Linux або негайно, або через певний період часу.

```bash
shutdown [-h] [-r] time [message]
```

Вкажіть час вимкнення у форматі `hh:mm` для точного часу або `+mm` для затримки у хвилинах.

Щоб примусово зупинити – використайте слово `now` замість часу. У цьому випадку, додаткове повідомлення не надсилається іншим користувачам системи.

Приклад:

```bash
[root]# shutdown -h 0:30 "Server shutdown at 0:30"
[root]# shutdown -r +5
```

Параметри:

| Опції | Зауваження                            |
| ----- | ------------------------------------- |
| `-h`  | Вимикає систему електронним способом. |
| `-r`  | Перезавантажує систему.               |

### Команда `history`

Команда `history` відображає історію команд, які були введені користувачем.

Команди зберігаються в файлі `.bash_history` у папці входу користувача.

Приклад команди history

```bash
$ history
147 man ls
148 man history
```

| Опції | Коментарі                                                              |
| ----- | ---------------------------------------------------------------------- |
| `-w`  | Записує поточну історію у файл історії.                                |
| `-c`  | Видаляє історію поточного сеансу (але не вміст файлу `.bash_history`). |

* Маніпулювання історією:

Для управління історією використовуються команди нижче, введені з командного рядка:

| Клавіші            | Функція                                                                   |
| ------------------ | ------------------------------------------------------------------------- |
| <kbd>!!</kbd>      | Відкликає останню введену команду.                                        |
| <kbd>!n</kbd>      | Відкликає команду за номером у списку.                                    |
| <kbd>!string</kbd> | Викликає останню команду, яка починається з рядка.                        |
| <kbd>↑</kbd>       | Переміщується у вашій історії, повертаючись у часі від останньої команди. |
| <kbd>↓</kbd>       | Переміщується у вашій історії, рухаючись вперед у часі.                   |

### Автозавершення

Автозавершення - це чудова допомога.

* Завершує команди, введені шляхи або імена файлів.
* Натисніть клавішу <kbd>TAB</kbd> , щоб завершити запис у випадку одного рішення.
* У випадку з множинними рішеннями натисніть <kbd>TAB</kbd> другий раз, щоб побачити варіанти.

Якщо подвійне натискання клавіші <kbd>TAB</kbd> не відображає варіанти, тоді немає розв'язку з поточним завершенням.

## Відображення та ідентифікація

### Команда `clear`

Команда `clear` очищує вміст екрана терміналу. Точніше, він зміщує дисплей так, щоб командний рядок знаходився у верхній частині екрана в першому рядку.

На фізичному терміналі дисплей буде постійно прихований, тоді як в графічному інтерфейсі, смуга прокручування дозволить вам повернутися в історію віртуального терміналу.

!!! Tip "Порада"

    <kbd>CTRL</kbd> + <kbd>L</kbd> матиме такий же ефект, що й команда `clear`

### Команда `echo`

Команда `echo` використовується для відображення рядка символів.

Ця команда найчастіше використовується в скриптах адміністрування, щоб проінформувати користувача під час виконання.

Параметр `-n` вказує на відсутність вихідного рядка нового рядка (за замовчуванням вихідний рядок нового рядка).

```bash
shell > echo -n "123";echo "456"
123456

shell > echo "123";echo "456"
123
456
```

З різних причин розробнику скриптів може знадобитися використання спеціальних послідовностей (починаючи з символу `\`). У цьому випадку буде передбачено параметр `-e`, що дозволяє інтерпретувати послідовності.

Серед часто використовуваних послідовностей ми можемо згадати:

| Послідовність | Результат                   |
| ------------- | --------------------------- |
| `\a`         | Надсилає звуковий сигнал    |
| `\b`         | Назад                       |
| `\n`         | Додає розрив рядка          |
| `\t`         | Додає горизонтальну вкладку |
| `\v`         | Додає вертикальну вкладку   |

### Команда `date`

Команда `date` відображає дату і час. Команда має наступний синтаксис:

```bash
date [-d yyyyMMdd] [format]
```

Приклади:

```bash
$ date
Mon May 24 16:46:53 CEST 2021
$ date -d 20210517 +%j
137
```

У цьому останньому прикладі, параметр `-d` відображає задану дату. Опція `+%j` форматує цю дату, щоб показати лише день року.

!!! Warning "Увага"

    Формат дати може змінюватися в залежності від значення мови, визначеного у змінній середовища `$LANG`.

Відображення дати може відповідати наступним форматам:

| Опція | Формат                                                            |
| ----- | ----------------------------------------------------------------- |
| `+%A` | Повна назва дня тижня (наприклад, неділя)                         |
| `+%B` | Повна назва місяця (наприклад, січень)                            |
| `+%c` | Дата й час у мовному коді (наприклад, Чт, 3 бер 23:05:25 2005 р.) |
| `+%d` | День місяця (напр., 01)                                           |
| `+%F` | Дата у `РРРР-ММ-ДД` форматі                                       |
| `+%G` | Рік                                                               |
| `+%H` | Година (00..23)                                                   |
| `+%j` | День року (001..366)                                              |
| `+%m` | Номер місяця (01..12)                                             |
| `+%M` | Хвилина (00..59)                                                  |
| `+%R` | Час в форматі `гг:хвхв`                                           |
| `+%s` | Секунди з 1 січня 1970 року                                       |
| `+%S` | Секунда (00..60)                                                  |
| `+%T` | Час у форматі`гг:хх:сс`                                           |
| `+%u` | День тижня (`1` для понеділка)                                    |
| `+%V` | Тиждень (`+%V`)                                                   |
| `+%x` | Дата у форматі `DDD/MM/YYYY`                                      |

Команда `date` також дозволяє змінювати системну дату та час. У такому випадку буде використана опція `-s`.

```bash
[root]# date -s "2021-05-24 10:19"
```

Формат, який слід використовувати після параметра `-s`, такий:

```bash
date -s "yyyy-MM-dd hh:mm[:ss]"
```

### Команди `id`, `who` та `whoami`

Команда `id` використовується для відображення інформації про користувачів і груп. За замовчуванням параметр користувача не додається, і відображається інформація про поточного користувача та групу

```bash
$ id rockstar
uid=1000(rockstar) gid=1000(rockstar) groups=1000(rockstar),10(wheel)
```

Параметри `-g`, `-G`, `-n` і `-u` відображають головну групу GID, підгрупу GID, імена замість числових ідентифікаторів та UID користувача відповідно.

Команда `whoami` відображає логін поточного користувача.

Команда `who` відображає імена зареєстрованих користувачів:

```bash
$ who
rockstar tty1   2021-05-24 10:30
root     pts/0  2021-05-24 10:31
```

Оскільки Linux є багатокористувацьким, можливо, що на одній станції відкрито кілька сеансів, фізично або через мережу. Цікаво знати, які користувачі авторизовані, хоча б для того, щоб спілкуватися з ними, надсилаючи повідомлення.

* tty: являє собою термінал.
* pts/: представляє віртуальну консоль у графічному середовищі з номером після представлення екземпляра віртуальної консолі (0, 1, 2...)

Параметр `-r` також відображає рівень виконання (див. розділ «запуск»).

## Дерево файлів

У Linux дерево файлів є перевернутим деревом, яке називається **єдиним ієрархічним деревом**, коренем якого є каталог `/`.

**Поточний каталог** – це каталог, у якому знаходиться користувач.

**Каталог підключення** – це робочий каталог, пов’язаний із користувачем. Каталоги входу за замовчуванням зберігаються в каталозі `/home`.

Коли користувач входить в систему, поточний каталог є каталогом входу.

**Абсолютний шлях** посилається на файл з кореня шляхом переміщення всього дерева на рівень файлу:

* `/home/groupA/alice/file`

**Відносний шлях** посилається на той самий файл, обходячи все дерево з поточного каталогу:

* `../alice/file`

У наведеному вище прикладі,`..`" посилається на батьківський каталог поточної директорії.

Директорія, навіть якщо вона порожня, обов'язково буде містити принаймні **два посилання**:

* `.`: посилання на саму себе.
* `..`: посилання на батьківський каталог поточної папки.

Відносний шлях може починатися з `./` або `../`. Коли відносний шлях посилається на підкаталог або файл у поточному каталозі, тоді `./` часто виконується. Згадка першого `./` у дереві справді потрібна лише для запуску виконуваного файлу.

Помилки в шляхах можуть викликати багато проблем: створення папок або файлів у неправильних місцях, ненавмисне видалення тощо. Тому наполегливо рекомендується використовувати автозавершення під час введення шляхів.

![наш приклад дерева](images/commands-pathabsolute.png)

У наведеному вище прикладі ми намагаємося визначити розташування файлу `myfile` з директорії bob.

* За **абсолютного шляху** поточний каталог не має значення. Ми починаємо з кореня і продовжуємо працювати вниз до директорій `home`, `groupA` `alice` і нарешті файл `myfile`: `/home/groupA/alice/myfile`.
* До **відносного шляху**, нашою початковою точкою є поточний каталог `bob`, ми йдемо на один рівень до `.` (напр. в каталог `groupA` і потім вниз в каталог alice, і нарешті `myfile` файл: `. /alice/myfile`.

### Команда `pwd`

Команда `pwd` (Print Working Directory - Друк Робочого Каталогу) відображає абсолютний шлях до поточного каталогу.

```bash
$ pwd
/home/rockstar
```

Щоб використати відносний шлях для посилання на файл чи каталог або використати команду `cd` для переходу до іншого каталогу, ви повинні знати його розташування в дереві файлів.

В залежності від типу оболонки і різних параметрів файлу конфігурації, командний рядок терміналу (також відомий як командний рядок) буде відображати абсолютний або відносний шлях до поточної директорії.

### Команда `cd`

Команда `cd` (Change Directory - Зміна Директорії) дозволяє змінювати поточну теку -- іншими словами, рухатися деревом.

```bash
$ cd /tmp
$ pwd
/tmp
$ cd ../
$ pwd
/
$ cd
$ pwd
/home/rockstar
```

Як ви бачите в останньому прикладі вище, команда `cd` без аргументів переміщує поточний каталог до `домашнього каталогу`.

### Команда `Is`

Команда `ls` відображає вміст каталогу.

```bash
ls [-a] [-i] [-l] [directory1] [directory2] […]
```

Наприклад:

```bash
$ ls /home
.    ..    rockstar
```

Основні параметри команди `ls`:

| Опція | Опис                                                                                                                  |
| ----- | --------------------------------------------------------------------------------------------------------------------- |
| `-a`  | Відображає всі файли, навіть приховані. Приховані файли в Linux починаються з `.`.                                    |
| `-і`  | Відображає номери inode.                                                                                              |
| `-l`  | Використовує формат довгого списку, тобто кожен рядок відображає інформацію про довгий формат для файлу або каталогу. |

Команда `ls`, однак, має багато варіантів (див. `man`):

| Опція | Опис                                                                                                                                                                     |
| ----- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `-d`  | Відображає інформацію про каталог замість того, щоб показати його вміст.                                                                                                 |
| `-g`  | Як параметр -l, але не вказує власника.                                                                                                                                  |
| `-h`  | Відображає розміри файлу у найбільш доцільному форматі (байт, кілобайт, мегабайт, ...). `h` означає «читабельний». Потребує використання з -l опцією.                    |
| `-s`  | Відображає розмір виділеного файлу в блоках. В операційній системі GNU/Linux «блок» — це найменша одиниця зберігання у файловій системі, один блок дорівнює 4096 байтам. |
| `-А`  | Відображає усі файли у каталозі за винятком `.` і `..`                                                                                                                   |
| `-R`  | Відображає вміст підкаталогів рекурсивно.                                                                                                                                |
| `-F`  | Відображає тип файлів. Виводить `/` для каталогу, `*` для виконуваних файлів, `@` для символічного посилання, і нічого для текстового файлу.                             |
| `-X`  | Сортує файли за їх розширеннями.                                                                                                                                         |

* Опис стовпців, згенерованих виконанням команди `ls -lia`:

```bash
$ ls -lia /home
78489 drwx------ 4 rockstar rockstar 4096 25 oct. 08:10 rockstar
```

| Значення        | Опис                                                                                                                                                                                                   |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `78489`         | Номер Inode.                                                                                                                                                                                           |
| `drwx------`    | Тип файлу (`d`) і права (`rwx------`).                                                                                                                                                                 |
| `4`             | Кількість підкаталогів (`.` і `..` включено). Для файлу це кількість жорстких посилань, і 1 представляє сам себе.                                                                                      |
| `rockstar`      | Власність користувача.                                                                                                                                                                                 |
| `rockstar`      | Власність групи.                                                                                                                                                                                       |
| `4096`          | Для файлів, показує розмір файлу. Для каталогів відобразиться фіксоване значення 4096 байт, окуповане іменуванням файлу. Для обчислення загального розміру каталогу, використовуйте `du -sh rockstar/` |
| `25 oct. 08:10` | Дата останньої зміни.                                                                                                                                                                                  |
| `rockstar`      | Ім'я файлу (або каталогу).                                                                                                                                                                             |

!!! Note "Примітка"

    **Псевдоніми** часто розміщуються в звичайних дистрибутивах.
    
    Це у випадку цього псевдоніма "ll":

    ```
    alias ll='ls -l --color=auto'
    ```

Команда `l` має багато параметрів. Ось кілька продвинутих прикладів використання:

* Перелічити файли в `/etc` в порядку останньої модифікації:

```bash
$ ls -ltr /etc
total 1332
-rw-r--r--.  1 root root    662 29 may   2021 logrotate.conf
-rw-r--r--.  1 root root    272 17 may.   2021 mailcap
-rw-------.  1 root root    122 12 may.  2021 securetty
...
-rw-r--r--.  2 root root     85 18 may.  17:04 resolv.conf
-rw-r--r--.  1 root root     44 18 may.  17:04 adjtime
-rw-r--r--.  1 root root    283 18 may.  17:05 mtab
```

* Список файлів `/var` більше, ніж 1 мегабайт, але меньше ніж 1 гігабайт. Приклад тут використовує додаткові `grep` команди з регулярними виразами. Новачкам не доведеться надто мучитися, у майбутньому буде спеціальний підручник, щоб представити ці регулярні вирази.

```bash
$ ls -lhR /var/ | grep ^\- | grep -E "[1-9]*\.[0-9]*M" 
...
-rw-r--r--. 1 apache apache 1.2М 10 may.  13:02 XB RiyazBdIt.ttf
-rw-r--r--. 1 apache apache 1.2М 10 may.  13:02 XB RiyazBd.ttf
-rw-r--r--. 1 apache apache 1.1М 10 may.  13:02 XB RiyazIt.ttf
...
```

Звичайно, ми рекомендуємо використовувати команду `find`.

```bash
$ find /var -size +1M -a size -1024M -type f -exec -lh {} \;
```

* Показати права на папку:

Щоб дізнатися права на папку, у нашому прикладі `/etc`, наступна команда **not** підійде:

```bash
$ ls -l /etc
total 1332
-rw-r--r--.  1 root root     44 18 nov.  17:04 adjtime
-rw-r--r--.  1 root root   1512 12 janv.  2010 aliases
-rw-r--r--.  1 корінь з 12288 Нью.  17:41 aliases.db
drwxr-xr-x.  2 корінь з 4096 17 Новин.  17:48 альтернатив
...
```

Наведена вище команда відобразить вміст папки (всередині) за замовчуванням. Для самої папки, ви можете використовувати опцію `-d`.

```bash
$ ls -ld /etc
drwxr-xr-x. 69 root root 4096 18 nov.  17:05 /etc
```

* Сортувати за розміром файлу, спочатку найбільший:

```bash
$ ls -lhS
```

* формат часу /дати з `-l`:

```bash
$ ls -l --time-style="+%Y-%m-%d %m-%d %H:%M" /
всього 12378
dr-xr-xr-x. 2 root root 4096 2014-11-23 11-23 03:13 bin
dr-xr-xr-x. 5 root root 1024 2014-11-23 11-23 05:29 boot
```

* Додайте _косу риску_ в кінці папок:

За замовчуванням команда `ls` не відображає останню косу риску папки. У деяких випадках, як, наприклад, для сценаріїв, корисно їх відобразити:

```bash
$ ls -dF /etc
/etc/
```

* Приховати деякі розширення:

```bash
$ ls /etc --hide=*.conf
```

### Команда `mkdir`

Команда `mkdir` створює папку або дерево.

```bash
mkdir [-p] каталог [directory] [...]
```

Наприклад:

```bash
$ mkdir /home/rockstar/work
```

Має існувати каталог "rockstar", щоб створити каталог "work".

В іншому випадку слід використовувати параметр `-p`. Параметр `-p` створює батьківські каталоги, якщо вони не існують.

!!! danger "Важливо"

    Не рекомендується використовувати назви команд Linux як каталог або файлові імена.

### Команда `touch`

Команда `touch` змінює відмітку файлу або створює порожній файл, якщо цього файлу не існує.

```bash
touch [-t date] file
```

Наприклад:

```bash
$ touch /home/rockstar/myfile
```

| Опція     | Опис                                                         |
| --------- | ------------------------------------------------------------ |
| `-t date` | Змінює дату останньої модифікації файлу із зазначеною датою. |

Формат дати: `[AAAA]MMJhhmm[ss]`

!!! Tip "Порада"

    Команда `touch` в першу чергу використовується для створення пустого файлу, але це може бути корисним для додаткових або диференціальних резервних копій. Дійсно, єдиним ефектом виконання команди`touch` до файлу буде примусове його збереження під час наступного резервного копіювання.

### Команда ` rmdir`

Команда `rmdir` видаляє порожню папку.

Наприклад:

```bash
$ rmdir /home/rockstar/work
```

| Опція | Опис                                                                 |
| ----- | -------------------------------------------------------------------- |
| `-р`  | Видаляє батьківський каталог або надані каталоги, якщо вони порожні. |

!!! Tip "Порада"

    Щоб видалити як непорожній каталог, так і його вміст, скористайтеся командою `rm`.

### Команда `rm`

Команда `rm` видаляє файл або каталог.

```bash
rm [-f] [-r] файл [file] [...]
```

!!! Danger "Важливо"

    Будь-яке видалення файлу чи каталогу остаточне.

| Опції | Опис                                                     |
| ----- | -------------------------------------------------------- |
| `-f`  | Не питати, чи слід видаляти.                             |
| `-і`  | Питати, чи слід вилучити.                                |
| `-р`  | Видалити каталог і рекурсивно видалити його підкаталоги. |

!!! Note "Примітка"

    Сама команда `rm` не запитує підтвердження під час видалення файлів. Однак у дистрибутиві Red Hat/Rocky `rm` запитує підтвердження видалення, оскільки команда `rm` є псевдонімом команди `rm -i`. Не дивуйтеся, якщо в іншому дистрибутиві, як, наприклад, Debian, ви не отримаєте запит на підтвердження.

Видалення папки за допомогою команди `rm`, незалежно від того, порожня вона чи ні, потребує додавання параметра `-r`.

Кінець опцій виводиться до оболонки подвійним рискою `--`.

Наприклад:

```bash
$ >-hard-hard # To create an empty file called -hard-hard
hard-hard
[CTRL+C] To interrupt the creation of the file
$ rm -f -- -hard-hard
```

Ім'я файлу hard-hard починається з `-`. Без використання `--` оболонка інтерпретувала б `-d` у `-hard-hard` як опцію.

### Команда `mv`

Команда `mv` переміщує та перейменовує файл.

```bash
файл mv [файл ...] призначення
```

Приклад:

```bash
$ mv /home/rockstar/file1 /home/rockstar/file2
$ mv /home/rockstar/file1 /home/rockstar/file2 /tmp
```

| Опції | Опис                                                                     |
| ----- | ------------------------------------------------------------------------ |
| `-f`  | Не запитувати підтвердження якщо перезапис файлу призначення.            |
| `-і`  | Підтвердження запиту, якщо перезапис вихідного файлу (за замовчуванням). |

Кілька конкретних випадків допоможуть вам зрозуміти труднощі, що можуть виникнути:

```bash
$ mv /home/rockstar/file1 /home/rockstar/file2
```

Перейменовує `file1` на `file2`. Якщо `file2` вже існує, замінити вміст файлу на `file1`.

```bash
$ mv /home/rockstar/file1 /home/rockstar/file2 /tmp
```

Переміщення `file1` і `file2` до папки `/tmp`.

```bash
$ mv file1 /repexist/file2
```

Переміщує `file1` у `repexist` і перейменовує його на `file2`.

```bash
$ mv file1 file2
```

`file1` перейменовано на `file2`.

```bash
$ mv file1 /repexist
```

Якщо цільовий каталог існує, `file1` переміщується до `/repexist`.

```bash
$ mv file1 /wrongrep
```

Якщо цільовий каталог не існує, `file1` буде перейменовано на `wrongrep` у кореневому каталозі.

### Команда `cp`

Команда `cp` копіює файл.

```bash
cp file [file ...] destination
```

Наприклад:

```bash
$ cp -r /home/rockstar /tmp
```

| Опції | Опис                                                                |
| ----- | ------------------------------------------------------------------- |
| `-і`  | Запитувати підтвердження в разі перезапису (за замовчуванням).      |
| `-f`  | Не запитувати підтвердження, якщо перезаписується файл призначення. |
| `-р`  | Зберігає власника, дозволи та позначку часу скопійованого файлу.    |
| `-r`  | Копіює каталог з його файлами і підкаталогами.                      |
| `-s`  | Створює символічне посилання, а не копіює.                          |

```bash
cp file1 /repexist/file2
```

`file1` скопійовано до `/repexist` під назвою `file2`.

```bash
$ cp file1 file2
```

`file1` копіюється як `file2` у цю теку.

```bash
$ cp file1 /repexist
```

Якщо цільовий каталог існує, `file1` копіюється в `/repexist`.

```bash
$ cp file1 /wrongrep
```

Якщо директорії призначення не існує, `file1` копіюється під назвою `wrongrep` в кореневий каталог.

## Візуалізація

### Команда `file`

Команда `file` відображає тип файлу.

```bash
file file1 [files]
```

Наприклад:

```bash
$ file /etc/passwd /etc
/etc/passwd:    ASCII text
/etc:        directory
```

### Команда `more`

Команда `more` екран за екраном відображає вміст одного чи кількох файлів.

```bash
more file1 [files]
```

Наприклад:

```bash
$ more /etc/passwd
root:x:0:0:root:/root:/bin/bash
...
```

За допомогою клавіші <kbd>ENTER</kbd> переміщайте рядок за рядком. За допомогою клавіші <kbd>ПРОБІЛ</kbd> переміщайте сторінку за сторінкою. `/text` дозволяє шукати входження у файл.

### Команда `less`

Команда `less` відображає вміст одного або кількох файлів. Команда `less` є інтерактивною та має власні команди для використання.

```bash
less file1 [files]
```

Команди, специфічні для `less`:

| Команда                                          | Дія                                               |
| ------------------------------------------------ | ------------------------------------------------- |
| <kbd>h</kbd>                                     | Допомогти.                                        |
| <kbd>↑</kbd><kbd>↓</kbd><kbd>→</kbd><kbd>←</kbd> | Рухатися вгору, вниз лінією праворуч або ліворуч. |
| <kbd>Enter</kbd>                                 | Посунути вниз на один рядок.                      |
| <kbd>Space</kbd>                                 | Посунути на одну сторінку.                        |
| <kbd>PgUp</kbd> і <kbd>PgDn</kbd>                | Посунути вгору або вниз одну сторінку.            |
| <kbd>gg</kbd> і <kbd>G</kbd>                     | Посунути на перші та останні сторінки             |
| `/text`                                          | Пошук тексту.                                     |
| <kbd>q</kbd>                                     | Закриває команду `less`.                          |

### Команда `cat`

Команда `cat` генерує вміст кількох файлів і відображає результат стандартного виводу.

```bash
cat file1 [files]
```

Приклад 1. Відображення вмісту файлу в стандартному виводі:

```bash
$ cat /etc/passwd
```

Приклад 2. Відображення вмісту кількох файлів у стандартному виводі:

```bash
$ cat /etc/passwd /etc/group
```

Приклад 3. Об’єднання вмісту кількох файлів в один файл за допомогою переспрямування виводу:

```bash
$ cat /etc/passwd /etc/group > usersAndGroups.txt
```

Приклад 4 - Відображення нумерації рядків:

```bash
$ cat -n /etc/profile
     1 # /etc/profile: загальносистемний файл .profile для оболонки Bourne (sh(1))
     2 # і Bourne сумісні оболонки (bash(1), ksh(1), ash(1), ...).
     3
     4, якщо [ "id -u`" -eq 0 ]; потім
     5 PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/sbin:/sbin:/binbinbinbin"
     6 інакше
…
```

Приклад 5 - Показує нумерацію непорожніх рядків:

```bash
$ cat -b /etc/profile
     1 # /etc/profile: загальносистемний файл .profile для оболонки Bourne (sh(1))
     2 # # і Bourne сумісні оболонки (bash(1), ksh(1), ash(1), ...).

     3    if [ "`id -u`" -eq 0 ]; then
     4      PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
     5    else
…
```

### Команда `tac`

Команда `tac` діє майже протилежно команді `cat`. Вона відображає вміст файлу, починаючи з кінця (що особливо цікаво для читання журналів!).

Приклад: відобразити файл журналу, відобразивши спочатку останній рядок:

```bash
[root]# tac /var/log/messages | less
```

### Команда `head`

Команда `head` відображає початок файлу.

```bash
head [-n x] file
```

| Опція  | Опис                             |
| ------ | -------------------------------- |
| `-n х` | Показувати перші `x` рядки файлу |

За замовчуванням (без опції `-n`), команда `head` відображає перші 10 рядків файлу.

### Команда `tail`

Команда `tail` відображає кінець файлу.

```bash
tail [-f] [-n x] file
```

| Опція  | Опис                                       |
| ------ | ------------------------------------------ |
| `-n х` | Відображає останні `x` рядків файлу        |
| `-f`   | Відображає зміни до файлу в реальному часі |

Наприклад:

```bash
tail -n 3 /etc/passwd
sshd:x:74:74:Privilege-separeted sshd:/var/empty /sshd:/sbin/nologin
tcpdump:x:72::/:/sbin/nologin
user1:x:500:500:grp1:/home/user1:/b/bash
```

За допомогою параметра `-f` інформація про зміни файлу завжди виводитиметься, якщо користувач не вийде зі стану моніторингу за допомогою <kbd>CTRL</kbd> + <kbd>C</kbd>. Ця опція дуже часто використовується для відстеження файлів журналів (логів) в реальному часі.

Без опції `-n` команда `tail` відображає останні 10 рядків файлу.

### Команда `sort`

Команда `sort` сортує рядки файлу.

Це дозволяє впорядкувати результат виконання команди або вміст файлу в заданому порядку, за цифрами, алфавітом, розміром (КБ, МБ, ГБ) або у зворотному порядку.

```bash
sort [-k] [-n] [-u] [-o file] [-t] file
```

Наприклад:

```bash
$ sort -k 3,4 -t ":" -n /і т. д/passwd
root:0:0:root:/bin/bash
adm:x:3:adm:/var/adm/adm/:/sbin/nologin
```

| Опція     | Опис                                                                                                                                                       |
| --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `-k`      | Вказує стовпці, які слід розділити. Ви можете вказати кілька стовпців.                                                                                     |
| `-n`      | Запитує числове сортування.                                                                                                                                |
| `-o file` | Зберігає сортування у вказаний файл.                                                                                                                       |
| `-t`      | Вказує роздільник, який вимагає, щоб вміст відповідного файлу був регулярно розділений вмістом стовпця, інакше його неможливо відсортувати належним чином. |
| `-r`      | Зворотний порядок результату. Використовується в поєднанні з опцією `-n` для сортування в порядку від найбільшого до найменшого.                           |
| `-u`      | Прибирає дублікати після сортування. Еквівалентно `sort file | uniq`.                                                                                      |

Команда `sort` сортує файл тільки на екрані. Файл не змінюється у сортуванні. Для збереження сортування використовуйте параметр `-o` або перенаправлення виводу `>`.

За замовчуванням числа відсортовані відповідно до їх значення. Таким чином, «110» буде перед «20», яке саме перед «3». Параметр `-n` повинен бути вказаний таким чином, щоб числові символьні блоки впорядковуються за їх значенням.

Команда `sort` змінює порядок результатів на протилежний за допомогою параметра `-r`:

```bash
$ sort -k 3 -t ":" -n -r /etc/passwd
nobody:65534:65534:65534:Kernel Overflow User:/sbin/nologin
systemd-coredump:x:999:997:systemd Core Dumper:/sbin/nologin
polkitd:x:998:996:User for polkitd:/sbin/nologin
```

У цьому прикладі команда `sort` відсортує вміст файлу `/etc/passwd` від найбільшого uid (ідентифікатора користувача) до найменшого.

Деякі додаткові приклади використання команди `sort`:

* Перетасування значень

Команда `sort` також дозволяє перетасувати значення за допомогою параметра `-R`:

```bash
$ sort -R /etc/passwd
```

* Сортування IP-адрес

Системний адміністратор швидко стикається з обробкою IP-адрес із журналів своїх служб, таких як SMTP, VSFTP або Apache. Ці адреси зазвичай витягуються за допомогою команди `cut`.

Ось приклад з файлом `dns-client.txt`:

```
192.168.1.10
192.168.1.200
5.1.150.146
208.128.150.98
208.128.150.99
```

```bash
$ sort -nr dns-client.txt
208.128.150.99
208.128.150.98
192.168.1.200
192.168.1.10
5.1.150.146
```

* Сортування файлу шляхом видалення дублікатів

Команда `sort` знає, як видалити дублікати з виведення файлу за допомогою `-u` як параметра.

Ось приклад із файлом `colours.txt`:

```
Red
Green
Blue
Red
Pink
```
```
$ sort -u colours.txt
Blue
Green
Pink
Red
```

* Сортування файлу за розмірами

Команда `sort` знає, як розпізнавати розміри файлів за допомогою таких команд, як `ls` з опцією `-h`.

Приклад з файлом `size.txt`:

```
1.7G
18M
69K
2.4М
1.2М
4.2G
6М
124М
12.4М
4G
```

```bash
$ sort -hr size.txt
4.2G
4G
1.7G
124M
18M
12.4M
6M
2.4M
1.2M
69K
```

### Команда `wc`

Команда `wc` рахує кількість рядків, слів та/або байтів у файлі.

```bash
wc [-l] [-m] [-w] файл [files]
```

| Опція | Опис                         |
| ----- | ---------------------------- |
| `-c`  | Рахує кількість байт.        |
| `-m`  | Рахує кількість символів.    |
| `-m`  | Підраховує кількість рядків. |
| `-w`  | Підраховує кількість слів.   |

## Пошук

### Команда `find`

Команда `find` шукає розташування файлів або каталогів.

```bash
знайти каталог [-name name] [-type type] [-user login] [-date date] [-date date]
```

Оскільки існує стільки варіантів для команди `find`, краще посилатися на `man`.

Якщо каталог пошуку не вказано, команда `find,` знайде поточну директорію.

| Опція               | Опис                          |
| ------------------- | ----------------------------- |
| `-perm permissions` | Пошук файлів за їх дозволами. |
| `-size size`        | Пошук файлів за розміром.     |

### Параметр `-exec` команди `find`

Можна використати опцію `-exec` команди `find`, щоб виконати команду в кожному рядку результату:

```bash
$ find /tmp -name *.txt -exec rm -f {} \;
```

Попередня команда шукає всі файли в каталозі `/tmp` під назвою `*.txt` і видаляє їх.

!!! Підказка "Зрозуміти параметр `-exec`

    У наведеному вище прикладі команда `find` створить рядок, який представлятиме команду, яку потрібно виконати.
    
    Якщо команда `find` знайде три файли з іменами `log1.txt`, `log2.txt` і `log3.txt`, тоді команда `find` створить рядок, замінивши в рядку `rm -f {} \;` фігурні дужки з одним із результатів пошуку, і виконає це стільки разів, скільки буде результатів.
    
    Це нам дасть:

    ```
    rm -f /tmp/log1.txt ; rm -f /tmp/log2.txt ; rm -f /tmp/log3.txt ;
    ```


    Символ `;` — це спеціальний символ оболонки, який має бути захищений символом `\`, щоб запобігти його передчасній інтерпретації командою `find` (а не в `-exec`).

!!! tip "Порада"

    `$ find /tmp -name *.txt -delete` робить те саме.

### Команда `whereis`

Команда `whereis` шукає файли, пов’язані з командою.

```bash
де [-b] [-m] [-s] команда
```

Наприклад:

```bash
$ whereis -b ls
ls: /bin/ls
```

| Опція | Опис                                 |
| ----- | ------------------------------------ |
| `-b`  | Для пошуку тільки у бінарному файлі. |
| `-m`  | Шукає лише сторінки довідок.         |
| `-s`  | Для пошуку тільки вихідних файлів.   |

### Команда `grep`

Команда `grep` шукає рядок у файлі.

```bash
grep [-w] [-i] [-v] "string" file
```

Наприклад:

```bash
$ grep -w "root:" /etc/passwd
root:x:0:0:root:/bin/bash
```

| Опція | Опис                              |
| ----- | --------------------------------- |
| `-і`  | Ігнорує регістр шуканого рядка.   |
| `-v`  | Виключає рядки, що містять рядок. |
| `-w`  | Пошук точного слова.              |

Команда `grep` повертає повний рядок, що містить рядок, який ви шукаєте.
* Спеціальний символ `^` використовується для пошуку рядка на початку рядка.
* Спеціальний символ `$` шукає рядок в кінці рядка.

```bash
$ grep -w "^root" /etc/passwd
```

!!! Note "Примітка"

    Ця команда дуже потужна, і настійно рекомендуємо ознайомитись з її посібником. У ньому багато похідних.

Можна шукати рядок у дереві файлів за допомогою параметра `-R`.

```bash
grep -R "Virtual" /etc/httpd
```

### Мета-символи (знаки підстановки)

Метасимволи замінюють один або кілька символів (або навіть відсутність символів) під час пошуку. Ці метасимволи також відомі як символи підстановки.

Їх можна поєднувати.

Символ `*` замінює рядок, що складається з будь-яких символів. Символ `*` також може означати відсутність символу.

```bash
$ find /home -name "test*"
/home/rockstar/test
/home/rockstar/test1
/home/rockstar/test11
/home/rockstar/tests
/home/rockstar/test362
```

Метасимволи дозволяють здійснювати більш складний пошук шляхом заміни всього або частини слова. Просто замініть невідомі цими спеціальними символами.

Символ `?` замінює один символ, яким би він не був.

```bash
$ find /home -name "test?"
/home/rockstar/test1
/home/rockstar/tests
```

Квадратні дужки `[` і `]` використовуються для визначення значень, які може приймати один символ.

```bash
$ find /home -name "test[123]*"
/home/rockstar/test1
/home/rockstar/test11
/home/rockstar/test362
```

!!! Note "Примітка"

    Завжди оточуйте слова, що містять метасимволи, символом "", щоб запобігти їх заміні назвами файлів, які відповідають критеріям.

!!! warning "Важливо"

    Не плутайте мета-символи оболонки з мета-символами регулярних виразів. Команда `grep` використовує метасимволи регулярного виразу.

## Перенаправлення та канали

### Стандартний ввід та вихід

На системи UNIX та Linux існує три стандартні потоки. Вони дозволяють програмам через бібліотеку `stdio.h` вводити або виводити інформацію.

Ці потоки називаються X-каналом або X-файловим дескриптором.

За замовчуванням:

* клавіатура це пристрій вводу для каналу 0, який називається **stdin**;
* екран є пристроєм виведення для каналів 1 і 2, який називається **stdout** і **stderr**.

![стандартні канали](images/input-output.png)

**stderr** отримує повідомлення про помилку, які повертає команда. Інші трансляції спрямовані на **stdout**.

Ці потоки вказують на периферійні файли, але оскільки все є файлом в UNIX/Linux, потоки введення-виведення можна легко перенаправити в інші файли. Цей принцип - сила оболонки.

### Переспрямування вводу

Можна перенаправити вхідний потік з іншого файлу за допомогою символу `<` або `<<`. Команда прочитає файл замість клавіатури:

```bash
$ ftp -in serverftp << ftp-commands.txt
```

!!! Note "Примітка"

    Тільки команди, які потребують введення клавіатури, зможуть виконувати переадресацію введення.

Також можна використовувати переадресацію вводу для імітації взаємодії користувачів. Команда читатиме вхідний потік, доки не зустріне визначене ключове слово після переспрямування введення.

Ця функція використовується для скрипту інтерактивних команд:

```bash
$ ftp -in serverftp << END
user alice password
put file
bye
END
```

Ключове слово `END` може бути замінене будь-яким словом.

```bash
$ ftp -in serverftp << STOP
user alice password
put file
bye
STOP
```

Оболонка завершує роботу команди `ftp`, коли отримує рядок, що містить лише ключове слово.

!!! warning "Важливо"

    Кінцеве ключове слово, тут `END` або `STOP`, має бути єдиним словом у рядку та має бути на початку рядка.

Стандартне переспрямування вводу використовується рідко, оскільки більшість команд приймає назву файлу як аргумент.

Команда `wc` може бути використана приблизно так:

```bash
$ wc -l .bash_profile
27. ash_profile # кількість рядків слідує імені файлу
$ wc -l < . ash_profile
27 # повертає тільки кількість рядків
```

### Перенаправлення виводу

Стандартний вихід можна перенаправляти до інших файлів за допомогою символів `>` або `>>`.

Просте переспрямування `>` перезаписує вміст вихідного файлу:

```bash
$ date +%F > date_file
```

Якщо використовується символ `>>`, це вказує на те, що вихідний результат команди додається до вмісту файлу.

```bash
$ date +%F >> date_file
```

В обох випадках файл створюється автоматично, коли він не існує.

Стандартний вивід помилки також може бути перенаправлений в інший файл. Цього разу буде необхідно вказати номер каналу (який може бути опущений для каналів 0 і 1):

```bash
$ ls -R / 2> errors_file
$ ls -R / 2>> errors_file
```

### Приклади перенаправлення

Перенаправлення 2 виходів у 2 файли:

```bash
$ ls -R / >> ok_file 2>> nok_file
```

Перенаправлення 2 виходів в один файл:

```bash
$ ls -R / >> log_file 2>&1
```

Переспрямування *stderr* до «бездонної ями» (`/dev/null`):

```bash
$ ls -R / 2>> /dev/null
```

Коли обидва вихідні потоки перенаправляються, інформація на екрані не відображається. Щоб використовувати як переспрямування виводу, так і зберегти відображення, вам доведеться використати команду `tee`.

### Роздільники

**Роздільник** — це механізм, який дозволяє зв’язати стандартний вихід першої команди зі стандартним входом другої команди.

Цей зв’язок є односпрямованим і здійснюється за допомогою символу `|`. Символ вертикальної лінії `|` отримується одночасним натисканням <kbd>SHIFT</kbd> + <kbd>|</kbd>.

![роздільник](images/pipe.png)

Усі дані, надіслані елементом керування зліва від каналу через стандартний вихідний канал, надсилаються на стандартний вхідний канал керування праворуч.

Особливі команди, що використовуються після тимчасового фільтру.

* Приклад:

Відображати лише початок:

```bash
$ ls -lia / | head
```

Відобразити тільки кінець:

```bash
$ ls -lia / | tail
```

Сортувати результат:

```bash
$ ls -lia / | sort
```

Порахувати кількість слів/символів:

```bash
$ ls -lia / | wc
```

Шукати рядок в результаті:

```bash
$ ls -lia / | grep fichier
```

## Особливі моменти

### Команда `tee`

Команда `tee` використовується для перенаправлення стандартного виводу команди у файл, зберігаючи відображення на екрані.

Він поєднується з каналом `|`, щоб отримати як вхідні дані команди, яку потрібно перенаправити:

```bash
$ ls -lia / | tee fic
$ cat fic
```

Параметр `-a` додає до файлу, а не перезаписує його.

### Команди `alias` і `unalias`

Використання **alias** — це спосіб попросити оболонку запам’ятати певну команду з її параметрами та дати їй назву.

Наприклад:

```bash
$ ll
```

замінить команду:

```bash
$ ls -l
```

Команда `alias` містить список псевдонімів для поточного сеансу. У дистрибутивах Linux псевдоніми встановлюються за замовчуванням. Тут псевдоніми для сервера Rocky:

```bash
$ alias
alias l.='ls -d .* --color=auto'
alias ll='ls -l --color=auto'
alias ls='ls --color=auto'
alias vi='vim'
alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'
```

Псевдоніми визначені лише тимчасово, на час сеансу користувача.

Для постійного використання вони повинні бути створені через:

* `.bashrc` файл в каталозі облікових записів користувача;
* `файл /etc/bashrc` для всіх користувачів.

!!! warning "Важливо"

    Слід бути особливо обережним при використанні псевдонімів, які можуть бути потенційно небезпечними! Наприклад, псевдонім, створений без знань адміністратора:

    ```bash
    alias cd='rm -Rf'
    ```

Команда `unalias` дозволяє видаляти псевдоніми.

Щоб видалити один псевдонім:

```bash
$ unalias ll
```

Щоб видалити всі псевдоніми:

```bash
$ unalias -a
```

Щоб тимчасово вимкнути псевдонім, використовуйте комбінацію `\&#060;alias name&#062;`.

Наприклад, якщо ми робимо:

```bash
$ type ls
```

може повернути наступне:

```bash
ls is an alias to « ls -rt »
```

Тепер, коли це відомо, ми можемо побачити результати використання псевдоніма або одноразового вимкнення за допомогою `\`, виконавши наступне:

```bash
$ ls file* # order by time
file3.txt file2.txt file1.txt
$ \ls file* # order by name
file1.txt file2.txt file3.txt file3.txt
```

### Псевдоніми та корисні функції

* Псевдонім `grep`.

Розфарбуйте результат виконання команди `grep`: `alias grep='grep --color=auto'`

* Функція `mcd`

Зазвичай створюють папку, а потім переміщуються в ній: `mcd() { mkdir -p "$1"; cd "$1"; }`

* Функція `cls`

Перейдіть до папки та перегляньте її вміст: `cls() { cd "$1"; ls; }`

* Функція `backup`

Створіть резервну копію файлу: `backup() { cp "$1"{,.bak}; }`

* Функція `extract`

Видобути будь-який тип архіву:

```bash
extract () {
  if [ -f $1 ] ; then
    case $1 in
      *.tar.bz2) tar xjf $1 ;;
      *.tar.gz) tar xzf $1 ;;
      *.bz2) bunzip2 $1 ;;
      *.rar) unrar e $1 ;;
      *.gz) gunzip $1 ;;
      *.tar) tar xf $1 ;;
      *.tbz2) tar xjf $1 ;;
      *.tgz) tar xzf $1 ;;
      *.zip) unzip $1 ;;
      *.Z) uncompress $1 ;;
      *.7z) 7z x $1 ;;
      *)
        echo "'$1' cannot be extracted via extract()" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}

```

* Якщо `alias cmount` повертає таке: `alias cmount="mount | column -t"`

Тоді ми можемо використати `cmount`, щоб показати всі монтування системи у таких стовпцях: `[root]# cmount`

який повертатиме нашу змонтовану файлову систему в такому форматі:

```bash
/dev/simfs  on  /                                          type  simfs        (rw,relatime,usrquota,grpquota)
proc        on  /proc                                      type  proc         (rw,relatime)
sysfs       on  /sys                                       type  sysfs        (rw,relatime)
none        on  /dev                                       type  devtmpfs     (rw,relatime,mode=755)
none        on  /dev/pts                                   type  devpts       (rw,relatime,mode=600,ptmxmode=000)
none        on  /dev/shm                                   type  tmpfs        (rw,relatime)
none        on  /proc/sys/fs/binfmt_misc                   type  binfmt_misc  (rw,relatime)
```

### Символ `;`

Символ `;` містить рядки команд.

Усі команди запускатимуться послідовно в порядку введення, коли користувач натисне <kbd>ENTER</kdb>.</p> 

<pre><code class="bash">$ ls /; cd /home; ls -lia; cd /
</code></pre>

<h2 spaces-before="0">
  Перевірте свої знання
</h2>

<p spaces-before="0">
  :heavy_check_mark: Що визначає користувача під Linux? (7 відповідей)
</p>

<p spaces-before="0">
  :heavy_check_mark: Що характеризує довгий параметр для команди?
</p>

<p spaces-before="0">
  :heavy_check_mark: Які команди дозволяють вам шукати за допомогою команди?
</p>

<ul>
  <li>
    [ ] <code>google</code>
  </li>
  <li>
    [ ] <code>chuck --norris</code>
  </li>
  <li>
    [ ] <code>info</code>
  </li>
  <li>
    [ ] <code>apropos</code>
  </li>
  <li>
    [ ] <code>whatis</code>
  </li>
</ul>

<p spaces-before="0">
  :heavy_check_mark: Яка команда дозволяє переглянути історію користувача?
</p>

<p spaces-before="0">
  :heavy_check_mark: Яка команда дозволяє шукати текст у файлі?
</p>

<ul>
  <li>
    [ ] <code>find</code>
  </li>
  <li>
    [ ] <code>grep</code>
  </li>
</ul>

<p spaces-before="0">
  :heavy_check_mark: Яка команда дозволяє вам шукати файл?
</p>

<ul>
  <li>
    [ ] <code>find</code>
  </li>
  <li>
    [ ] <code>grep</code>
  </li>
</ul>

<p spaces-before="0">
  :heavy_check_mark: Яка команда перенаправляє потік помилки на файл <code>errors.log</code>?
</p>

<ul>
  <li>
    [ ] <code>ls -R / 2&gt; errors.log</code>
  </li>
  <li>
    [ ] <code>ls -R / 2&gt;&gt; errors.log</code>
  </li>
  <li>
    [ ] <code>ls -R / 2&gt; errors.log 2&gt;&1</code>
  </li>
</ul>   
