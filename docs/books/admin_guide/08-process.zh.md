---
title: 进程管理
---

# 进程管理

在本章中，您将学习如何使用进程。

****

**目标**：在本章中，未来的 Linux 管理员将学习如何：

:heavy_check_mark: 识别进程的 `PID` 和 `PPID`；   
:heavy_check_mark: 查看并搜索进程；   
:heavy_check_mark: 管理进程。

:checkered_flag: **进程**，**linux**

**知识性**: :star: :star:   
**复杂度**: :star:

**阅读时间**: 20 分钟

****

## 概述

操作系统由进程组成。 这些进程以特定的顺序执行并且彼此相关。 有两大类的进程，一类侧重于用户环境，另一类侧重于硬件环境。

当程序运行时，系统将程序数据和代码放入到内存中并创建 **运行栈** 来创建进程。 因此，进程是程序的一个实例，它具有相关联的处理器环境（顺序计数器、寄存器等）和内存环境。

每个进程都有：

* _PID_：_**P**rocess **ID**entifier_，唯一的进程标识符
* _PPID_：_**P**arent **P**rocess **ID**entifier_，父进程的唯一标识符

通过连续的隶属关系，`init` 进程是所有进程之父。

* 一个进程始终由父进程创建
* 一个父进程可以有多个子进程

进程之间存在父/子关系。 子进程是父进程调用 _fork()_ 原语并复制自己的代码来创建子进程的结果。 子进程的 _PID_ 会返回给父进程，以便父进程与之对话。 每个子进程都有父进程的标识符 _PPID_ 。

_PID_ 数字代表执行时的进程。 当进程结束时，该数字可再次用于另一个进程。 多次运行同一命令将每次产生不同的 _PID_。<!-- TODO !\[Parent/child relationship between processes\](images/FON-050-001.png) -->!!! note "说明"

    请不要将进程与 _线程_ 混淆。 每个进程都有自己的内存上下文（资源和地址空间），而来自同一进程的 _线程_ 共享相同的上下文。

## 查看进程

`ps` 命令显示正在运行的进程的状态。
```
ps [-e] [-f] [-u login]
```

示例：
```
# ps -fu root
```

| 选项         | 说明       |
| ---------- | -------- |
| `-e`       | 显示所有进程。  |
| `-f`       | 显示附加信息。  |
| `-u` login | 显示用户的进程。 |

一些附加选项：

| 选项                    | 说明            |
| --------------------- | ------------- |
| `-g`                  | 显示组中的进程。      |
| `-t tty`              | 显示从终端运行的进程。   |
| `-p PID`              | 显示进程信息。       |
| `-H`                  | 以树结构显示信息。     |
| `-I`                  | 显示附加信息。       |
| `--sort COL`          | 根据列对结果进行排序。   |
| `--headers`           | 在终端的每一页上显示标题。 |
| `--format "%a %b %c"` | 自定义输出显示格式。    |

如果没有指定选项，`ps` 命令仅显示从当前终端运行的进程。

结果以列形式显示：

```
# ps -ef
UID  PID PPID C STIME  TTY TIME      CMD
root 1   0    0 Jan01  ?   00:00/03  /sbin/init
```

| 列       | 说明       |
| ------- | -------- |
| `UID`   | 所有者用户。   |
| `PID`   | 进程标识符。   |
| `PPID`  | 父进程标识符。  |
| `C`     | 进程的优先级。  |
| `STIME` | 执行日期和时间。 |
| `TTY`   | 执行终端。    |
| `TIME`  | 处理时间。    |
| `CMD`   | 已执行命令。   |

该控件的行为可以完全自定义：

```
# ps -e --format "%P %p %c %n" --sort ppid --headers
 PPID   PID COMMAND          NI
    0     1 systemd           0
    0     2 kthreadd          0
    1   516 systemd-journal   0
    1   538 systemd-udevd     0
    1   598 lvmetad           0
    1   643 auditd           -4
    1   668 rtkit-daemon      1
    1   670 sssd              0
```

## 进程类型

用户进程：

* 从与用户相关联的终端启动
* 通过请求或守护进程访问资源

系统进程（_守护进程_）：

* 由系统启动
* 不与任何终端关联，并且由系统用户所有（通常为 `root` ）
* 在启动时加载并驻留在内存中，正在等待调用
* 通常用与进程名相关的字母 `d` 来标识

因此，系统进程被称为守护进程（(_**D**isk **A**nd **E**xecution **MON**itor_）

## 权限

执行命令时，用户的凭据将传递给创建的进程。

因此，在默认情况下，进程的实际 `UID<code> 和 <code>GID` 与 执行命令的用户的 `UID` 和 `GID` 相同。

在命令上设置 `SUID`（和/或 `SGID`）后，实际 `UID`（和/或 `GID`）将变为命令所有者（和/或所属组）的 UID（和/或 GID），而不再是发出命令的用户或用户组的 UID（和/或 GID）。 因此，有效的 **UID** 和真实的 **UID** 是不同的。

每次访问文件时，系统都会根据其有效标识符检查进程的权限。

## 进程管理

一个进程不能无限期运行，因为这会损害其他正在运行的进程，并会妨碍多任务处理。

因此，可用的总处理时间被划分为几个小范围，每个进程（具有优先级）都以顺序的方式访问处理器。 进程在其生命周期中将经历几个状态：

* 就绪：等待进程可用
* 执行中：访问处理器
* 挂起：等待 I/O（输入/输出）
* 停止：等待来自另一个进程的信号
* 僵尸：请求销毁
* 死亡：父进程结束子进程

进程结束排序如下：

1. 关闭打开的文件
2. 释放使用过的内存
3. 向父进程和子进程发送信号

当父进程死亡时，其子进程被称为孤儿进程。 然后它们被 `init` 进程收养并销毁它们。

### 进程的优先级

处理器以分时方式工作，每个进程需要占用一些处理器时间。

进程按优先级进行分类，其值从 **-20**（最高优先级）到 **+19**（最低优先级）不等。

进程的默认优先级是 **0**。

### 运作方式

进程可以通过两种方式运行：

* **同步**：在执行命令过程中，用户将失去对 shell 的访问权限。 进程执行结束后，命令提示符会重新出现。
* **异步**：进程在后台进行处理。 命令提示符会立即再次显示。

异步方式的约束：

* 命令或脚本不能等待键盘输入
* 命令或脚本不得在屏幕上返回任何结果
* 退出 shell 将结束进程

## 进程管理控制

### `kill` 命令

`kill` 命令向进程发送停止信号。

```
kill [-signal] PID
```

示例：

```
$ kill -9 1664
```

| 代码   | 信号        | 说明                                   |
| ---- | --------- | ------------------------------------ |
| `2`  | _SIGINT_  | 立即终止进程                               |
| `9`  | _SIGKILL_ | 中断进程（<kbd>CTRL</kbd> + <kbd>D</kbd>） |
| `15` | _SIGTERM_ | 优雅地终止进程                              |
| `18` | _SIGCONT_ | 恢复进程                                 |
| `19` | _SIGSTOP_ | 挂起进程                                 |

信号是进程之间的通信手段。 `kill`命令的作用就是向进程发送信号。

!!! Tip "提示"

    `kill` 命令所考虑到的完整信号列表可通过键入以下命令获得：

    ```
    $ man 7 signal
    ```

### `nohup` 命令

`nohup` 允许独立于连接之外启动进程。

```
nohup command
```

示例：

```
$ nohup myprogram.sh 0</dev/null &
```

`nohup` 命令会忽略用户注销时发送的 `SIGHUP` 信号。

!!! Note "说明"

    `nohup` 能处理标准输出和错误，但不处理标准输入，因此会将输入重定向到 `/dev/null`。

### [CTRL] + [Z]

通过同时按下 <kbd>CTRL</kbd> + <kbd>Z</kbd> 键，同步进程将暂时暂停。 在显示刚刚被暂停进程的编号后，将恢复对提示符的访问。

### `&` 指令

`&` 语句异步执行命令（该命令被称为 _作业_）并显示 _作业_ 编号。 然后返回对提示符的访问权限。

示例：

```
$ time ls -lR / > list.ls 2> /dev/null &
[1] 15430
$
```

_作业_ 编号是在后台处理过程中获得的，显示在方括号中，后面跟着 `PID` 编号。

### `fg` 和 `bg` 命令

`fg` 命令将进程置于前台：

```
$ time ls -lR / > list.ls 2>/dev/null &
$ fg 1
time ls -lR / > list.ls 2/dev/null
```

而命令 `bg` 将其置于后台：

```
[CTRL]+[Z]
^Z
[1]+ Stopped
$ bg 1
[1] 15430
$
```

无论是在使用 `&` 参数创建进程时将其置于后台，还是随后使用 <kbd>CTRL</kbd> + <kbd>Z</kbd> 键将其置于后台，都可以使用 `fg` 命令及其作业编号将进程带回前台。

### `jobs` 命令

`job` 命令显示后台运行的进程列表，并指定它们的作业编号。

示例：

```
$ jobs
[1]- Running    sleep 1000
[2]+ Running    find / > arbo.txt
```

这些列表示：

1. 作业编号
2. 进程运行的顺序
- `+`：未指定作业编号时，`fg` 和 `bg` 命令默认选择的进程
- `-`：下一个进程选择 `+`
3.  _正在运行_（正在运行的进程）或_已停止_（已挂起的进程）
4. 命令

### `nice` 和 `renice` 命令

命令 `nice` 允许通过指定优先级来执行命令。

```
nice priority command
```

示例：

```
$ nice -n+15 find / -name "file"
```

与 `root` 不同，标准的普通用户只能降低进程的优先级。 只接受 +0 到 +19 之间的值。

!!! Tip "提示"

    通过修改 `/etc/security/limits.conf` 文件，可以按用户或组取消最后一项限制。

使用 `renice` 命令可以更改正在运行中的进程优先级。

```
renice priority [-g GID] [-p PID] [-u UID]
```

示例：

```
$ renice +15 -p 1664
```
| 选项   | 说明            |
| ---- | ------------- |
| `-g` | 进程所属组的 `GID`。 |
| `-p` | 进程的 `PID`。    |
| `-u` | 进程所有者的 `UID`。 |

`renice` 命令作用于已经运行的进程。 因此，我们可以改变特定进程的优先级，也可以改变属于用户或组的几个进程的优先级。

!!! Tip "提示"

    `pidof` 命令与 `xargs` 命令相结合（请参阅 "高级命令" 课程），可允许在单个命令中应用新的优先级：

    ```
    $ pidof sleep | xargs renice 20
    ```

### `top` 命令

`top` 命令用于显示进程及其资源消耗。

```
$ top
PID  USER PR NI ... %CPU %MEM  TIME+    COMMAND
2514 root 20 0       15    5.5 0:01.14   top
```

| 列         | 说明       |
| --------- | -------- |
| `PID`     | 进程标识符。   |
| `USER`    | 所有者用户。   |
| `PR`      | 进程优先级。   |
| `NI`      | Nice 值。  |
| `%CPU`    | 处理器负载。   |
| `%MEM`    | 内存负载。    |
| `TIME+`   | 处理器使用时间。 |
| `COMMAND` | 已执行命令。   |

`top` 命令允许实时和以交互模式控制进程。

### `pgrep` 和 `pkill` 命令

`pgrep` 命令可在运行的进程中搜索进程名，并在标准输出中显示与选择条件匹配的 _PID_。

`pkill` 命令将向每个进程发送指定的信号（默认情况下为 _SIGTERM_）。

```
pgrep process
pkill [-signal] process
```

示例：

* 从 `sshd` 中获取进程编号：

```
$ pgrep -u root sshd
```

* 结束所有 `tomcat` 进程：

```
$ pkill tomcat
```
