---
title: Резервне копіювання і відновлення
---

# Резервне копіювання і відновлення

У цьому розділі ви дізнаєтесь, як створювати резервні копії та відновлювати дані за допомогою Linux.

****

**Цілі**: у цьому розділі майбутні адміністратори Linux дізнаються, як:

:heavy_check_mark: використовувати команди `tar` і `cpio`, для створення резервної копії;   
:heavy_check_mark: перевіряти резервні копії та відновлювати дані;   
:heavy_check_mark: архівувати або розпакувати резервні копії.

:checkered_flag: **резервне копіювання**, **відновлення**, **стиснення**

**Знання**: :star: :star: :star:   
**Складність**: :star: :star:

**Час для читання**: 40 хвилин

****

!!! Примітка

    У цій главі командні структури використовують «пристрій» для визначення як цільового розташування для резервного копіювання, так і вихідного розташування під час відновлення. Пристроєм може бути як зовнішній носій, так і локальний файл. Ви повинні відчути це, коли розгортається розділ, але ви завжди можете повернутися до цієї примітки для роз’яснення, якщо вам потрібно.

Резервне копіювання задовольнить необхідність збереження та відновлення даних надійним і ефективним способом.

Резервне копіювання дозволяє захистити себе від наступного:

* **Знищення**: добровільне чи мимовільне. Людські або технічні. Вірус, ...
* **Видалення**: добровільне чи мимовільне. Людські або технічні. Вірус, ...
* **Цілісність**: дані стають непридатними для використання.

Жодна система не є безпомилковою, жодна людина не є безпомилковою, тому, щоб уникнути втрати даних, необхідно створити їх резервну копію, щоб мати можливість їх відновити.

Носій резервного копіювання слід зберігати в іншій кімнаті (або будівлі), ніж сервер, щоб катастрофа не знищила сервер і резервні копії.

Крім того, адміністратор повинен регулярно перевіряти, чи не пошкоджені носії резервних копій.

## Загальні положення

Існує два принципи: **резервне копіювання** та **архівування**.

* Архів після операції знищує джерело інформації.
* Резервна копія зберігає джерело інформації після операції.

Ці операції складаються зі збереження інформації у файлі, на периферійному чи підтримуваному носії (стрічках, дисках тощо).

### Процес

Резервне копіювання вимагає від системного адміністратора великої дисциплінованості та ретельності. Необхідно поставити наступні питання:

* Яке середовище є відповідним?
* Для чого слід створити резервну копію?
* Скільки примірників?
* Скільки часу триватиме резервне копіювання?
* Метод?
* Як часто?
* Автоматичне чи ручне?
* Де його зберігати?
* Як довго він буде зберігатися?

### Методи резервного копіювання

* **Повний**: створено резервну копію однієї або кількох **файлових систем** (ядро, дані, утиліти, ...).
* **Частковий**: створюється резервна копія одного або кількох **файлів** (конфігурацій, каталогів тощо).
* **Диференційний**: створюються резервні копії лише файлів, змінених після останнього **повного** резервного копіювання.
* **Інкрементний**: створюється резервна копія лише файлів, змінених після останнього резервного копіювання.

### Періодичність

* **Попередньо**: у певний час (до оновлення системи, ...).
* **Періодичність**: щоденно, щотижня, щомісяця, ...

!!! Порада

    Перед зміною системи може бути корисно зробити резервну копію. Однак немає сенсу щодня створювати резервні копії даних, які змінюються лише щомісяця.

### Методи відновлення

Залежно від доступних утиліт, можна буде виконати кілька типів відновлення.

* **Повне відновлення**: дерева, ...
* **Вибіркове відновлення**: частина дерева, файли, ...

Можна відновити всю резервну копію, але також можна відновити лише її частину. Однак під час відновлення каталогу файли, створені після резервного копіювання, не видаляються.

!!! Порада

    Щоб відновити каталог, яким він був на момент створення резервної копії, необхідно повністю видалити його вміст перед початком відновлення.

### Інструменти

Існує багато утиліт для створення резервних копій.

* **інструменти редактора**;
* **графічні інструменти**;
* **інструменти командного рядка**: `tar`, `cpio`, `pax`, `dd`, `dump`, ...

Команди, які ми тут використаємо, це `tar` і `cpio`.

* `tar`:
  * проста у використанні;
  * дозволяє додавати файли до існуючої резервної копії.
* `cpio`:
  * зберігає власників;
  * зберігає групи, дати та права;
  * пропускає пошкоджені файли;
  * повну файлову систему.

!!! Примітка

    Ці команди зберігають у власному стандартизованому форматі.

### Правила іменування

Використання угоди про найменування дає змогу швидко визначити вміст файлу резервної копії та таким чином уникнути небезпечне відновлення.

* назва довідника;
* використана утиліта;
* використовувані опції;
* дата.

!!! Порада

    Ім’я резервної копії має бути чітким.

!!! Важливо

    Поняття розширення в Linux не існує. Іншими словами, ми використовуємо розширення тут для людини-оператора. Якщо системний адміністратор бачить, наприклад, розширення файлу `.tar.gz` або `.tgz`, то він знає, як поводитися з файлом.

### Вміст резервної копії

Резервна копія зазвичай містить такі елементи:

* файл;
* ім'я;
* власник;
* розмір;
* дозволи;
* дата доступу.

!!! Важливо

    Номер `inode` відсутній.

### Режими зберігання

Існує два різних режими зберігання:

* файл на диску;
* пристрій.

## Tape ArchiveR - `tar`

Команда `tar` дозволяє зберігати на кількох послідовних носіях (багатотомні параметри).

Є можливість розпакувати всю або частину резервної копії.

`tar` неявно виконує резервне копіювання у відносному режимі, навіть якщо шлях до інформації для резервного копіювання вказано в абсолютному режимі. Проте резервне копіювання та відновлення в абсолютному режимі можливі.

### Інструкції з відновлення

Правильними запитаннями є:

* що: часткове чи повне;
* де: місце відновлення даних;
* як: абсолютна чи відносна.

!!! Увага

    Перед відновленням важливо подумати та визначити найбільш відповідний метод, щоб уникнути помилок.

Відновлення зазвичай виконуються після того, як виникла проблема, яку необхідно швидко вирішити. Неякісна реставрація може в деяких випадках погіршити ситуацію.

### Резервне копіювання за допомогою `tar`

Стандартною утилітою для створення резервних копій у системах UNIX є команда `tar`. Ці резервні копії можна стискати за допомогою `bzip2`, `xz`, `lzip`, `lzma`, `lzop`, `gzip`, `compress` або `zstd`.

`tar` дозволяє видобувати один файл або каталог із резервної копії, переглядати його вміст або перевіряти його цілісність.

#### Оцінка розміру резервної копії

Наступна команда оцінює розмір можливого файлу _tar_ у кілобайтах:

```
$ tar cf - /directory/to/backup/ | wc -c
20480
$ tar czf - /directory/to/backup/ | wc -c
508
$ tar cjf - /directory/to/backup/ | wc -c
428
```

!!! Увага

    Обережно, наявність «-» у командному рядку заважає `zsh`. Переключіться на `bash`!

#### Правила іменування резервної копії `tar`

Ось приклад іменування резервної копії `tar`, знаючи, що до назви потрібно додати дату.

| опції   | Файли   | Суфікс           | Функціональність                               |
| ------- | ------- | ---------------- | ---------------------------------------------- |
| `cvf`   | `home`  | `home.tar`       | `/home` у відносному режимі, нестиснена форма  |
| `cvfP`  | `/etc`  | `etc.A.tar`      | `/etc` в абсолютному режимі, без стиснення     |
| `cvfz`  | `usr`   | `usr.tar.gz`     | `/usr` у відносному режимі, стиснення _gzip_   |
| `cvfj`  | `usr`   | `usr.tar.bz2`    | `/usr` у відносному режимі, стиснення _bzip2_  |
| `cvfPz` | `/home` | `home.A.tar.gz`  | `home` в абсолютному режимі, стиснення _gzip_  |
| `cvfPj` | `/home` | `home.A.tar.bz2` | `home` в абсолютному режимі, стиснення _bzip2_ |
| …       |         |                  |                                                |

#### Створення резервної копії

##### Створення резервної копії у відносному режимі

Створення нестиснутої резервної копії у відносному режимі виконується за допомогою параметра `cvf`:

```
tar c[vf] [device] [file(s)]
```

Приклад:

```
[root]# tar cvf /backups/home.133.tar /home/
```


| Параметр | Опис                                            |
| -------- | ----------------------------------------------- |
| `c`      | Створює резервну копію.                         |
| `v`      | Відображає назву оброблених файлів.             |
| `f`      | Дозволяє вказати назву резервної копії (носій). |

!!! Порада

    Дефіс (`-`) перед клавішами `tar` не потрібен!

##### Створення резервної копії в абсолютному режимі

Створення нестиснутої резервної копії в абсолютному режимі виконується за допомогою опції `cvfP`:

```
$ tar c[vf]P [device] [file(s)]
```

Приклад:

```
[root]# tar cvfP /backups/home.133.P.tar /home/
```

| Параметр | Опис                                            |
| -------- | ----------------------------------------------- |
| `P`      | Створення резервної копії в абсолютному режимі. |


!!! Увага

    За допомогою клавіші `P` шлях до файлів для резервного копіювання має бути введений як **абсолютний**. Якщо дві умови (ключ `P` і шлях **абсолютний**) не вказано, резервне копіювання виконується у відносному режимі.

##### Створення стисненої резервної копії за допомогою `gzip`

Створення стисненої резервної копії за допомогою `gzip` виконується за допомогою опції `cvfz`:

```
$ tar cvzf backup.tar.gz dirname/
```

| Параметр | Опис                                |
| -------- | ----------------------------------- |
| `z`      | Стискання резервної копії в _gzip_. |


!!! Примітка

    Розширення `.tgz` є еквівалентним розширенням `.tar.gz`.

!!! Примітка

    Збереження опцій `cvf` (`tvf` або `xvf`) незмінними для всіх операцій резервного копіювання та просте додавання опції стиснення в кінці робить команду легшою для розуміння (наприклад, `cvfz` або `cvfj` тощо).

##### Створення стисненої резервної копії за допомогою `bzip`

Створення стисненої резервної копії за допомогою `bzip` виконується за допомогою опції `cvfj`:

```
$ tar cvfj backup.tar.bz2 dirname/
```

| Параметр | Опис                              |
| -------- | --------------------------------- |
| `j`      | Стискає резервну копію в _bzip2_. |

!!! Примітка

    Розширення `.tbz` і `.tb2` еквівалентні розширенням `.tar.bz2`.

##### Стиснення `compress`, `gzip`, `bzip2`, `lzip` і `xz`

Стиснення та, як наслідок, декомпресія впливатимуть на споживання ресурсів (час і використання ЦП).

Ось рейтинг стиснення набору текстових файлів від найменшого до найефективнішого:

- compress (`.tar.Z`)
- gzip (`.tar.gz`)
- bzip2 (`.tar.bz2`)
- lzip (`.tar.lz`)
- xz (`.tar.xz`)

#### Додавання файлу або каталогу до наявної резервної копії

До існуючої резервної копії можна додати один або кілька елементів.

```
tar {r|A}[key(s)] [device] [file(s)]
```

Щоб додати `/etc/passwd` до резервної копії `/backups/home.133.tar`:

```
[root]# tar rvf /backups/home.133.tar /etc/passwd
```

Додавання каталогу аналогічно. Тут додайте `dirtoadd` до `backup_name.tar`:

```
$ tar rvf backup_name.tar dirtoadd
```

| Параметр | Опис                                                                                                      |
| -------- | --------------------------------------------------------------------------------------------------------- |
| `r`      | Додає один або кілька файлів наприкінці резервної копії носія з прямим доступом (жорсткий диск).          |
| `A`      | Додає один або кілька файлів наприкінці резервного копіювання на носій із послідовним доступом (стрічка). |

!!! Важливо

    Неможливо додати файли або папки до стиснутої резервної копії.

    ```
    $ tar rvfz backup.tgz filetoadd
    tar: Cannot update compressed archives
    Try `tar --help' or `tar --usage' for more information.
    ```

!!! Важливо

    Якщо резервне копіювання було виконано у відносному режимі, додайте файли у відносному режимі. Якщо резервне копіювання було зроблено в абсолютному режимі, додайте файли в абсолютному режимі.
    
    Змішування режимів може викликати проблеми при відновленні.

#### Перелік вмісту резервної копії

Перегляд вмісту резервної копії без її вилучення можливий.

```
tar t[key(s)] [device]
```

| Параметр | Опис                                                |
| -------- | --------------------------------------------------- |
| `t`      | Відображає вміст резервної копії (стисненої чи ні). |

Приклади:

```
$ tar tvf backup.tar
$ tar tvfz backup.tar.gz
$ tar tvfj backup.tar.bz2
```

Коли кількість файлів у резервній копії стає великою, можна _передати_ результат команди `tar` на _pager_ (` більше`, `менше`, `більшість` тощо):

```
$ tar tvf backup.tar | less
```

!!! Порада

    Щоб отримати список або отримати вміст резервної копії, немає необхідності згадувати алгоритм стиснення, який використовувався під час створення резервної копії. Тобто `tar tvf` еквівалентний `tar tvfj` для читання вмісту, а `tar xvf` еквівалентний `tar xvfj` для вилучення.

!!! Порада

    Завжди перевіряйте вміст резервної копії.

#### Перевірка цілісності резервної копії

Цілісність резервної копії можна перевірити за допомогою опції `W` під час її створення:

```
$ tar cvfW file_name.tar dir/
```

Цілісність резервної копії можна перевірити за допомогою опції `d` після її створення:

```
$ tar vfd file_name.tar dir/
```

!!! Порада

    Додавши другий `v` до попереднього ключа, ви отримаєте список заархівованих файлів, а також відмінності між заархівованими файлами та файлами, присутніми у файловій системі.

    ```
    $ tar vvfd  /tmp/quodlibet.tar .quodlibet/
    drwxr-x--- rockstar/rockstar     0 2021-05-21 00:11 .quodlibet/
    -rw-r--r-- rockstar/rockstar     0 2021-05-19 00:59 .quodlibet/queue
    […]
    -rw------- rockstar/rockstar  3323 2021-05-21 00:11 .quodlibet/config
    .quodlibet/config: Mod time differs
    .quodlibet/config: Size differs
    […]
    ```

Опція `W` також використовується для порівняння вмісту архіву з файловою системою:

```
$ tar tvfW file_name.tar
Verify 1/file1
1/file1: Mod time differs
1/file1: Size differs
Verify 1/file2
Verify 1/file3
```

Перевірку за допомогою опції `W` неможливо виконати зі стисненим архівом. Потрібно використовувати опцію `d`:

```
$ tar dfz file_name.tgz
$ tar dfj file_name.tar.bz2
```

#### Розпакування (_untar_) резервної копії

Розпакування (_untar_) резервної копії `*.tar` виконується за допомогою опції `xvf`:

Розпакування файлу `etc/exports` із резервної копії `/savings/etc.133.tar` у каталог `etc` активного каталогу:

```
$ tar xvf /backups/etc.133.tar etc/exports
```

Розпакування всіх файлів зі стисненої резервної копії `/backups/home.133.tar.bz2` в активний каталог:

```
[root]# tar xvfj /backups/home.133.tar.bz2
```

Розпакування усіх файлів з резервної копії `/backups/etc.133.P.tar` до оригінального каталогу:

```
$ tar xvfP /backups/etc.133.P.tar
```

!!! Важливо

    Перейдіть в потрібне місце.
    
    Перевірте вміст резервної копії.

| Параметр | Опис                                             |
| -------- | ------------------------------------------------ |
| `x`      | Витягує файли з резервної копії, стиснуті чи ні. |


Видобування резервної копії _tar-gzip_ (`*.tar.gz`) виконується за допомогою опції `xvfz`:

```
$ tar xvfz backup.tar.gz
```

Видобування резервної копії _tar-bzip_ (`*.tar.bz2`) виконується за допомогою опції `xvfj`:

```
$ tar xvfj backup.tar.bz2
```

!!! Порада

    Щоб видобути або отримати список вмісту резервної копії, немає необхідності згадувати алгоритм стиснення, який використовується для створення резервної копії. Тобто `tar xvf` еквівалентний `tar xvfj`, щоб витягнути вміст, а `tar tvf` еквівалентний `tar tvfj`, щоб отримати список.

!!! Увага

    Щоб відновити файли у вихідному каталозі (опція `P` `tar xvf`), ви повинні створити резервну копію з абсолютним шляхом. Тобто за допомогою опцій `P` `tar cvf`.

##### Витягнути лише файл із резервної копії _tar_

Щоб отримати певний файл із резервної копії _tar_, укажіть назву цього файлу в кінці команди `tar xvf`.

```
$ tar xvf backup.tar /path/to/file
```

Попередня команда витягує лише файл `/path/to/file` із резервної копії `backup.tar`. Цей файл буде відновлено до каталогу `/path/to/`, створеного або вже наявного в активному каталозі.

```
$ tar xvfz backup.tar.gz /path/to/file
$ tar xvfj backup.tar.bz2 /path/to/file
```

##### Витягнути папку з резервної копії _tar_

Щоб отримати лише один каталог (включно з його підкаталогами та файлами) із резервної копії, вкажіть назву каталогу в кінці команди `tar xvf`.

```
$ tar xvf backup.tar /path/to/dir/
```

Щоб отримати кілька каталогів, вкажіть кожне з імен одне за одним:

```
$ tar xvf backup.tar /path/to/dir1/ /path/to/dir2/
$ tar xvfz backup.tar.gz /path/to/dir1/ /path/to/dir2/
$ tar xvfj backup.tar.bz2 /path/to/dir1/ /path/to/dir2/
```

##### Витягнути групу файлів із резервної копії _tar_ за допомогою регулярних виразів (_regex_)

Укажіть _regex_, щоб видобути файли, які відповідають вказаному шаблону вибору.

Наприклад, щоб видобути всі файли з розширенням `.conf`:

```
$ tar xvf backup.tar --wildcards '*.conf'
```

опції:

  * **--wildcards *.conf** відповідає файлам із розширенням `.conf`.

## _CoPy Input Output_ - `cpio`

Команда `cpio` дозволяє зберігати на кількох послідовних носіях, не вказуючи жодних параметрів.

Є можливість розпакувати всю або частину резервної копії.

Немає можливості, на відміну від команди `tar`, для резервного копіювання та стиснення одночасно. Отже, це робиться в два етапи: резервне копіювання та стиснення.

Щоб виконати резервне копіювання за допомогою `cpio`, вам потрібно вказати список файлів для резервного копіювання.

Цей список надається за допомогою команд `find`, `ls` або `cat`.

* `find` : переглянути дерево, рекурсивне чи ні;
* `ls` : перелічує каталог, рекурсивний чи ні;
* `cat` : читає файл, що містить дерева або файли, які потрібно зберегти.

!!! Примітка

    `ls` не можна використовувати з `-l` (подробиці) або `-R` (рекурсивний).
    
    Для цього потрібен простий список імен.

### Створення резервної копії за допомогою команди `cpio`

Синтаксис команди `cpio`:

```
[files command |] cpio {-o| --create} [-options] [<file-list] [>device]
```

Приклад:

З перенаправленням виводу `cpio`:

```
$ find /etc | cpio -ov > /backups/etc.cpio
```

Використання назви резервного носія:

```
$ find /etc | cpio -ovF /backups/etc.cpio
```

Результат виконання команди `find` надсилається як вхідні дані для команди `cpio` через _pipe_ (символ `|`, <kbd>AltGr</kbd> + <kbd>6</kbd>).

Тут команда `find /etc` повертає команді `cpio` список файлів, що відповідають вмісту каталогу `/etc` (рекурсивно), який виконує резервне копіювання.

Не забудьте про знак `>` під час збереження або `F save_name_cpio`.

| Опції | Опис                                                     |
| ----- | -------------------------------------------------------- |
| `-o`  | Створює резервну копію (_output_).                       |
| `-v`  | Відображає назву оброблених файлів.                      |
| `-F`  | Позначає резервну копію, яку потрібно змінити (середня). |

Резервне копіювання на носій:

```
$ find /etc | cpio -ov > /dev/rmt0
```

Призначенням може бути наступне:

* стрічковий накопичувач: `/dev/rmt0`;
* розділ: `/dev/sda5`, `/dev/hda5` тощо.

### Тип резервного копіювання

#### Резервне копіювання з відносним шляхом

```
$ cd /
$ find etc | cpio -o > /backups/etc.cpio
```

#### Резервне копіювання з абсолютним шляхом

```
$ find /etc | cpio -o > /backups/etc.A.cpio
```

!!! Важливо

    Якщо шлях, указаний у команді `find`, є **абсолютним**, тоді резервне копіювання буде виконано в **абсолютному**.
    
    Якщо шлях, указаний у команді `find`, є **відносним**, тоді резервне копіювання буде виконано у **відносному**.

### Додати до резервної копії

```
[files command |] cpio {-o| --create} -A [-options] [<fic-list] {F|>device}
```

Приклад:

```
$ find /etc/shadow | cpio -o -AF SystemFiles.A.cpio
```

Додавання файлів можливе лише на носії прямого доступу.

| Опція | Опис                                                      |
| ----- | --------------------------------------------------------- |
| `-A`  | Додає один або кілька файлів до резервної копії на диску. |
| `-F`  | Визначає резервну копію, яку потрібно змінити.            |

### Стиснення резервної копії

* Збережіть **потім** стисніть

```
$ find /etc | cpio  –o > etc.A.cpio
$ gzip /backups/etc.A.cpio
$ ls /backups/etc.A.cpio*
/backups/etc.A.cpio.gz
```

* Зберегти **та** стиснути

```
$ find /etc | cpio –o | gzip > /backups/etc.A.cpio.gz
```

На відміну від команди `tar`, немає можливості зберігати та стискати одночасно. Отже, це робиться в два етапи: збереження та стиснення.

Синтаксис першого методу легше зрозуміти і запам'ятати, оскільки він складається з двох кроків.

Для першого методу файл резервної копії автоматично перейменовується утилітою `gzip`, яка додає `.gz` у кінець імені файлу. Так само утиліта `bzip2` автоматично додає `.bz2`.

### Прочитати вміст резервної копії

Синтаксис команди `cpio` для читання вмісту резервної копії _cpio_:

```
cpio -t [-options] [<fic-list]
```

Приклад:

```
$ cpio -tv </backups/etc.152.cpio | less
```

| Опції | Опис                       |
| ----- | -------------------------- |
| `-t`  | Читає резервну копію.      |
| `-v`  | Відображає атрибути файлу. |

Після створення резервної копії необхідно прочитати її вміст, щоб переконатися, що немає помилок.

Таким же чином, перед виконанням відновлення, ви повинні прочитати вміст резервної копії, яка буде використана.

### Відновлення резервної копії

Синтаксис команди `cpio` для відновлення резервної копії:

```
cpio {-i| --extract} [-E file] [-options] [<device]
```

Приклад:

```
$ cpio -iv </backups/etc.152.cpio | less
```

| Опції                        | Опис                                                                                  |
| ---------------------------- | ------------------------------------------------------------------------------------- |
| `-i`                         | Відновлює повну резервну копію.                                                       |
| `-E file`                    | Відновлює лише ті файли, ім'я яких міститься у файлі.                                 |
| `--make-directories` or `-d` | Відновлює відсутню структуру дерева.                                                  |
| `-u`                         | Замінює всі файли, навіть якщо вони існують.                                          |
| `--no-absolute-filenames`    | Дозволяє відновити резервну копію, зроблену в абсолютному режимі, у відносний спосіб. |

!!! Важливо

    За замовчуванням, під час відновлення, файли на диску, дата останньої зміни яких є новішою або дорівнює даті резервної копії, не відновлюються (щоб уникнути перезапису останньої інформації старішою).
    
    Параметр `u`, з іншого боку, дозволяє відновити старіші версії файлів.

Приклади:

* Повне відновлення абсолютної резервної копії

```
$ cpio –ivF home.A.cpio
```

* Абсолютне відновлення на існуючій структурі дерева

Параметр `u` дозволяє перезаписувати існуючі файли в тому місці, де відбувається відновлення.

```
$ cpio –iuvF home.A.cpio
```

* Відновлення абсолютної резервної копії у відносному режимі

Довгий параметр `no-absolute-filenames` дозволяє відновлення у відносному режимі. Насправді `/` на початку шляху буде видалено.

```
$ cpio --no-absolute-filenames -divuF home.A.cpio
```

!!! Порада

    Створення каталогів, можливо, необхідне, тому використовується опція `d`

* Відновлення відносної резервної копії

```
$ cpio –iv <etc.cpio
```

* Повне відновлення файлу або каталогу

Відновлення певного файлу або каталогу вимагає створення файлу списку, який потім потрібно видалити.

```
echo "/etc/passwd" > tmp
cpio –iuE tmp -F etc.A.cpio
rm -f tmp
```

## Утиліти компресії - декомпресії

Використання стиснення під час резервного копіювання може мати ряд недоліків:

* Подовжує час резервного копіювання, а також час відновлення.
* Це унеможливлює додавання файлів до резервної копії.

!!! Примітка

    Тому краще зробити резервну копію та стиснути її, ніж стискати під час резервного копіювання.

### Стиснення за допомогою `gzip`

Команда `gzip` стискає дані.

Синтаксис команди `gzip`:

```
gzip [options] [file ...]
```

Приклад:

```
$ gzip usr.tar
$ ls
usr.tar.gz
```

Файл отримує розширення `.gz`.

Він зберігає ті самі права та ті самі дати останнього доступу та змін.

### Стиснення за допомогою `bunzip2`

Команда `bunzip2` також стискає дані.

Синтаксис команди `bzip2`:

```
bzip2 [options] [file ...]
```

Приклад:

```
$ bzip2 usr.cpio
$ ls
usr.cpio.bz2
```

Ім’я файлу має розширення `.bz2`.

Стиснення за допомогою `bzip2` краще, ніж стиснення за допомогою `gzip`, але для його виконання потрібно більше часу.

### Декомпресія за допомогою `gunzip`

Команда `gunzip` розпаковує стислі дані.

Синтаксис команди `gunzip`:

```
gunzip [options] [file ...]
```

Приклад:

```
$ gunzip usr.tar.gz
$ ls
usr.tar
```

Ім’я файлу скорочується за допомогою `gunzip`, а розширення `.gz` видаляється.

`gunzip` також розпаковує файли з такими розширеннями:

* `.z` ;
* `-z` ;
* `_z` .

### Декомпресія за допомогою `bunzip2`

Команда `bunzip2` розпаковує стислі дані.

Синтаксис команди `bzip2`:

```
bzip2 [options] [file ...]
```

Приклад:

```
$ bunzip2 usr.cpio.bz2
$ ls
usr.cpio
```

Ім’я файлу скорочується на `bunzip2`, а розширення `.bz2` видаляється.

`bunzip2` також розпаковує файл із такими розширеннями:

* `-bz` ;
* `.tbz2` ;
* `tbz` .
