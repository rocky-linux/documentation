---
title: Резервне копіювання і відновлення
---

# Резервне копіювання і відновлення

У цьому розділі ви дізнаєтесь, як створювати резервні копії та відновлювати дані за допомогою Linux.

****

**Цілі**: у цьому розділі майбутні адміністратори Linux дізнаються, як:

:heavy_check_mark: використовувати команди `tar` і `cpio`, для створення резервної копії;  
:heavy_check_mark: перевіряти резервні копії та відновлювати дані;  
:heavy_check_mark: архівувати або розпакувати резервні копії.

:checkered_flag: **резервне копіювання**, **відновлення**, **стиснення**

**Знання**: :star: :star: :star:  
**Складність**: :star: :star:

**Час для читання**: 40 хвилин

****

!!! Примітка

    У цій главі командні структури використовують «пристрій» для визначення як цільового розташування для резервного копіювання, так і вихідного розташування під час відновлення. Пристроєм може бути як зовнішній носій, так і локальний файл. Ви повинні відчути це, коли розгортається розділ, але ви завжди можете повернутися до цієї примітки для роз’яснення, якщо вам потрібно.

Резервне копіювання задовольнить необхідність збереження та відновлення даних надійним і ефективним способом.

Резервне копіювання дозволяє захистити себе від наступного:

* **Знищення**: добровільне чи мимовільне. Людські або технічні. Вірус, ...
* **Видалення**: добровільне чи мимовільне. Людські або технічні. Вірус, ...
* **Цілісність**: дані стають непридатними для використання.

Жодна система не є безпомилковою, жодна людина не є безпомилковою, тому, щоб уникнути втрати даних, необхідно створити їх резервну копію, щоб мати можливість їх відновити.

Носій резервного копіювання слід зберігати в іншій кімнаті (або будівлі), ніж сервер, щоб катастрофа не знищила сервер і резервні копії.

Крім того, адміністратор повинен регулярно перевіряти, чи не пошкоджені носії резервних копій.

## Загальні положення

Існує два принципи: **резервне копіювання** та **архівування**.

* Архів після операції знищує джерело інформації.
* Резервна копія зберігає джерело інформації після операції.

Ці операції складаються зі збереження інформації у файлі, на периферійному чи підтримуваному носії (стрічках, дисках тощо).

### Процес

Резервне копіювання вимагає від системного адміністратора великої дисциплінованості та ретельності. Необхідно поставити наступні питання:

* Яке середовище є відповідним?
* Для чого слід створити резервну копію?
* Скільки примірників?
* Скільки часу триватиме резервне копіювання?
* Метод?
* Як часто?
* Автоматичне чи ручне?
* Де його зберігати?
* Як довго він буде зберігатися?

### Методи резервного копіювання

* **Повний**: створено резервну копію однієї або кількох **файлових систем** (ядро, дані, утиліти, ...).
* **Частковий**: створюється резервна копія одного або кількох **файлів** (конфігурацій, каталогів тощо).
* **Диференційний**: створюються резервні копії лише файлів, змінених після останнього **повного** резервного копіювання.
* **Інкрементний**: створюється резервна копія лише файлів, змінених після останнього резервного копіювання.

### Періодичність

* **Попередньо**: у певний час (до оновлення системи, ...).
* **Періодичність**: щоденно, щотижня, щомісяця, ...

!!! tip "Порада"

    Перед зміною системи може бути корисно зробити резервну копію. Однак немає сенсу щодня створювати резервні копії даних, які змінюються лише щомісяця.

### Методи відновлення

Залежно від доступних утиліт, можна буде виконати кілька типів відновлення.

* **Повне відновлення**: дерева, ...
* **Вибіркове відновлення**: частина дерева, файли, ...

Можна відновити всю резервну копію, але також можна відновити лише її частину. Однак під час відновлення каталогу файли, створені після резервного копіювання, не видаляються.

!!! tip "Порада"

    Щоб відновити каталог, яким він був на момент створення резервної копії, необхідно повністю видалити його вміст перед початком відновлення.

### Інструменти

Існує багато утиліт для створення резервних копій.

* **інструменти редактора**;
* **графічні інструменти**;
* **інструменти командного рядка**: `tar`, `cpio`, `pax`, `dd`, `dump`, ...

Команди, які ми тут використаємо, це `tar` і `cpio`.

* `tar`:

  1. простий у використанні;
  2. дозволяє додавати файли до існуючої резервної копії.

* `cpio`:

  1. зберігає власників;
  2. зберігає групи, дати та права;
  3. пропускає пошкоджені файли;
  4. вся файлова система.

!!! Note "Примітка"

    Ці команди зберігають у власному стандартизованому форматі.

### Правила іменування

Використання угоди про найменування дає змогу швидко визначити вміст файлу резервної копії та таким чином уникнути небезпечне відновлення.

* назва довідника;
* використана утиліта;
* використовувані опції;
* дата.

!!! tip "Порада"

    Ім’я резервної копії має бути чітким.

!!! Note "Примітка"

    Поняття розширення в Linux не існує. Іншими словами, ми використовуємо розширення тут для людини-оператора. Якщо системний адміністратор бачить, наприклад, розширення файлу `.tar.gz` або `.tgz`, то він знає, як поводитися з файлом.

### Вміст резервної копії

Резервна копія зазвичай містить такі елементи:

* файл;
* ім'я;
* власник;
* розмір;
* дозволи;
* дата доступу.

!!! Note "Примітка"

    Номер `inode` відсутній.

### Режими зберігання

Існує два різних режими зберігання:

* файл на диску;
* пристрій.

## Tape ArchiveR - `tar`

Команда `tar` дозволяє зберігати на кількох послідовних носіях (багатотомні параметри).

Є можливість розпакувати всю або частину резервної копії.

`tar` неявно виконує резервне копіювання у відносному режимі, навіть якщо шлях до інформації для резервного копіювання вказано в абсолютному режимі. Проте резервне копіювання та відновлення в абсолютному режимі можливі.

### Інструкції з відновлення

Правильними запитаннями є:

* що: часткове чи повне;
* де: місце відновлення даних;
* як: абсолютна чи відносна.

!!! Warning "Увага"

    Перед відновленням важливо подумати та визначити найбільш відповідний метод, щоб уникнути помилок.

Відновлення зазвичай виконуються після того, як виникла проблема, яку необхідно швидко вирішити. Неякісна реставрація може в деяких випадках погіршити ситуацію.

### Резервне копіювання за допомогою `tar`

Стандартною утилітою для створення резервних копій у системах UNIX є команда `tar`. Ці резервні копії можна стискати за допомогою `bzip2`, `xz`, `lzip`, `lzma`, `lzop`, `gzip`, `compress` або `zstd`.

`tar` дозволяє видобувати один файл або каталог із резервної копії, переглядати його вміст або перевіряти його цілісність.

#### Оцінка розміру резервної копії

Наступна команда оцінює розмір можливого файлу *tar* у кілобайтах:

```bash
$ tar cf - /directory/to/backup/ | wc -c
20480
$ tar czf - /directory/to/backup/ | wc -c
508
$ tar cjf - /directory/to/backup/ | wc -c
428
```

!!! Увага

    Обережно, наявність «-» у командному рядку заважає `zsh`. Переключіться на `bash`!

#### Правила іменування резервної копії `tar`

Ось приклад іменування резервної копії `tar`, знаючи, що до назви потрібно додати дату.

| опції   | Файли   | Суфікс           | Функціональність                               |
| ------- | ------- | ---------------- | ---------------------------------------------- |
| `cvf`   | `home`  | `home.tar`       | `/home` у відносному режимі, нестиснена форма  |
| `cvfP`  | `/etc`  | `etc.A.tar`      | `/etc` в абсолютному режимі, без стиснення     |
| `cvfz`  | `usr`   | `usr.tar.gz`     | `/usr` у відносному режимі, стиснення *gzip*   |
| `cvfj`  | `usr`   | `usr.tar.bz2`    | `/usr` у відносному режимі, стиснення *bzip2*  |
| `cvfPz` | `/home` | `home.A.tar.gz`  | `home` в абсолютному режимі, стиснення *gzip*  |
| `cvfPj` | `/home` | `home.A.tar.bz2` | `home` в абсолютному режимі, стиснення *bzip2* |
| …       |         |                  |                                                |

#### Створення резервної копії

##### Створення резервної копії у відносному режимі

Створення нестиснутої резервної копії у відносному режимі виконується за допомогою параметра `cvf`:

```bash
tar c[vf] [device] [file(s)]
```

Приклад:

```bash
[root]# tar cvf /backups/home.133.tar /home/
```

| Параметр | Опис                                            |
| -------- | ----------------------------------------------- |
| `c`      | Створює резервну копію.                         |
| `v`      | Відображає назву оброблених файлів.             |
| `f`      | Дозволяє вказати назву резервної копії (носій). |

!!! tip "Порада"

    Дефіс (`-`) перед клавішами `tar` не потрібен!

##### Створення резервної копії в абсолютному режимі

Створення нестиснутої резервної копії в абсолютному режимі виконується за допомогою опції `cvfP`:

```bash
tar c[vf]P [device] [file(s)]
```

Приклад:

```bash
[root]# tar cvfP /backups/home.133.P.tar /home/
```

| Параметр | Опис                                            |
| -------- | ----------------------------------------------- |
| `P`      | Створення резервної копії в абсолютному режимі. |

!!! Увага

    За допомогою клавіші `P` шлях до файлів для резервного копіювання має бути введений як **абсолютний**. Якщо дві умови (ключ `P` і шлях **абсолютний**) не вказано, резервне копіювання виконується у відносному режимі.

##### Створення стисненої резервної копії за допомогою `gzip`

Створення стисненої резервної копії за допомогою `gzip` виконується за допомогою опції `cvfz`:

```bash
tar cvzf backup.tar.gz dirname/
```

| Параметр | Опис                                |
| -------- | ----------------------------------- |
| `z`      | Стискання резервної копії в *gzip*. |

!!! Примітка

    Розширення `.tgz` є еквівалентним розширенням `.tar.gz`.

!!! Примітка

    Збереження опцій `cvf` (`tvf` або `xvf`) незмінними для всіх операцій резервного копіювання та просте додавання опції стиснення в кінці робить команду легшою для розуміння (наприклад, `cvfz` або `cvfj` тощо).

##### Створення стисненої резервної копії за допомогою `bzip`

Створення стисненої резервної копії за допомогою `bzip` виконується за допомогою опції `cvfj`:

```bash
tar cvfj backup.tar.bz2 dirname/
```

| Параметр | Опис                              |
| -------- | --------------------------------- |
| `j`      | Стискає резервну копію в *bzip2*. |

!!! Примітка

    Розширення `.tbz` і `.tb2` еквівалентні розширенням `.tar.bz2`.

##### Стиснення `compress`, `gzip`, `bzip2`, `lzip` і `xz`

Стиснення та, як наслідок, декомпресія впливатимуть на споживання ресурсів (час і використання ЦП).

Ось рейтинг стиснення набору текстових файлів від найменшого до найефективнішого:

* compress (`.tar.Z`)
* gzip (`.tar.gz`)
* bzip2 (`.tar.bz2`)
* lzip (`.tar.lz`)
* xz (`.tar.xz`)

#### Додавання файлу або каталогу до наявної резервної копії

До існуючої резервної копії можна додати один або кілька елементів.

```bash
tar {r|A}[key(s)] [device] [file(s)]
```

Щоб додати `/etc/passwd` до резервної копії `/backups/home.133.tar`:

```bash
[root]# tar rvf /backups/home.133.tar /etc/passwd
```

Додавання каталогу аналогічно. Тут додайте `dirtoadd` до `backup_name.tar`:

```bash
tar rvf backup_name.tar dirtoadd
```

| Параметр | Опис                                                                                                      |
| -------- | --------------------------------------------------------------------------------------------------------- |
| `r`      | Додає один або кілька файлів наприкінці резервної копії носія з прямим доступом (жорсткий диск).          |
| `A`      | Додає один або кілька файлів наприкінці резервного копіювання на носій із послідовним доступом (стрічка). |

!!! Note "Примітка"

    Неможливо додати файли або папки до стиснутої резервної копії.

    ```
    $ tar rvfz backup.tgz filetoadd
    tar: Cannot update compressed archives
    Try `tar --help' or `tar --usage' for more information.
    ```

!!! Note "Примітка"

    Якщо резервне копіювання було виконано у відносному режимі, додайте файли у відносному режимі. Якщо резервне копіювання було зроблено в абсолютному режимі, додайте файли в абсолютному режимі.
    
    Змішування режимів може викликати проблеми при відновленні.

#### Перелік вмісту резервної копії

Перегляд вмісту резервної копії без її вилучення можливий.

```bash
tar t[key(s)] [device]
```

| Параметр | Опис                                                |
| -------- | --------------------------------------------------- |
| `t`      | Відображає вміст резервної копії (стисненої чи ні). |

Приклади:

```bash
tar tvf backup.tar
tar tvfz backup.tar.gz
tar tvfj backup.tar.bz2
```

Коли кількість файлів у резервній копії стає великою, можна *передати* результат команди `tar` на *pager* (` більше`, `менше`, `більшість` тощо):

```bash
tar tvf backup.tar | less
```

!!! Tip "Підказка"

    Щоб отримати список або отримати вміст резервної копії, немає необхідності згадувати алгоритм стиснення, який використовувався під час створення резервної копії. Тобто `tar tvf` еквівалентний `tar tvfj` для читання вмісту, а `tar xvf` еквівалентний `tar xvfj` для вилучення.

!!! Tip "Підказка"

    Завжди перевіряйте вміст резервної копії.

#### Перевірка цілісності резервної копії

Цілісність резервної копії можна перевірити за допомогою опції `W` під час її створення:

```bash
tar cvfW file_name.tar dir/
```

Цілісність резервної копії можна перевірити за допомогою опції `d` після її створення:

```bash
tar vfd file_name.tar dir/
```

!!! tip "Порада"

    Додавши другий `v` до попереднього ключа, ви отримаєте список заархівованих файлів, а також відмінності між заархівованими файлами та файлами, присутніми у файловій системі.

    ```
    $ tar vvfd  /tmp/quodlibet.tar .quodlibet/
    drwxr-x--- rockstar/rockstar     0 2021-05-21 00:11 .quodlibet/
    -rw-r--r-- rockstar/rockstar     0 2021-05-19 00:59 .quodlibet/queue
    […]
    -rw------- rockstar/rockstar  3323 2021-05-21 00:11 .quodlibet/config
    .quodlibet/config: Mod time differs
    .quodlibet/config: Size differs
    […]
    ```

Опція `W` також використовується для порівняння вмісту архіву з файловою системою:

```bash
$ tar tvfW file_name.tar
Verify 1/file1
1/file1: Mod time differs
1/file1: Size differs
Verify 1/file2
Verify 1/file3
```

Перевірку за допомогою опції `W` неможливо виконати зі стисненим архівом. Потрібно використовувати опцію ++d++:

```bash
tar dfz file_name.tgz
tar dfj file_name.tar.bz2
```

#### Розпакування (*untar*) резервної копії

Розпакування (*untar*) резервної копії `*.tar` виконується за допомогою опції `xvf`:

Розпакування файлу `etc/exports` із резервної копії `/savings/etc.133.tar` у каталог `etc` активного каталогу:

```bash
tar xvf /backups/etc.133.tar etc/exports
```

Розпакування всіх файлів зі стисненої резервної копії `/backups/home.133.tar.bz2` в активний каталог:

```bash
[root]# tar xvfj /backups/home.133.tar.bz2
```

Розпакування усіх файлів з резервної копії `/backups/etc.133.P.tar` до оригінального каталогу:

```bash
tar xvfP /backups/etc.133.P.tar
```

!!! Warning "Увага"

    Перейдіть в потрібне місце.
    
    Перевірте вміст резервної копії.

| Параметр | Опис                                             |
| -------- | ------------------------------------------------ |
| `x`      | Витягує файли з резервної копії, стиснуті чи ні. |

Видобування резервної копії *tar-gzip* (`*.tar.gz`) виконується за допомогою опції `xvfz`:

```bash
tar xvfz backup.tar.gz
```

Видобування резервної копії *tar-bzip* (`*.tar.bz2`) виконується за допомогою опції `xvfj`:

```bash
tar xvfj backup.tar.bz2
```

!!! tip "Порада"

    Щоб видобути або отримати список вмісту резервної копії, немає необхідності згадувати алгоритм стиснення, який використовується для створення резервної копії. Тобто `tar xvf` еквівалентний `tar xvfj`, щоб витягнути вміст, а `tar tvf` еквівалентний `tar tvfj`, щоб отримати список.

!!! Увага

    Щоб відновити файли у вихідному каталозі (опція `P` `tar xvf`), ви повинні створити резервну копію з абсолютним шляхом. Тобто за допомогою опцій `P` `tar cvf`.

##### Витягнути лише файл із резервної копії *tar*

Щоб отримати певний файл із резервної копії *tar*, укажіть назву цього файлу в кінці команди `tar xvf`.

```bash
tar xvf backup.tar /path/to/file
```

Попередня команда витягує лише файл `/path/to/file` із резервної копії `backup.tar`. Цей файл буде відновлено до каталогу `/path/to/`, створеного або вже наявного в активному каталозі.

```bash
tar xvfz backup.tar.gz /path/to/file
tar xvfj backup.tar.bz2 /path/to/file
```

##### Витягнути папку з резервної копії *tar*

Щоб отримати лише один каталог (включно з його підкаталогами та файлами) із резервної копії, вкажіть назву каталогу в кінці команди `tar xvf`.

```bash
tar xvf backup.tar /path/to/dir/
```

Щоб отримати кілька каталогів, вкажіть кожне з імен одне за одним:

```bash
tar xvf backup.tar /path/to/dir1/ /path/to/dir2/
tar xvfz backup.tar.gz /path/to/dir1/ /path/to/dir2/
tar xvfj backup.tar.bz2 /path/to/dir1/ /path/to/dir2/
```

##### Витягнути групу файлів із резервної копії *tar* за допомогою регулярних виразів (*regex*)

Укажіть *regex*, щоб видобути файли, які відповідають вказаному шаблону вибору.

Наприклад, щоб видобути всі файли з розширенням `.conf`:

```bash
tar xvf backup.tar --wildcards '*.conf'
```

опції:

* **--wildcards *.conf** відповідає файлам із розширенням `.conf`.

## *CoPy Input Output* - `cpio`

Команда `cpio` дозволяє зберігати на кількох послідовних носіях, не вказуючи жодних параметрів.

Є можливість розпакувати всю або частину резервної копії.

Немає можливості, на відміну від команди `tar`, для резервного копіювання та стиснення одночасно. Отже, це робиться в два етапи: резервне копіювання та стиснення.

Щоб виконати резервне копіювання за допомогою `cpio`, вам потрібно вказати список файлів для резервного копіювання.

Цей список надається за допомогою команд `find`, `ls` або `cat`.

* `find` : переглянути дерево, рекурсивне чи ні;
* `ls` : перелічує каталог, рекурсивний чи ні;
* `cat` : читає файл, що містить дерева або файли, які потрібно зберегти.

!!! Примітка

    `ls` не можна використовувати з `-l` (подробиці) або `-R` (рекурсивний).
    
    Для цього потрібен простий список імен.

### Створення резервної копії за допомогою команди `cpio`

Синтаксис команди `cpio`:

```bash
[files command |] cpio {-o| --create} [-options] [<file-list] [>device]
```

Приклад:

З перенаправленням виводу `cpio`:

```bash
find /etc | cpio -ov > /backups/etc.cpio
```

Використання назви резервного носія:

```bash
find /etc | cpio -ovF /backups/etc.cpio
```

Результат виконання команди `find` надсилається як вхідні дані для команди `cpio` через *pipe* (символ `|`, ++alt-graph+6++).

Тут команда `find /etc` повертає команді `cpio` список файлів, що відповідають вмісту каталогу `/etc` (рекурсивно), який виконує резервне копіювання.

Не забудьте про знак `>` під час збереження або `F save_name_cpio`.

| Опції | Опис                                                     |
| ----- | -------------------------------------------------------- |
| `-o`  | Створює резервну копію (*output*).                       |
| `-v`  | Відображає назву оброблених файлів.                      |
| `-F`  | Позначає резервну копію, яку потрібно змінити (середня). |

Резервне копіювання на носій:

```bash
find /etc | cpio -ov > /dev/rmt0
```

Призначенням може бути наступне:

* стрічковий накопичувач: `/dev/rmt0`;
* розділ: `/dev/sda5`, `/dev/hda5` тощо.

### Тип резервного копіювання

#### Резервне копіювання з відносним шляхом

```bash
cd /
find etc | cpio -o > /backups/etc.cpio
```

#### Резервне копіювання з абсолютним шляхом

```bash
find /etc | cpio -o > /backups/etc.A.cpio
```

!!! Warning "Увага"

    Якщо шлях, указаний у команді `find`, є **абсолютним**, тоді резервне копіювання буде виконано в **абсолютному**.
    
    Якщо шлях, указаний у команді `find`, є **відносним**, тоді резервне копіювання буде виконано у **відносному**.

### Додати до резервної копії

```bash
[files command |] cpio {-o| --create} -A [-options] [<fic-list] {F|>device}
```

Приклад:

```bash
find /etc/shadow | cpio -o -AF SystemFiles.A.cpio
```

Додавання файлів можливе лише на носії прямого доступу.

| Опція | Опис                                                      |
| ----- | --------------------------------------------------------- |
| `-A`  | Додає один або кілька файлів до резервної копії на диску. |
| `-F`  | Визначає резервну копію, яку потрібно змінити.            |

### Стиснення резервної копії

* Збережіть **потім** стисніть

```bash
$ find /etc | cpio  –o > etc.A.cpio
$ gzip /backups/etc.A.cpio
$ ls /backups/etc.A.cpio*
/backups/etc.A.cpio.gz
```

* Зберегти **та** стиснути

```bash
find /etc | cpio –o | gzip > /backups/etc.A.cpio.gz
```

На відміну від команди `tar`, немає можливості зберігати та стискати одночасно. Отже, це робиться в два етапи: збереження та стиснення.

Синтаксис першого методу легше зрозуміти і запам'ятати, оскільки він складається з двох кроків.

Для першого методу файл резервної копії автоматично перейменовується утилітою `gzip`, яка додає `.gz` у кінець імені файлу. Так само утиліта `bzip2` автоматично додає `.bz2`.

### Прочитати вміст резервної копії

Синтаксис команди `cpio` для читання вмісту резервної копії *cpio*:

```bash
cpio -t [-options] [<fic-list]
```

Приклад:

```bash
cpio -tv </backups/etc.152.cpio | less
```

| Опції | Опис                       |
| ----- | -------------------------- |
| `-t`  | Читає резервну копію.      |
| `-v`  | Відображає атрибути файлу. |

Після створення резервної копії необхідно прочитати її вміст, щоб переконатися, що немає помилок.

Таким же чином, перед виконанням відновлення, ви повинні прочитати вміст резервної копії, яка буде використана.

### Відновлення резервної копії

Синтаксис команди `cpio` для відновлення резервної копії:

```bash
cpio {-i| --extract} [-E file] [-options] [<device]
```

Приклад:

```bash
cpio -iv </backups/etc.152.cpio | less
```

| Опції                        | Опис                                                                                  |
| ---------------------------- | ------------------------------------------------------------------------------------- |
| `-i`                         | Відновлює повну резервну копію.                                                       |
| `-E file`                    | Відновлює лише ті файли, ім'я яких міститься у файлі.                                 |
| `--make-directories` or `-d` | Відновлює відсутню структуру дерева.                                                  |
| `-u`                         | Замінює всі файли, навіть якщо вони існують.                                          |
| `--no-absolute-filenames`    | Дозволяє відновити резервну копію, зроблену в абсолютному режимі, у відносний спосіб. |

!!! Важливо

    За замовчуванням, під час відновлення, файли на диску, дата останньої зміни яких є новішою або дорівнює даті резервної копії, не відновлюються (щоб уникнути перезапису останньої інформації старішою).
    
    Параметр `u`, з іншого боку, дозволяє відновити старіші версії файлів.

Приклади:

* Повне відновлення абсолютної резервної копії

```bash
cpio –ivF home.A.cpio
```

* Абсолютне відновлення на існуючій структурі дерева

Параметр `u` дозволяє перезаписувати існуючі файли в тому місці, де відбувається відновлення.

```bash
cpio –iuvF home.A.cpio
```

* Відновлення абсолютної резервної копії у відносному режимі

Довгий параметр `no-absolute-filenames` дозволяє відновлення у відносному режимі. Насправді `/` на початку шляху буде видалено.

```bash
cpio --no-absolute-filenames -divuF home.A.cpio
```

!!! tip "Порада"

    Створення каталогів, можливо, необхідне, тому використовується опція `d`

* Відновлення відносної резервної копії

```bash
cpio –iv <etc.cpio
```

* Повне відновлення файлу або каталогу

Відновлення певного файлу або каталогу вимагає створення файлу списку, який потім потрібно видалити.

```bash
echo "/etc/passwd" > tmp
cpio –iuE tmp -F etc.A.cpio
rm -f tmp
```

## Утиліти компресії - декомпресії

Використання стиснення під час резервного копіювання може мати ряд недоліків:

* Подовжує час резервного копіювання, а також час відновлення.
* Це унеможливлює додавання файлів до резервної копії.

!!! Примітка

    Тому краще зробити резервну копію та стиснути її, ніж стискати під час резервного копіювання.

### Стиснення за допомогою `gzip`

Команда `gzip` стискає дані.

Синтаксис команди `gzip`:

```bash
gzip [options] [file ...]
```

Приклад:

```bash
$ gzip usr.tar
$ ls
usr.tar.gz
```

Файл отримує розширення `.gz`.

Він зберігає ті самі права та ті самі дати останнього доступу та змін.

### Стиснення за допомогою `bunzip2`

Команда `bunzip2` також стискає дані.

Синтаксис команди `bzip2`:

```bash
bzip2 [options] [file ...]
```

Приклад:

```bash
$ bzip2 usr.cpio
$ ls
usr.cpio.bz2
```

Ім’я файлу має розширення `.bz2`.

Стиснення за допомогою `bzip2` краще, ніж стиснення за допомогою `gzip`, але для його виконання потрібно більше часу.

### Декомпресія за допомогою `gunzip`

Команда `gunzip` розпаковує стислі дані.

Синтаксис команди `gunzip`:

```bash
gunzip [options] [file ...]
```

Приклад:

```bash
$ gunzip usr.tar.gz
$ ls
usr.tar
```

Ім’я файлу скорочується за допомогою `gunzip`, а розширення `.gz` видаляється.

`gunzip` також розпаковує файли з такими розширеннями:

* `.z` ;
* `-z` ;
* `_z` .

### Декомпресія за допомогою `bunzip2`

Команда `bunzip2` розпаковує стислі дані.

Синтаксис команди `bzip2`:

```bash
bzip2 [options] [file ...]
```

Приклад:

```bash
$ bunzip2 usr.cpio.bz2
$ ls
usr.cpio
```

Ім’я файлу скорочується на `bunzip2`, а розширення `.bz2` видаляється.

`bunzip2` також розпаковує файл із такими розширеннями:

* `-bz` ;
* `.tbz2` ;
* `tbz` .
