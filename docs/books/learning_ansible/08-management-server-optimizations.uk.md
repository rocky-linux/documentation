---
title: Оптимізація сервера керування
author: Antoine Le Morvan
contributors: Steven Spencer, Ganna Zhyrnova
update: 06 грудня 2021 року
---

# Оптимізація сервера керування

У цьому розділі ми розглянемо параметри конфігурації, які можуть бути цікавими для оптимізації нашого сервера керування Ansible.

## Файл конфігурації `ansible.cfg`

Кілька цікавих параметрів конфігурації для коментарів:

* `forks`: за умовчанням 5, це кількість процесів, які Ansible запускатиме паралельно для зв’язку з віддаленими хостами. Чим вище це число, тим більшою кількістю клієнтів Ansible зможе керувати одночасно, і таким чином пришвидшити обробку. Значення, яке ви можете встановити, залежить від обмежень CPU/RAM вашого сервера керування. Зауважте, що значення за замовчуванням, `5`, дуже мале, у документації Ansible зазначено, що багато користувачів встановлюють його на 50, навіть 500 або більше.

* `gathering`: ця змінна змінює політику збору фактів. За замовчуванням значення є `implicit`, що означає, що факти збиратимуться систематично. Перемикання цієї змінної на `smart` дозволяє отримувати факти збору лише тоді, коли вони ще не зібрані. У поєднанні з кешем фактів (див. нижче) ця опція може значно підвищити продуктивність.

* `host_key_checking`: Будьте обережні з безпекою свого сервера! Однак, якщо ви контролюєте своє середовище, може бути цікаво вимкнути керування ключами віддалених серверів і заощадити час на підключенні. Ви також можете на віддалених серверах вимкнути використання DNS сервера SSH (у `/etc/ssh/sshd_config`, параметр `UseDNS no`), цей параметр витрачає час під час з’єднання та найчастіше використовується лише в журналах з’єднань.

* `ansible_managed`: ця змінна, яка за умовчанням містить `Ansible managed`, зазвичай використовується в шаблонах файлів, які розгортаються на віддалених серверах. Це дозволяє вказати адміністратору, що файл керується автоматично та що будь-які зміни, які вони вносять до нього, потенційно будуть втрачені. Може бути цікаво надати адміністраторам більш повне повідомлення. Будьте обережні, якщо ви зміните цю змінну, це може спричинити перезапуск демонів (через обробники, пов’язані з шаблонами).

* `ssh_args = -C -o ControlMaster=auto -o ControlPersist=300s -o PreferredAuthentications=publickey`: вказує параметри підключення ssh. Вимкнувши всі методи автентифікації, окрім відкритого ключа, можна заощадити багато часу. Ви також можете збільшити `ControlPersist`, щоб покращити продуктивність (документація припускає, що значення, еквівалентне 30 хвилинам, може бути відповідним). З’єднання з клієнтом залишатиметься відкритим довше та може бути повторно використано при повторному підключенні до того самого сервера, що значно економить час.

* `control_path_dir`: вказує шлях до сокетів підключення. Якщо цей шлях занадто довгий, це може спричинити проблеми. Спробуйте змінити його на щось коротке, наприклад `/tmp/.cp`.

* `pipelining`: встановлення цього значення на `True` підвищує продуктивність, зменшуючи кількість підключень SSH, необхідних під час запуску віддалених модулів. Ви повинні спочатку переконатися, що параметр `requiretty` вимкнено в параметрах `sudoers` (див. документацію).

## Кешування фактів

Збір фактів – процес, який може зайняти деякий час. Може бути цікаво вимкнути це збирання для playbooks, яким воно не потрібно (через параметр `gather_facts`) або зберігати ці факти в пам’яті в кеші протягом певного періоду часу (наприклад, 24 години).

Ці факти можна легко зберегти в базі даних `redis`:

```bash
sudo yum install redis
sudo systemctl start redis
sudo systemctl enable redis
sudo pip3 install redis
```

Не забудьте змінити конфігурацію ansible:

```bash
fact_caching = redis
fact_caching_timeout = 86400
fact_caching_connection = localhost:6379:0
```

Щоб перевірити правильність роботи, достатньо запитати сервер `redis`:

```bash
redis-cli
127.0.0.1:6379> keys *
127.0.0.1:6379> get ansible_facts_SERVERNAME
```

## Використання Vault

Різноманітні паролі та секрети не можна зберігати у вигляді відкритого тексту з вихідним кодом Ansible ні локально на сервері керування, ні в можливому менеджері вихідного коду.

Ansible пропонує використовувати менеджер шифрування: `ansible-vault`.

Принцип полягає в шифруванні змінної або цілого файлу за допомогою команди `ansible-vault`.

Ansible зможе розшифрувати цей файл під час виконання, отримавши ключ шифрування з файлу (наприклад) `/etc/ansible/ansible.cfg`. Останній також може бути сценарієм python або іншим.

Відредагуйте файл `/etc/ansible/ansible.cfg`:

```bash
#vault_password_file = /path/to/vault_password_file
vault_password_file = /etc/ansible/vault_pass
```

Збережіть пароль у цьому файлі `/etc/ansible/vault_pass` і призначте необхідні обмежувальні права:

```bash
mysecretpassword
```

Потім ви можете зашифрувати файли за допомогою команди:

```bash
ansible-vault encrypt myfile.yml
```

Файл, зашифрований `ansible-vault`, можна легко розпізнати за його заголовком:

```text
$ANSIBLE_VAULT;1.1;AES256
35376532343663353330613133663834626136316234323964333735363333396136613266383966
6664322261633261356566383438393738386165333966660a343032663233343762633936313630
34373230124561663766306134656235386233323964336239336661653433663036633334366661
6434656630306261650a313364636261393931313739363931336664386536333766326264633330
6334
```

Після того, як файл зашифровано, його все ще можна редагувати за допомогою команди:

```bash
ansible-vault edit myfile.yml
```

Ви також можете перенести своє зберігання паролів у будь-який менеджер паролів.

Наприклад, щоб отримати пароль, який зберігатиметься в сховищі rundeck:

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
import urllib.request
import io
import ssl

def get_password():
    '''
    :return: Vault password
    :return_type: str
    '''
    ctx = ssl.create_default_context()
    ctx.check_hostname = False
    ctx.verify_mode = ssl.CERT_NONE

    url = 'https://rundeck.rockylinux.org/api/11/storage/keys/ansible/vault'
    req = urllib.request.Request(url, headers={
                          'Accept': '*/*',
                          'X-Rundeck-Auth-Token': '****token-rundeck****'
                          })
    response = urllib.request.urlopen(req, context=ctx)

    return response.read().decode('utf-8')

if __name__ == '__main__':
    print(get_password())
```

## Робота з серверами Windows

Необхідно буде встановити на сервер управління кілька пакетів:

* Через менеджер пакетів:

```bash
sudo dnf install python38-devel krb5-devel krb5-libs krb5-workstation
```

і налаштуйте файл `/etc/krb5.conf`, щоб указати правильні `realms`:

```bash
[realms]
ROCKYLINUX.ORG = {
    kdc = dc1.rockylinux.org
    kdc = dc2.rockylinux.org
}
[domain_realm]
  .rockylinux.org = ROCKYLINUX.ORG
```

* Через менеджер пакетів python:

```bash
pip3 install pywinrm
pip3 install pywinrm[credssp]
pip3 install kerberos requests-kerberos
```

## Робота з IP модулями

Для мережевих модулів зазвичай потрібен модуль python `netaddr`:

```bash
sudo pip3 install netaddr
```

## Створення CMDB

Інструмент `ansible-cmdb` був розроблений для створення CMDB з ansible.

```bash
pip3 install ansible-cmdb
```

Факти повинні бути експортовані ansible за допомогою наступної команди:

```bash
ansible --become --become-user=root -o -m setup --tree /var/www/ansible/cmdb/out/
```

Потім ви можете створити глобальний файл `json`:

```bash
ansible-cmdb -t json /var/www/ansible/cmdb/out/linux > /var/www/ansible/cmdb/cmdb-linux.json
```

Якщо ви віддаєте перевагу веб-інтерфейсу:

```bash
ansible-cmdb -t html_fancy_split /var/www/ansible/cmdb/out/
```
