---
title: 6 Профілі
author: Steven Spencer
contributors: Ezequiel Bruni, Ganna Zhyrnova
tested_with: 9.4
tags:
  - incus
  - enterprise
  - Інкус профілі
---

У цій главі ви повинні запускати команди як непривілейований користувач ("incusadmin", якщо ви стежите за цим із початку цієї книги).

Коли ви інсталюєте Incus, вам надається профіль за замовчуванням, який ви не можете видалити чи змінити. Якщо вам потрібен більш детальний доступ до послуги, використовуйте натомість вихідні IP-адреси.

Якщо ви перевірите свій список контейнерів, ви помітите, що IP-адреса в кожному випадку походить з мостового інтерфейсу. У виробничому середовищі ви можете використовувати щось інше. Це може бути призначена DHCP адреса з інтерфейсу локальної мережі або статично призначена адреса з вашої глобальної мережі.

Якщо ви налаштуєте свій сервер Incus із двома інтерфейсами та призначите кожному IP-адресу у своїй WAN та LAN, ви зможете призначити IP-адреси свого контейнера на основі інтерфейсу, до якого контейнер має бути спрямований.

Починаючи з Rocky Linux версії 9.4 (і будь-якої помилки копії помилок Red Hat Enterprise Linux), метод статичного або динамічного призначення IP-адрес із профілями не працює.

Є способи обійти це, але це не дуже приємно. Схоже, це якось пов’язано зі змінами, внесеними в Менеджер мережі, які впливають на `macvlan`. `macvlan` дозволяє створювати багато інтерфейсів з різними адресами рівня 2.

Майте на увазі, що це має недоліки під час вибору зображень контейнерів на основі RHEL.

## Створення профілю `macvlan` і його призначення

Щоб створити свій профіль `macvlan`, скористайтеся цією командою:

```bash
incus profile create macvlan
```

Якщо ви користуєтеся багатоінтерфейсним комп’ютером і вам потрібен більше одного шаблону `macvlan` на основі мережі, яку ви хочете охопити, ви можете використати «lanmacvlan» або «wanmacvlan» або будь-яке інше ім’я, яке ви намагалися використати для ідентифікації профілю. Використання "macvlan" у вашій заяві про створення профілю залежить від вас.

Ви хочете змінити інтерфейс `macvlan`, але перед тим, як це зробити, вам потрібно знати, що таке батьківський інтерфейс для вашого сервера Incus. Цьому інтерфейсу буде призначено IP-адресу локальної мережі (у цьому випадку). Щоб дізнатися, що це за інтерфейс, використовуйте:

```bash
ip addr
```

Шукайте інтерфейс із призначенням IP LAN у мережі 192.168.1.0/24:

```bash
2: enp3s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 40:16:7e:a9:94:85 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.106/24 brd 192.168.1.255 scope global dynamic noprefixroute enp3s0
       valid_lft 4040sec preferred_lft 4040sec
    inet6 fe80::a308:acfb:fcb3:878f/64 scope link noprefixroute
       valid_lft forever preferred_lft forever
```

В цьому випадку інтерфейс буде "enp3s0".

Далі змініть профіль:

```bash
incus profile device add macvlan eth0 nic nictype=macvlan parent=enp3s0
```

Ця команда додає всі параметри до профілю `macvlan`, необхідні для використання.

Перевірте, що створила ця команда за допомогою команди:

```bash
incus profile show macvlan
```

Що дасть вам результат, подібний до цього:

```bash
config: {}
description: ""
devices:
  eth0:
    nictype: macvlan
    parent: enp3s0 
    type: nic
name: macvlan
used_by: []
```

Профілі можна використовувати для багатьох інших речей, але призначення статичної IP-адреси контейнеру або використання власного сервера DHCP є звичайними потребами.

Щоб призначити rockylinux-test-8 профіль `macvlan`, вам потрібно зробити наступне:

```bash
incus profile assign rockylinux-test-8 default,macvlan
```

Зробимо те саме для rockylinux-test-9:

```bash
incus profile assign rockylinux-test-9 default,macvlan
```

Це означає, що вам потрібен профіль за замовчуванням, а також потрібно застосувати профіль `macvlan`.

## Rocky Linux `macvlan`

У дистрибутивах і клонах RHEL мережевий менеджер постійно змінюється. Через це спосіб роботи профілю `macvlan` не працює (принаймні в порівнянні з іншими дистрибутивами) і вимагає додаткової роботи для призначення IP-адрес через DHCP або статично.

Пам’ятайте, що все це не має нічого спільного з Rocky Linux, а лише з реалізацією пакунка вгору.

Якщо ви хочете запустити контейнери Rocky Linux і використовувати `macvlan` для призначення IP-адреси з вашої мережі LAN або WAN, процес буде відрізнятися залежно від версії контейнера операційної системи (8.x або 9.x).

### Rocky Linux 9.0 macvlan – виправлення DHCP

Спочатку давайте проілюструємо, що відбувається під час зупинки та перезапуску двох контейнерів після призначення профілю `macvlan`.

Однак призначення профілю не змінює конфігурацію за замовчуванням, якою за замовчуванням є DHCP.

Щоб перевірити це, просто виконайте такі дії:

```bash
incus restart rocky-test-8
incus restart rocky-test-9
```

Перелічіть свої контейнери ще раз і зауважте, що rockylinux-test-9 більше не має IP-адреси:

```bash
incus list
```

```bash
+-------------------+---------+----------------------+------+-----------+-----------+
|       NAME        |  STATE  |         IPV4         | IPV6 |   TYPE    | SNAPSHOTS |
+-------------------+---------+----------------------+------+-----------+-----------+
| rockylinux-test-8 | RUNNING | 192.168.1.114 (eth0) |      | CONTAINER | 0         |
+-------------------+---------+----------------------+------+-----------+-----------+
| rockylinux-test-9 | RUNNING |                      |      | CONTAINER | 0         |
+-------------------+---------+----------------------+------+-----------+-----------+
| ubuntu-test       | RUNNING | 10.146.84.181 (eth0) |      | CONTAINER | 0         |
+-------------------+---------+----------------------+------+-----------+-----------+
```

Як бачите, ваш контейнер Rocky Linux 8.x отримав IP-адресу від інтерфейсу LAN, тоді як контейнер Rocky Linux 9.x ні.

Щоб детальніше продемонструвати проблему, ви повинні запустити `dhclient` на контейнері Rocky Linux 9.0. Це покаже нам, що _застосовується_ профіль `macvlan`:

```bash
incus exec rockylinux-test-9 dhclient
```

Інший список контейнерів тепер показує наступне:

```bash
+-------------------+---------+----------------------+------+-----------+-----------+
|       NAME        |  STATE  |         IPV4         | IPV6 |   TYPE    | SNAPSHOTS |
+-------------------+---------+----------------------+------+-----------+-----------+
| rockylinux-test-8 | RUNNING | 192.168.1.114 (eth0) |      | CONTAINER | 0         |
+-------------------+---------+----------------------+------+-----------+-----------+
| rockylinux-test-9 | RUNNING | 192.168.1.113 (eth0) |      | CONTAINER | 0         |
+-------------------+---------+----------------------+------+-----------+-----------+
| ubuntu-test       | RUNNING | 10.146.84.181 (eth0) |      | CONTAINER | 0         |
+-------------------+---------+----------------------+------+-----------+-----------+
```

Це мало статися з простою зупинкою та запуском контейнера, але цього не відбувається. Якщо припустити, що ви хочете щоразу використовувати IP-адресу, призначену DHCP, ви можете виправити це простим записом у crontab. Для цього вам потрібно отримати доступ до контейнера, ввівши:

```bash
incus shell rockylinux-test-9
```

Далі визначимо шлях до `dhclient`. Для цього, оскільки цей контейнер створено з мінімального образу, вам потрібно спочатку встановити `which`:

```bash
dnf install which
```

А потім запустіть:

```bash
which dhclient
```

Що поверне:

```bash
/usr/sbin/dhclient
```

Далі змінимо crontab користувача root:

```bash
crontab -e
```

І додайте цей рядок:

```bash
@reboot    /usr/sbin/dhclient
```

Введена команда crontab використовує _vi_. Використовуйте ++shift+двокрапка+"w"+"q"++, щоб зберегти зміни та вийти.

Вийдіть із контейнера та перезапустіть rockylinux-test-9:

```bash
incus restart rockylinux-test-9
```

Інший список показує, що контейнеру призначено адресу DHCP:

```bash
+-------------------+---------+----------------------+------+-----------+-----------+
|       NAME        |  STATE  |         IPV4         | IPV6 |   TYPE    | SNAPSHOTS |
+-------------------+---------+----------------------+------+-----------+-----------+
| rockylinux-test-8 | RUNNING | 192.168.1.114 (eth0) |      | CONTAINER | 0         |
+-------------------+---------+----------------------+------+-----------+-----------+
| rockylinux-test-9 | RUNNING | 192.168.1.113 (eth0) |      | CONTAINER | 0         |
+-------------------+---------+----------------------+------+-----------+-----------+
| ubuntu-test       | RUNNING | 10.146.84.181 (eth0) |      | CONTAINER | 0         |
+-------------------+---------+----------------------+------+-----------+-----------+

```

### Rocky Linux 9.x `macvlan` – виправлення статичної IP-адреси

При статичному призначенні IP-адреси все стає ще заплутанішим. Оскільки `network-scripts` тепер застарілий у Rocky Linux 9.x, єдиним способом зробити це є статичне призначення. Оскільки контейнери використовують мережу, ви не зможете встановити маршрут за допомогою звичайного оператора `ip route`. Проблема полягає в тому, що інтерфейсом, призначеним під час застосування профілю `macvlan` (у цьому випадку eth0), не можна керувати за допомогою Network Manager. Виправлення полягає в перейменуванні мережевого інтерфейсу контейнера після перезапуску та призначенні статичної IP-адреси. Ви можете зробити це за допомогою сценарію та запустити (ще раз) у crontab root. Зробіть це за допомогою команди `ip`.

Для цього вам потрібно знову отримати доступ оболонки до контейнера:

```bash
incus shell rockylinux-test-9
```

Далі ви збираєтеся створити сценарій bash у `/usr/local/sbin` під назвою "static":

```bash
vi /usr/local/sbin/static
```

Зміст цього сценарію не є складним:

```bash
#!/usr/bin/env bash

/usr/sbin/ip link set dev eth0 name net0
/usr/sbin/ip addr add 192.168.1.151/24 dev net0
/usr/sbin/ip link set dev net0 up
sleep 2
/usr/sbin/ip route add default via 192.168.1.1
```

Що саме ви тут робите?

- ви перейменовуєте eth0 на нове ім'я, яким можете керувати ("net0")
- ви призначаєте новий статичний IP, який ви виділили для свого контейнера (192.168.1.151)
- ви відкриваєте новий інтерфейс "net0"
- ви додаєте 2-секундне очікування, поки інтерфейс стане активним, перш ніж додати маршрут за замовчуванням
- вам потрібно додати маршрут за замовчуванням для вашого інтерфейсу

Зробіть свій сценарій виконуваним за допомогою наступного:

```bash
chmod +x /usr/local/sbin/static
```

Додайте це до crontab кореневого користувача для контейнера з часом @reboot:

```bash
@reboot     /usr/local/sbin/static
```

Нарешті, вийдіть з контейнера та перезапустіть його:

```bash
incus restart rockylinux-test-9
```

Зачекайте кілька секунд і знову виведіть список контейнерів:

```bash
incus list
```

Ви повинні побачити успіх:

```bash
+-------------------+---------+----------------------+------+-----------+-----------+
|       NAME        |  STATE  |         IPV4         | IPV6 |   TYPE    | SNAPSHOTS |
+-------------------+---------+----------------------+------+-----------+-----------+
| rockylinux-test-8 | RUNNING | 192.168.1.114 (eth0) |      | CONTAINER | 0         |
+-------------------+---------+----------------------+------+-----------+-----------+
| rockylinux-test-9 | RUNNING | 192.168.1.151 (eth0) |      | CONTAINER | 0         |
+-------------------+---------+----------------------+------+-----------+-----------+
| ubuntu-test       | RUNNING | 10.146.84.181 (eth0) |      | CONTAINER | 0         |
+-------------------+---------+----------------------+------+-----------+-----------+
```

## Ubuntu macvlan

На щастя, реалізація Network Manager в Ubuntu не порушує стек `macvlan`, що значно полегшує розгортання!

Як і у випадку з вашим контейнером rockylinux-test-9, вам потрібно призначити профіль для вашого контейнера:

```bash
incus profile assign ubuntu-test default,macvlan
```

Щоб дізнатися, чи DHCP призначає адресу контейнеру, зупиніть і знову запустіть контейнер:

```bash
incus restart ubuntu-test
```

Потім знову перерахуйте контейнери:

```bash
+-------------------+---------+----------------------+------+-----------+-----------+
|       NAME        |  STATE  |         IPV4         | IPV6 |   TYPE    | SNAPSHOTS |
+-------------------+---------+----------------------+------+-----------+-----------+
| rockylinux-test-8 | RUNNING | 192.168.1.114 (eth0) |      | CONTAINER | 0         |
+-------------------+---------+----------------------+------+-----------+-----------+
| rockylinux-test-9 | RUNNING | 192.168.1.151 (eth0) |      | CONTAINER | 0         |
+-------------------+---------+----------------------+------+-----------+-----------+
| ubuntu-test       | RUNNING | 192.168.1.132 (eth0) |      | CONTAINER | 0         |
+-------------------+---------+----------------------+------+-----------+-----------+
```

Успішно!

Налаштування статичної IP-адреси трохи відрізняється, але не складно. Ви повинні змінити файл `.yaml`, пов’язаний із підключенням контейнера (`10-incus.yaml`). Для цього статичного IP ви будете використовувати 192.168.1.201:

```bash
vi /etc/netplan/10-incus.yaml
```

Змініть те, що є, на таке:

```bash
network:
  version: 2
  ethernets:
    eth0:
      dhcp4: false
      addresses: [192.168.1.201/24]
      gateway4: 192.168.1.1
      nameservers:
        addresses: [8.8.8.8,8.8.4.4]
```

Будь ласка, збережіть зміни та залиште контейнер.

Перезапустіть контейнер:

```bash
incus restart ubuntu-test
```

Коли ви знову перерахуєте свої контейнери, ви побачите нашу нову статичну IP-адресу:

```bash
+-------------------+---------+----------------------+------+-----------+-----------+
|       NAME        |  STATE  |         IPV4         | IPV6 |   TYPE    | SNAPSHOTS |
+-------------------+---------+----------------------+------+-----------+-----------+
| rockylinux-test-8 | RUNNING | 192.168.1.114 (eth0) |      | CONTAINER | 0         |
+-------------------+---------+----------------------+------+-----------+-----------+
| rockylinux-test-9 | RUNNING | 192.168.1.151 (eth0) |      | CONTAINER | 0         |
+-------------------+---------+----------------------+------+-----------+-----------+
| ubuntu-test       | RUNNING | 192.168.1.201 (eth0) |      | CONTAINER | 0         |
+-------------------+---------+----------------------+------+-----------+-----------+

```

Успішно!

У прикладах, які тут використовуються, навмисно було обрано складний контейнер для налаштування та два менш складних. У списку зображень багато інших версій Linux. Якщо у вас є улюблений, спробуйте встановити його, призначити шаблон `macvlan` і налаштувати IP-адреси.
